<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="安₃">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="安₃">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安₃">






  <link rel="canonical" href="http://yoursite.com/page/4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>安₃</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<!--github start-->
	<a href="https://github.com/awcnoanswer" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	<!--github end-->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安₃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/xd-WEB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/xd-WEB/" itemprop="url">
                  xd-WEB
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-25 22:57:57" itemprop="dateCreated datePublished" datetime="2018-12-25T22:57:57+08:00">2018-12-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:38:29" itemprop="dateModified" datetime="2019-03-08T14:38:29+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Web容器"><a href="#Web容器" class="headerlink" title="Web容器"></a>Web容器</h1><ul>
<li>所有的程序运行都需要有一个必要的运行环境。这个环境可以是软件，也可以是硬件，或者是软件和硬件的结合。比如说Windows操作系统需要运行在硬件基础上；Office软件需要运行在操作系统上。并且程序与运行环境之间会有一定的数据交换，比如操作系统会将运行指令传递给硬件，硬件也会将指令运行结果传递给操作系统</li>
<li>Java Web程序也需要一个运行环境才能够执行。这种运行Java Web程序的环境被称为Web容器，Java Web程序与Web容器之间存在数据交互。</li>
</ul>
<h2 id="独立的Java-Web容器"><a href="#独立的Java-Web容器" class="headerlink" title="独立的Java Web容器"></a>独立的Java Web容器</h2><ul>
<li>在这种容器里面只能运行Web程序，这种容器一般也叫做Web服务器，如Tomcat</li>
</ul>
<h2 id="与其他Java-EE容器混合在一起的Web容器"><a href="#与其他Java-EE容器混合在一起的Web容器" class="headerlink" title="与其他Java EE容器混合在一起的Web容器"></a>与其他Java EE容器混合在一起的Web容器</h2><ul>
<li>Web容器负责运行Web程序，其他容器负责运行EJB等程序，如WebLogic</li>
</ul>
<h2 id="web容器与web应用间的数据交互"><a href="#web容器与web应用间的数据交互" class="headerlink" title="web容器与web应用间的数据交互"></a>web容器与web应用间的数据交互</h2><ul>
<li>web容器接收客户端请求封装<strong>HttpServletRequest</strong>对象，并传递给web应用</li>
<li>web应用处理请求</li>
<li>web容器将结果封装到<strong>HttpServletResponse</strong>对象，响应给客户端</li>
<li>注<ul>
<li>这两个对象仅存在于Web容器和Web应用当中，与浏览器没有关系</li>
</ul>
</li>
</ul>
<h2 id="tomcat和servlet的区别"><a href="#tomcat和servlet的区别" class="headerlink" title="tomcat和servlet的区别"></a>tomcat和servlet的区别</h2><ul>
<li>Tomcat 是Web应用服务器,是一个Servlet/JSP容器</li>
<li>servlet是一种运行在服务器端的Java应用程序</li>
</ul>
<h2 id="web应用服务器"><a href="#web应用服务器" class="headerlink" title="web应用服务器"></a>web应用服务器</h2><ul>
<li><code>tomcat</code><ul>
<li>支持servlet/jsp规范</li>
</ul>
</li>
<li><code>weblogic</code><ul>
<li>支持全部j2ee规范</li>
</ul>
</li>
<li><code>websphere</code><ul>
<li>支持全部j2ee规范</li>
</ul>
</li>
<li><code>jboss</code></li>
</ul>
<h1 id="标准JavaWeb应用目录结构"><a href="#标准JavaWeb应用目录结构" class="headerlink" title="标准JavaWeb应用目录结构"></a>标准JavaWeb应用目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyApp  				//项目名</span><br><span class="line">	html,css,js,img... //资源文件</span><br><span class="line">	WEB-INF</span><br><span class="line">		classes	    //.class文件，配置文件</span><br><span class="line">		lib			// jar包</span><br><span class="line">		web.xml		//web配置文件</span><br></pre></td></tr></table></figure>
<ul>
<li>说明<ul>
<li>ide中的src目录<ul>
<li>编译后会存在web-inf下的classes中。</li>
</ul>
</li>
<li>以下三个目录中的文件会直接存在应用下，与web-inf同级，相当于资源文件<ul>
<li>eclipse中的WebContent目录</li>
<li>Myeclipse中的WebRoot目录</li>
<li>intellij中的web目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul>
<li>Tomcat启动时，需要查找<code>CATALINA_HOME</code>这个环境变量<ul>
<li>判断<code>CATALINA_HOME</code>环境变量是否为空<ul>
<li>为空<ul>
<li>就将当前目录设为CATALINA_HOME的值，接着判断当前目录下是否存在<code>bin\catalina.bat</code>，如果文件不存在，将当前目录的父目录设为<code>CATALINA_HOM</code>E的值，循环，最后如果找不到<code>bin\catalina.bat</code>就报错。</li>
</ul>
</li>
<li>不为空<ul>
<li>通过这个环境变量调用<code>bin\catalina.bat</code>命令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>执行<code>startup.bat</code>命令，会自动去执行<code>catalina.bat start</code>命令</li>
</ul>
<p>##<code>CATALINA_HOME</code>和<code>CATALINA_BASE</code>区别</p>
<h3 id="CATALINA-HOME"><a href="#CATALINA-HOME" class="headerlink" title="CATALINA_HOME"></a>CATALINA_HOME</h3><ul>
<li>是Tomcat的安装目录</li>
<li>类似于<code>JAVA_HOME</code>环境变量</li>
<li>如果配置了就能在任意路径执行bin目录下的bat或者exe</li>
<li>通常不配置</li>
</ul>
<h3 id="CATALINA-BASE"><a href="#CATALINA-BASE" class="headerlink" title="CATALINA_BASE"></a>CATALINA_BASE</h3><ul>
<li>是Tomcat的工作目录</li>
<li>如果CATALINA_BASE没有值的话，它默认的值就是CATALINA_HOME</li>
</ul>
<h3 id="tomcat目录"><a href="#tomcat目录" class="headerlink" title="tomcat目录"></a>tomcat目录</h3><ul>
<li>其中只有 bin 和 lib 目录被多个tomcat示例公用</li>
<li>其它目录conf、logs、temp、webapps和work 每个Tomcat实例必须拥有其自己独立的备份</li>
<li>catalina.home(安装目录)：<ul>
<li>指向公用信息的位置，就是bin和lib的父目录</li>
</ul>
</li>
<li>catalina.base(工作目录)：<ul>
<li>指向每个Tomcat目录私有信息的位置，就是conf、logs、temp、webapps和work的父目录。</li>
</ul>
</li>
<li>仅运行一个Tomcat实例时，这两个属性指向的位置是相同的</li>
</ul>
<h3 id="网上自建startup-bat的内容"><a href="#网上自建startup-bat的内容" class="headerlink" title="网上自建startup.bat的内容"></a>网上自建<code>startup.bat</code>的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set &quot;CATALINA_BASE=%cd%&quot;  </span><br><span class="line">set &quot;CATALINA_HOME=D:/save/apache-tomcat-8.0.48&quot;  </span><br><span class="line">set &quot;EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat&quot;  </span><br><span class="line">call &quot;%EXECUTABLE%&quot; start</span><br></pre></td></tr></table></figure>
<ul>
<li><code>%cd%</code><ul>
<li>代表当前目录（不太确定）</li>
</ul>
</li>
<li><code>CATALINA_BASE</code>就代表一个tomcat的运行实例<ul>
<li>包含<code>conf</code>,logs,temp,webapps,work`的目录。</li>
</ul>
</li>
<li><code>CATALINA_HOME</code>代表了一个tomcat，需要tomcat的<code>bin,lib...</code></li>
<li>启动tomcat后，<code>CATALINA_BASE</code>指向哪个tomcat实例，就运行哪个。<ul>
<li>比如我有一个tomcat8080，然后再另一个文件夹复制了一个<code>conf</code>并设置端口号为7070</li>
<li><code>CATALINA_HOME</code>为tomcat8080安装目录，设置<code>CATALINA_BASE</code>为7070对应的目录，那么能访问的是7070而非8080,</li>
<li><strong>虚拟目录</strong>貌似就是这个原理。</li>
</ul>
</li>
</ul>
<h2 id="tomcat部署应用"><a href="#tomcat部署应用" class="headerlink" title="tomcat部署应用"></a>tomcat部署应用</h2><h3 id="部署形式"><a href="#部署形式" class="headerlink" title="部署形式"></a>部署形式</h3><ol>
<li>项目文件夹</li>
<li>war包<ul>
<li>tomcat会自动判断war包并解压。</li>
</ul>
</li>
</ol>
<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><h4 id="一-将项目复制到tomcat-webapps目录下。"><a href="#一-将项目复制到tomcat-webapps目录下。" class="headerlink" title="一 将项目复制到tomcat/webapps目录下。"></a>一 将项目复制到<code>tomcat/webapps</code>目录下。</h4><ul>
<li>Myeclipse就是这种方式。</li>
</ul>
<h4 id="二-虚拟目录"><a href="#二-虚拟目录" class="headerlink" title="二 虚拟目录"></a>二 虚拟目录</h4><ul>
<li>就是把项目放到其它位置通过一些配置也能一样访问。(安)</li>
</ul>
<h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h5><ul>
<li><p><code>tomcat/conf/server.xml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Host&gt;</span><br><span class="line">	&lt;Context docBase=&quot;应用的真实路径&quot; path=&quot;网络访问的虚拟目录名(自定义)&quot; /&gt;</span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Eclipse使用这种方式</p>
<ul>
<li><code>Catalina_Base</code><ul>
<li><code>workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps</code></li>
</ul>
</li>
</ul>
</li>
<li>不推荐，修改需要重启tomcat</li>
</ul>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><ul>
<li><p><code>tomcat/conf/catalina/localhost</code></p>
<ul>
<li>新建<code>虚拟目录名(自定义).xml</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context docBase=&quot;应用的真实路径&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Intellij使用这种方式</p>
<ul>
<li><code>Catalina_Base</code><ul>
<li><code>Intellij/system/tomcat/</code></li>
</ul>
</li>
</ul>
</li>
<li>支持热部署，修改不用重启tomcat</li>
<li>如果新建的<code>虚拟目录名</code>为<code>ROOT</code>，则访问时，可以不写<ul>
<li>Intellij就是这样做的</li>
</ul>
</li>
</ul>
<h2 id="tomcat的访问"><a href="#tomcat的访问" class="headerlink" title="tomcat的访问"></a>tomcat的访问</h2><ul>
<li><code>http://ip:端口/应用/资源</code></li>
</ul>
<h3 id="默认端口"><a href="#默认端口" class="headerlink" title="默认端口"></a>默认端口</h3><ul>
<li>http协议端口为80</li>
<li>把tomcat端口设为80就不用写端口了</li>
</ul>
<h3 id="默认应用"><a href="#默认应用" class="headerlink" title="默认应用"></a>默认应用</h3><ul>
<li>tomcat默认访问ROOT应用<br>  *（见上边虚拟目录）</li>
</ul>
<h3 id="默认主页"><a href="#默认主页" class="headerlink" title="默认主页"></a>默认主页</h3><ul>
<li><code>web.xml</code>中配置</li>
</ul>
<h2 id="idea中tomcat的部署"><a href="#idea中tomcat的部署" class="headerlink" title="idea中tomcat的部署"></a>idea中tomcat的部署</h2><h3 id="war"><a href="#war" class="headerlink" title="war"></a><code>war</code></h3><ul>
<li>将web工程以war包的形式上传到服务器</li>
<li>可以称之为是发布模式，看名字也知道，这是先打包war包，再发布</li>
<li><code>request.getServletContext().getRealPath(&quot;/&quot;)</code><ul>
<li><code>D:\save\apache-tomcat-8.0.48\webapps\ROOT\</code></li>
<li>结果是tomcat的webapps的Root目录</li>
<li>会把Root目录项目替换成此项目<ul>
<li>此种情况是配置tomcat时application context选择了<code>/</code></li>
<li>如果配置成别的如<code>/aaa</code><ul>
<li>则不会替换Root，而是在webapps下创建aaa</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="war-exploed"><a href="#war-exploed" class="headerlink" title="war exploed"></a><code>war exploed</code></h3><ul>
<li>将web工程以当前文件夹的位置关系上传到服务器</li>
<li>展开部署(相当于将资源文件进行展开后进行部署)</li>
<li>直接把文件夹，jsp页面，classes等等移到Tomcat部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。</li>
<li><code>request.getServletContext().getRealPath(&quot;/&quot;)</code><ul>
<li><code>D:\save\IntellijWP\project\HelloMaven\target\HelloMaven-1.0-SNAPSHOT\</code></li>
<li>可以看到是项目target下的目录</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Servlet/" itemprop="url">
                  xd-Servlet
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:38:28" itemprop="dateCreated datePublished" datetime="2018-12-11T00:38:28+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:38:38" itemprop="dateModified" datetime="2019-03-08T14:38:38+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>server applet</code><ul>
<li>运行在服务端的小程序</li>
</ul>
</li>
<li>客户端请求服务器动态资源时，怎么就是动态资源呢？需要写代码逻辑来实现动态，也就是java类。而这种java类不是自己使用main方法执行的，而是依赖服务器执行的。那么什么样的java类服务器都认可吗？这就要求java类符合一定的规范，这规范就是Servlet</li>
<li>Servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则。</li>
</ul>
<h2 id="Servlet规范包含三个技术点"><a href="#Servlet规范包含三个技术点" class="headerlink" title="Servlet规范包含三个技术点"></a>Servlet规范包含三个技术点</h2><ul>
<li>servlet技术</li>
<li>filter技术</li>
<li>listener技术</li>
</ul>
<h1 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h1><p><img src="https://gitee.com/3noanswer/pics/raw/master/Servle体系图.png" alt=""></p>
<h1 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h1><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>默认第一请求访问时实例化servlet</li>
<li><p>通过配置<code>&lt;load-on-startup&gt;</code>服务器一启动就实例化servlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;load-on-startup&gt;x&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>x&gt;0<ul>
<li>web容器启动的时候做实例化处理，顺序是由小到大，正整数小的先被实例化(1-2-3…)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li><code>init(ServletConfig config)</code><ul>
<li>只会调用一次</li>
<li>说明<strong>Servlet是单例</strong>的<ul>
<li>不要使用成员变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><ul>
<li><code>service(ServletRequest req, ServletResponse res)</code><ul>
<li>每次请求都会调用</li>
</ul>
</li>
</ul>
<h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><ul>
<li><code>destroy()</code><ul>
<li>只会调用一次</li>
<li>在Servlet销毁前调用，服务器关闭，Servlet销毁</li>
<li>tomcat正常关闭,才会调用</li>
</ul>
</li>
</ul>
<h1 id="Servelt执行过程"><a href="#Servelt执行过程" class="headerlink" title="Servelt执行过程"></a>Servelt执行过程</h1><ol>
<li>客户端发送请求<code>http://localhost:8080/应用名/资源名</code></li>
<li>tomcat接收请求</li>
<li>tomcat根据请求路径<ul>
<li><code>应用名</code><ul>
<li>查找tomcat服务器下是否有此名称应用</li>
</ul>
</li>
<li><code>资源名</code><ul>
<li>查找<code>web.xml</code>的<code>&lt;url-pattern&gt;</code>是否有次资源名</li>
<li>根据<code>&lt;url-pattern&gt;</code>匹配到相应的<code>&lt;Servlet-name&gt;</code></li>
<li>根据<code>&lt;Servlet-name&gt;</code>匹配到相应的<code>&lt;Servlet-class&gt;</code></li>
<li>根据<code>&lt;Servlet-class&gt;</code>的全类名通过反射将字节码文件加载进内存</li>
<li>然后通过反射创建Servlet对象(默认第一次访问创建)，初始化…</li>
<li>然后调用<code>service()</code></li>
</ul>
</li>
</ul>
</li>
<li>响应数据给客户端。</li>
</ol>
<h1 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h1><ol>
<li>实现Servlet接口(不推荐)</li>
<li>继承GenericServlet(不推荐)</li>
<li>继承HttpServlet(常用)</li>
</ol>
<h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><ul>
<li>一个Servlet可以有多个匹配路径，即<code>url-pattern</code>的值可以有多个</li>
</ul>
<h2 id="映射规则"><a href="#映射规则" class="headerlink" title="映射规则"></a>映射规则</h2><ul>
<li><code>/xxx/xx/x</code><ul>
<li>绝对匹配    </li>
</ul>
</li>
<li><code>/*</code><ul>
<li>拦截所有</li>
</ul>
</li>
<li><code>*.do</code><ul>
<li>指定扩展名</li>
</ul>
</li>
<li>优先级<ul>
<li><code>绝对匹配 &gt; /开头匹配 &gt; 扩展名方式匹配</code></li>
</ul>
</li>
</ul>
<h2 id="为什么可以访问xxx-jsp-安"><a href="#为什么可以访问xxx-jsp-安" class="headerlink" title="为什么可以访问xxx.jsp(安)"></a>为什么可以访问<code>xxx.jsp</code>(安)</h2><h3 id="DefaultServlet"><a href="#DefaultServlet" class="headerlink" title="DefaultServlet"></a><code>DefaultServlet</code></h3><ul>
<li>缺省Servlet     </li>
<li>其实web服务器中的资源(包含静态资源)都是由servlet响应的</li>
<li><p>tomcat中<code>/conf/web.xml</code>中的默认配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;default&lt;servlet-name&gt;</span><br><span class="line">		&lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;jsp&lt;servlet-name&gt;</span><br><span class="line">		&lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">// ------------------------------------------------------------------</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">		&lt;servlet-name&gt;default&lt;servlet-name&gt;</span><br><span class="line">		&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">		&lt;servlet-name&gt;jsp&lt;servlet-name&gt;</span><br><span class="line">		&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">		&lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看出对于所有资源如果没有优先的匹配<ul>
<li>默认找的是<code>DefaultServlet</code></li>
<li>我们配置<code>/</code>会覆盖默认</li>
</ul>
</li>
<li>对于<code>.jsp .jspx</code>默认找的是<code>JspServlet</code></li>
</ul>
</li>
</ul>
<h2 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h2><ul>
<li>支持注解</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="WebServlet"><a href="#WebServlet" class="headerlink" title="@WebServlet"></a><code>@WebServlet</code></h4><ul>
<li><code>String name() default &quot;&quot;</code><ul>
<li>相当于<code>&lt;Servlet-name&gt;</code></li>
</ul>
</li>
<li><code>String[] value() default {}</code><ul>
<li>代表<code>urlPatterns()</code>属性配置</li>
</ul>
</li>
<li><code>String[] urlPatterns() default {}</code><ul>
<li>相当于<code>&lt;url-pattern&gt;</code></li>
</ul>
</li>
<li><code>int loadOnStartup() default -1</code></li>
<li><code>WebInitParam[] initParams() default {}</code></li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>由于注解作用在类上，所以不用配置<code>&lt;servlet-name&gt;</code>来匹配<code>&lt;servlet-class&gt;</code>了，即不用配置<code>name</code></li>
<li>只需配置<code>urlPattern()</code>即可找到servlet，而<code>value</code>又代表了<code>urlPatterns()</code>的值，所以配置<code>value</code>也是一样的，而注解中如果只配一项，而此项名称又是<code>value</code>，<code>value</code>是可以省略的。</li>
<li>所以直接配置虚拟目录值即可<ul>
<li><code>@WebServlet(&quot;/虚拟目录1&quot;, &quot;/虚拟目录2&quot;, &quot;...&quot;)</code></li>
</ul>
</li>
</ul>
<h1 id="Interface-Servlet"><a href="#Interface-Servlet" class="headerlink" title="Interface Servlet"></a>Interface Servlet</h1><ul>
<li>所有servlet都要直接或间接实现此接口</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>void init(ServletConfig config)</code>    </li>
<li><code>void service(ServletRequest req, ServletResponse res)</code></li>
<li><code>void destroy()</code></li>
<li><code>ServletConfig getServletConfig()</code></li>
<li><code>String getServletInfo()</code><ul>
<li>获取servlet信息(作者,版本,版权…)</li>
</ul>
</li>
</ul>
<h1 id="Interface-ServletConfig"><a href="#Interface-ServletConfig" class="headerlink" title="Interface ServletConfig"></a>Interface ServletConfig</h1><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>ServletContext getServletContext()</code></li>
<li><code>String getInitParameter(String name)</code><ul>
<li>由当前servlet配置信息的键获取值</li>
</ul>
</li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code><ul>
<li>获取当前servlet配置信息的名称的枚举</li>
</ul>
</li>
<li><p>当前servlet配置信息在web.xm中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;servelt&gt;</span><br><span class="line">		&lt;init-param&gt;</span><br><span class="line">			&lt;param-name&gt;&lt;/param-name&gt;</span><br><span class="line">			&lt;param-value&gt;&lt;/param-value&gt;</span><br><span class="line">		&lt;/init-param&gt;</span><br><span class="line">&lt;/servelt&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String getServletName()</code></p>
<ul>
<li>获取servlet名字</li>
</ul>
</li>
</ul>
<h1 id="abstract-class-GenericServlet"><a href="#abstract-class-GenericServlet" class="headerlink" title="abstract class GenericServlet"></a>abstract class GenericServlet</h1><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>void init(ServletConfig config)</code><ul>
<li>实现的接口Servlet的<code>void init(ServletConfig config)</code>方法</li>
<li>此有参init(ServletConfig config)内部调用了<code>GenericServlet</code>特有的无参init()</li>
</ul>
</li>
<li><code>void init()</code><ul>
<li>GenericServlet类的特有方法</li>
<li>内容为空,是为了让程序员做一些其它事情，比如做了一些自定义初始化，有参初始化init()方法会自动调用此无参方法。(安)</li>
</ul>
</li>
</ul>
<h1 id="abstract-class-HttpServlet"><a href="#abstract-class-HttpServlet" class="headerlink" title="abstract class HttpServlet"></a>abstract class HttpServlet</h1><h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>void doGet(HttpServletRequest req, HttpServletResponse res)</code></li>
<li><code>void doPost(HttpServletRequest req, HttpServletResponse res)</code></li>
<li><code>void doXxx()</code><ul>
<li>其它doxxx方法。</li>
</ul>
</li>
<li><code>void service(ServletRequest req, ServletResponse res)</code><ul>
<li>覆写父类<code>GenericServlet</code>的<code>service()</code>方法</li>
</ul>
</li>
<li><code>void service(HttpServletRequest req, HttpServletResponse res)</code><ul>
<li><code>HttpServlet</code>特有的<code>service()</code>方法。</li>
</ul>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>每次请求都会执行<code>service()</code>方法，<code>HttpServlet</code>重写了此方法，此方法内部<ul>
<li>判断是否是http请求<ul>
<li>否<ul>
<li>则抛出非http请求异常</li>
</ul>
</li>
<li>是<ul>
<li>则调用<code>HttpServlet</code>特有的<code>service()</code>方法</li>
<li>特有的<code>service()</code>方法内部<ul>
<li>通过请求对象req获取请求方法名<ul>
<li>get 则调用本类<code>doGet()</code>方法</li>
<li>post 则调用本类<code>doPost()</code>方法</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>所以我们继承<code>HtttpServlet</code>的servlet只需要覆写<code>doGet()</code>或<code>doPost()</code>即可</li>
</ul>
<h1 id="Interface-ServletContext"><a href="#Interface-ServletContext" class="headerlink" title="Interface ServletContext"></a>Interface ServletContext</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>代表整个应用，一个应用对应一个ServletContext，可以和程序的容器(服务器)来通信</li>
</ul>
<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><ol>
<li><code>ServletContext getServletContext()</code><ul>
<li><code>ServletConfig</code>接口的方法</li>
<li>由于我们的servlet是实现了<code>ServletConftig</code>接口的，所以直接调用此接方法获取即可<ul>
<li><code>this.getServletContext()</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ServletContext getServletContext()</code><ul>
<li><code>HttpServletRequest</code>接口中的方法</li>
<li>使用request对象获取<ul>
<li><code>request.getServletContext()</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="获取MIME类型"><a href="#获取MIME类型" class="headerlink" title="获取MIME类型"></a>获取MIME类型</h3><ul>
<li><code>String getMimeType(String file)</code></li>
</ul>
<h4 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h4><ul>
<li>在互联网通信过程中定义的一种文件数据类型</li>
<li>格式<ul>
<li><code>大类型/小类型</code>   <ul>
<li><code>text/html</code></li>
<li><code>image/jpeg</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="域对象"><a href="#域对象" class="headerlink" title="域对象"></a>域对象</h3><ul>
<li><code>void setAttribute(String key,Object obj)</code></li>
<li><code>Object getAttribute(String key)</code></li>
<li><code>void removeAttribute(String key)</code></li>
</ul>
<h3 id="获取文件真实-服务器-路径"><a href="#获取文件真实-服务器-路径" class="headerlink" title="获取文件真实(服务器)路径"></a>获取文件真实(服务器)路径</h3><ul>
<li><code>String getRealPath(String path)</code><ul>
<li>应用下任何路径的资源都可以获取。</li>
<li><code>path</code><ul>
<li>为资源相对路径以<code>/</code>开头</li>
<li>注意这个相对路径说的是最终标准web应用结构时的相对路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="src下的资源xxx"><a href="#src下的资源xxx" class="headerlink" title="src下的资源xxx"></a>src下的资源xxx</h4><ul>
<li><code>getServletContext().getRealPath(&quot;/WEB-INF/classes/xxx&quot;)</code><ul>
<li>src中的资源最后会在<code>WEB-INF/classes</code>中</li>
<li>对于<code>WEB-INF/classes</code>下的资源还有一种获取方式<ul>
<li><code>MyServlet.class.getClassloader().getResource(&quot;xxx&quot;).getPath()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="web下的资源xxx"><a href="#web下的资源xxx" class="headerlink" title="web下的资源xxx"></a>web下的资源xxx</h4><ul>
<li><code>getServletContext().getRealPath(&quot;/xxx&quot;)</code><ul>
<li>web下的资源最后就在应用下</li>
</ul>
</li>
</ul>
<h4 id="WEB-INF下的资源xxx"><a href="#WEB-INF下的资源xxx" class="headerlink" title="WEB-INF下的资源xxx"></a>WEB-INF下的资源xxx</h4><ul>
<li><code>getServletContext().getRealPath(&quot;/WEB-INF/xxx&quot;)</code></li>
</ul>
<h4 id="应用下与src-web同级的资源"><a href="#应用下与src-web同级的资源" class="headerlink" title="应用下与src,web同级的资源"></a>应用下与src,web同级的资源</h4><ul>
<li>获取不到，因为这个位置最后不会发布到web应用中</li>
</ul>
<h3 id="获取全局配置信息"><a href="#获取全局配置信息" class="headerlink" title="获取全局配置信息"></a>获取全局配置信息</h3><ul>
<li><code>String getInitParameter(String name)</code></li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code></li>
<li>全局配置信息在web.xml中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><ul>
<li><code>RequestDispatcher getRequestDispatcher(String path)</code></li>
</ul>
<h1 id="Request-请求"><a href="#Request-请求" class="headerlink" title="Request(请求)"></a>Request(请求)</h1><h2 id="体系-1"><a href="#体系-1" class="headerlink" title="体系"></a>体系</h2><ul>
<li><code>ServletRequest</code><ul>
<li><code>HttpServletRequest</code><ul>
<li><code>org.apache.catalina.connector.RequestFacade</code><ul>
<li>tomcat的实现类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><h3 id="1-获取请求信息"><a href="#1-获取请求信息" class="headerlink" title="1. 获取请求信息"></a>1. 获取请求信息</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><ul>
<li><strong><code>String getContextPath()</code></strong><ul>
<li>获取虚拟目录</li>
</ul>
</li>
<li><code>getServletPath()</code><ul>
<li>获取servlet路径</li>
</ul>
</li>
<li><code>getMethod()</code><ul>
<li>获取请求方法名</li>
</ul>
</li>
<li><code>getRequestURL()</code></li>
<li><code>getRequestURI()</code></li>
<li><code>getQueryString()</code><ul>
<li>获取get请求参数</li>
</ul>
</li>
<li><code>String getProtocol()</code><ul>
<li>获取协议及版本<code>HTTP/1.1</code></li>
</ul>
</li>
<li><code>getRomoteAddr()</code><ul>
<li>获取访问的客户端的ip地址</li>
</ul>
</li>
</ul>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><ul>
<li><code>String getHeader(String name)</code></li>
<li><code>Enumeration&lt;String&gt; getHeaderNames()</code></li>
</ul>
<h4 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h4><ul>
<li>只有post请求才有请求体，post请求将请求体封装成了流，所以要获取请求体，<ol>
<li>先要获取流</li>
<li>然后从流中获取数据</li>
</ol>
</li>
<li><code>BufferedReader getReader()</code></li>
<li><code>ServletInputStream getInputStream()</code></li>
</ul>
<h3 id="2-其它功能"><a href="#2-其它功能" class="headerlink" title="2. 其它功能"></a>2. 其它功能</h3><h4 id="通用获取请求参数"><a href="#通用获取请求参数" class="headerlink" title="通用获取请求参数"></a>通用获取请求参数</h4><ul>
<li><strong><code>String getParameter(String name)</code></strong><ul>
<li>根据请求name获取value</li>
</ul>
</li>
<li><code>Map&lt;String,String[]&gt; getParameterMap()</code><ul>
<li>获取所有请求的键值map</li>
</ul>
</li>
<li><code>String[] getParameterValues(String name)</code><ul>
<li>根据请求name获取value数组</li>
</ul>
</li>
<li><code>Enumeration&lt;String&gt; getParameterNames()</code><ul>
<li>获取所有请求name的枚举</li>
</ul>
</li>
</ul>
<h5 id="请求乱码问题"><a href="#请求乱码问题" class="headerlink" title="请求乱码问题"></a>请求乱码问题</h5><h6 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h6><ul>
<li>tomcat8以后已经将get乱码解决了</li>
</ul>
<h6 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h6><ul>
<li><code>void setCharacterEncoding(String env)</code><ul>
<li>告诉服务器用什么编码接收请求参数</li>
<li>获取参数前设置</li>
</ul>
</li>
</ul>
<h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><ul>
<li><code>RequestDispatcher getRequestDispatcher(String path)</code><ul>
<li>获取RequestDispatcher对象</li>
</ul>
</li>
</ul>
<h5 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="RequestDispatcher"></a>RequestDispatcher</h5><ul>
<li><code>void forward(ServletRequest req, ServletResponse res)</code></li>
<li><code>void include(ServletRequest req, ServletResponse res)</code></li>
</ul>
<h4 id="域对象-1"><a href="#域对象-1" class="headerlink" title="域对象"></a>域对象</h4><ul>
<li><code>void setAttribute(String name, Object obj)</code></li>
<li><code>Object getAttribute(String name)</code></li>
<li><code>void removeAttribute(String name)</code></li>
</ul>
<h4 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h4><ul>
<li><code>ServletContext getServletContext()</code></li>
</ul>
<h1 id="Response-响应"><a href="#Response-响应" class="headerlink" title="Response(响应)"></a>Response(响应)</h1><h2 id="体系-2"><a href="#体系-2" class="headerlink" title="体系"></a>体系</h2><ul>
<li><code>ServletResponse</code><ul>
<li><code>HttpServletResponse</code></li>
</ul>
</li>
</ul>
<h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><ul>
<li><code>void setStatus(int sc)</code><ul>
<li>设置状态码</li>
</ul>
</li>
</ul>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><ul>
<li><code>void setHeader(String name, String value)</code></li>
</ul>
<h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><ul>
<li>步骤<ol>
<li>获取输出流</li>
<li>使用输出流将数据输出到客户端浏览器</li>
</ol>
</li>
<li>特点<ul>
<li>response获取的流不用关，tomcat会帮我们关</li>
<li>getWriter()和getOutputStream()不能同时用</li>
</ul>
</li>
<li><code>ServletOutputStream getOutputStream()</code></li>
<li><code>PrintWriter getWriter()</code></li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li>完成重定向需要<ol>
<li><code>response.setStatus(302)</code><ul>
<li>告诉客户端需要重定向</li>
</ul>
</li>
<li><code>response.setHeander(&quot;location&quot;, String path)</code><ul>
<li>告诉客户端重定向的地址</li>
</ul>
</li>
</ol>
</li>
<li><strong>简化</strong><ul>
<li><code>response.sendRedirect(String path)</code></li>
</ul>
</li>
</ul>
<h3 id="响应乱码问题"><a href="#响应乱码问题" class="headerlink" title="响应乱码问题"></a>响应乱码问题</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ol>
<li>响应流不是我们自己创建的，而是由tomcat获取的，默认编码是<code>iso-8859-1</code></li>
<li>浏览器解码的码表不确定，可能与响应数据码表不一致</li>
</ol>
<ul>
<li>所以要解决乱码<ol>
<li>设置响应数据的码表</li>
<li>使浏览器的码表与响应数据的码表一致</li>
</ol>
</li>
</ul>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li><code>response.setChracterEncoding(&quot;utf-8&quot;)</code><ul>
<li>设置响应数据编码方式</li>
</ul>
</li>
<li><code>response.setheader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;)</code><ul>
<li>设置响应数据类型及浏览器解码方式</li>
</ul>
</li>
<li><strong>简化</strong><ul>
<li><code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code><ul>
<li>封装了上边两个方法.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="转发-amp-重定向"><a href="#转发-amp-重定向" class="headerlink" title="转发 &amp; 重定向"></a>转发 &amp; 重定向</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="转发-1"><a href="#转发-1" class="headerlink" title="转发"></a>转发</h3><ol>
<li>一次请求</li>
<li>浏览器地址栏不变</li>
<li>转发只能访问当前服务器下的资源</li>
</ol>
<h3 id="重定向-1"><a href="#重定向-1" class="headerlink" title="重定向"></a>重定向</h3><ol>
<li>二次请求</li>
<li>浏览器地址栏改变</li>
<li>重定向可以访问其它站点(服务器)下的资源</li>
</ol>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h3 id="转发-2"><a href="#转发-2" class="headerlink" title="转发"></a>转发</h3><ul>
<li><code>request.getRequestDispatcher(String path).forward(req,res)</code><ul>
<li><code>path</code><ul>
<li>是在服务器内部进行的，是给服务器使用的，路径不需要写<code>虚拟目录名</code><ul>
<li>可以理解为<code>/</code>就代表<code>http://localhost:8080/虚拟目录名</code></li>
</ul>
</li>
<li>若地址前不写<code>/</code>,代表相对路径，相对当前文件路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="重定向-2"><a href="#重定向-2" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li><code>response.sendRedirect(String path)</code><ul>
<li>path<ul>
<li>是在客户端浏览器执行的，是给客户端使用的，需要加`虚拟目录名<ul>
<li>可以理解为”/“<code>代表的是</code><a href="http://localhost:8080/`" target="_blank" rel="noopener">http://localhost:8080/`</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>重定向或者转发后，后边的代码还会执行，但通常不会写</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-JSP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-JSP/" itemprop="url">
                  xd-JSP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:38:44" itemprop="dateCreated datePublished" datetime="2018-12-11T00:38:44+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:38:49" itemprop="dateModified" datetime="2019-03-08T14:38:49+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>Java Server Pages</code></li>
<li>JSP本质上就是Servlet<ul>
<li>jsp翻译的<code>.java</code>文件间接继承了<code>HttpServlet</code></li>
</ul>
</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="jsp执行过程"><a href="#jsp执行过程" class="headerlink" title="jsp执行过程"></a>jsp执行过程</h2><ul>
<li>第一次访问会把<code>.jsp</code>先翻译成<code>.java</code>文件</li>
<li>把<code>.java</code>编译成<code>.class</code>文件</li>
<li>执行<code>.class</code>文件</li>
<li>以后访问直接执行.class文件</li>
<li>如果.jsp发生变化,则视为第一次访问，循环…。</li>
</ul>
<h2 id="jsp的html排版标签是如何展示的"><a href="#jsp的html排版标签是如何展示的" class="headerlink" title="jsp的html排版标签是如何展示的"></a>jsp的html排版标签是如何展示的</h2><ul>
<li>在service方法中调用<code>out.write(标签)</code>写出。</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li><p><code>test.jsp</code>生成的<code>.java</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.jasper.runtime.HttpJspBase;</span><br><span class="line">public final class test_jsp extends HttpJspBase &#123;</span><br><span class="line">	public void _jspService(req,res)&#123;&#125;</span><br><span class="line">	public void _jspInit() &#123;&#125;</span><br><span class="line">	public void _jspDestroy() &#123;&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HttpJspBase</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class HttpJspBase extends HttpServlet &#123;</span><br><span class="line">	public void _jspInit()&#123;&#125;</span><br><span class="line">	public void init(ServletConfig config)&#123;</span><br><span class="line">		_jspInit();</span><br><span class="line">	&#125;</span><br><span class="line">	public abstract void _jspService(req,res);</span><br><span class="line">	public void service(req,res)&#123;</span><br><span class="line">		_jspService(req,res);</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>jsp翻译成的<code>.java</code>文件，继承了<code>HttpJspBase</code>，而<code>HttpJspBase</code>继承了<code>HttpServlet</code>，所以说jsp就是一个Servlet。</li>
<li>可以看到方法调用，最终还是servlet的那几个方法。</li>
</ul>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li>静态内容 如:html标签和文本。</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><code>&lt;!-- --&gt;</code><ul>
<li>不能注释脚本</li>
</ul>
</li>
<li><code>&lt;%-- --%&gt;</code><ul>
<li>可以注释脚本</li>
<li>不会被写出到最终的页面中，安全省流量。</li>
</ul>
</li>
</ul>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h3><ul>
<li><code>&lt;% java代码 %&gt;</code><ul>
<li>最终在翻译成的<code>.java</code>文件的<code>service()</code>中</li>
</ul>
</li>
</ul>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ul>
<li><code>&lt;%= %&gt;</code><ul>
<li><code>out.write()</code></li>
<li>最终在翻译成的<code>.java</code>文件的<code>service()</code>中</li>
</ul>
</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li><code>&lt;%! %&gt;</code><ul>
<li>声明成员变量，静态块…</li>
<li>最终在翻译成的<code>.java</code>文件的成员位置。</li>
</ul>
</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul>
<li>jsp指令不直接产生任何可见输出，而只告诉jsp引擎如何处理jsp页面中的内容。</li>
</ul>
<h3 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h3><ul>
<li><code>&lt;%@指令名 属性1=&quot;值&quot; 属性2=&quot;值&quot;... %&gt;</code><ul>
<li>页面中可出现多次</li>
</ul>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h4><ul>
<li>用于定义jsp页面的各种属性</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><code>import</code><ul>
<li>用于导包</li>
<li>jsp默认自动导入的包<ul>
<li><code>import java.lang.*;</code></li>
<li><code>import javax.servlet.*;</code></li>
<li><code>import javax.servlet.http.*;</code></li>
<li><code>import javax.servlet.jsp.*</code></li>
</ul>
</li>
</ul>
</li>
<li><code>language</code><ul>
<li><code>java</code>： 默认</li>
</ul>
</li>
<li><strong><code>pageEncoding</code></strong><ul>
<li>告诉服务器用什么编码把<code>.jsp</code>翻译成<code>.java</code>文件</li>
</ul>
</li>
<li><code>session</code><ul>
<li><code>true</code>： 默认</li>
<li><code>false</code></li>
</ul>
</li>
<li><code>buffer</code><ul>
<li>输出数据的缓存大小(out的缓冲区)</li>
<li>值<ul>
<li><code>8kb</code> ：默认</li>
<li><code>none</code></li>
<li><code>自定义size kb</code></li>
</ul>
</li>
</ul>
</li>
<li><code>errorPage</code><ul>
<li>如果页面中有错误，则跳转到指定的资源</li>
<li><code>errorPage=&quot;/xx.jsp&quot;</code></li>
</ul>
</li>
<li><code>isErrorPage</code><ul>
<li>是否创建throwable内置对象</li>
<li>是否是错误页面</li>
<li>值<ul>
<li><code>true</code></li>
<li><code>false</code>： 默认</li>
</ul>
</li>
</ul>
</li>
<li><code>contentType</code><ul>
<li>等价于<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code></li>
<li>告诉浏览器用什么格式和编码解析</li>
<li>如果不赋值，默认使用<code>pageEncoding</code>的编码</li>
</ul>
</li>
<li><code>isELIgnored</code><ul>
<li>是否忽略EL表达式</li>
<li>值<ul>
<li><code>true</code></li>
<li><code>false</code>： 默认</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="taglib指令"><a href="#taglib指令" class="headerlink" title="taglib指令"></a>taglib指令</h4><ul>
<li><code>&lt;%@ taglib uri=&quot;&quot; prefix=&quot;&quot; %&gt;</code><ul>
<li>在JSP页面中导入标签库。</li>
</ul>
</li>
</ul>
<h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h4><ul>
<li><code>&lt;%@ include file=&quot;&quot; %&gt;</code><ul>
<li><strong>静态包含</strong></li>
<li>先合并成一个文件，再翻译。所以静态包含，被包含的文件可以不写重复的标签</li>
</ul>
</li>
</ul>
<h2 id="jsp编码问题"><a href="#jsp编码问题" class="headerlink" title="jsp编码问题"></a>jsp编码问题</h2><h3 id="jsp编解码过程"><a href="#jsp编解码过程" class="headerlink" title="jsp编解码过程"></a>jsp编解码过程</h3><ol>
<li><code>.jsp</code>的存储编码<ul>
<li>即文件本身的存储编码</li>
<li>我的ide通常用utf-8，所以<code>.jsp</code>也是用utf-8存的</li>
<li>注意用什么存的，<code>pageEncoding</code>就要写什么,不然翻译就会乱码</li>
</ul>
</li>
<li><code>.jsp</code>→<code>.java</code><ul>
<li>使用<code>pageEncoding</code>指定的码表翻译</li>
</ul>
</li>
<li><code>.java</code>→<code>.class</code><ul>
<li>jvm使用utf-8编译，不可修改</li>
</ul>
</li>
<li>用户浏览器解析<ul>
<li>使用的是<code>contentType</code>指定的编码</li>
</ul>
</li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>想要不乱码，保证以下三码一致即可。<ol>
<li><code>.jsp</code>的存储编码</li>
<li><code>pageEncoding</code>的编码</li>
<li><code>contentType</code>的编码</li>
</ol>
</li>
<li>而由于<code>contentType</code>如果不赋值，默认会使用<code>pageEncoding</code>的编码。所以，保证<code>.jsp</code>的存储编码和<code>pageEncoding</code>的编码一致即可。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>设置jsp的<code>pageEncoding</code>的编码为<code>.jsp</code>的文件存储编码即可</li>
</ul>
<h3 id="jsp中的html乱码"><a href="#jsp中的html乱码" class="headerlink" title="jsp中的html乱码"></a>jsp中的html乱码</h3><ul>
<li>因为html本身也有编码格式，而jsp中包含有html的内容</li>
<li>如果html的内容乱码设置好content中的charset即可<ul>
<li><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h2><h3 id="lt-jsp-include-gt"><a href="#lt-jsp-include-gt" class="headerlink" title="&lt;jsp:include&gt;"></a><code>&lt;jsp:include&gt;</code></h3><ul>
<li><code>&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;</code><ul>
<li><strong>动态包含</strong></li>
<li>不会合并文件，当代码执行到include时，才包含另一个文件的内容</li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-forward-gt"><a href="#lt-jsp-forward-gt" class="headerlink" title="&lt;jsp:forward&gt;"></a><code>&lt;jsp:forward&gt;</code></h3><ul>
<li><code>&lt;jsp:forward page=&quot;path&quot;/&gt;</code><ul>
<li>转发</li>
<li>相当于<code>req.getRequestDispatcher(path).forward(req,res);</code></li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-param-gt"><a href="#lt-jsp-param-gt" class="headerlink" title="&lt;jsp:param&gt;"></a><code>&lt;jsp:param&gt;</code></h3><ul>
<li><code>&lt;jsp:param name=&quot;&quot; value=&quot;&quot; /&gt;</code><ul>
<li>请求参数</li>
<li>相当于<code>url?name=value</code></li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-useBean-gt"><a href="#lt-jsp-useBean-gt" class="headerlink" title="&lt;jsp:useBean&gt;"></a><code>&lt;jsp:useBean&gt;</code></h3><ul>
<li><code>&lt;jsp:useBean id=&quot;p&quot; class=&quot;cn.an.Person&quot;/&gt;</code><ul>
<li>创建对象</li>
<li>相当于<code>cn.an.Person p=new Person();</code></li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-setProperty-gt"><a href="#lt-jsp-setProperty-gt" class="headerlink" title="&lt;jsp:setProperty&gt;"></a><code>&lt;jsp:setProperty&gt;</code></h3><ul>
<li><code>&lt;jsp:setProperty property=&quot;age&quot; name=&quot;p&quot; value=&quot;8&quot;/&gt;</code><ul>
<li>为对象属性赋值</li>
<li>相当于<code>p.setAge(8);</code></li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-getProperty-gt"><a href="#lt-jsp-getProperty-gt" class="headerlink" title="&lt;jsp:getProperty&gt;"></a><code>&lt;jsp:getProperty&gt;</code></h3><ul>
<li><code>&lt;jsp:getProperty property=&quot;age&quot; name=&quot;p&quot;/&gt;</code><ul>
<li>获取对象属性值</li>
<li>相当于<code>p.getAge();</code></li>
</ul>
</li>
</ul>
<h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><ul>
<li>在<code>&lt;%= %&gt;</code>和<code>&lt;% %&gt;</code>中可以直接使用的对象。即<code>service()</code>中的对象</li>
</ul>
<table>
<thead>
<tr>
<th>对象名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td><code>javax.servlet.http.HttpServletRequest</code></td>
<td>request域</td>
</tr>
<tr>
<td>response</td>
<td><code>javax.servlet.http.HttpServletResponse</code></td>
<td>response域</td>
</tr>
<tr>
<td>session</td>
<td><code>javax.servlet.http.HttpSession</code></td>
<td>session域 page指令的session属性开关</td>
</tr>
<tr>
<td>application</td>
<td><code>javax.servlet.ServletContext</code></td>
<td>application域</td>
</tr>
<tr>
<td>pageContext</td>
<td><code>javax.servlet.jsp.PageContext</code></td>
<td>pageContext域</td>
</tr>
<tr>
<td>exception</td>
<td><code>java.lang.Throwable</code></td>
<td>page指令的isErrorPage属性开关</td>
</tr>
<tr>
<td>page</td>
<td><code>java.lang.Object</code></td>
<td>当前servlet实例 this</td>
</tr>
<tr>
<td>config</td>
<td><code>javax.servlet.ServletConfig</code></td>
<td></td>
</tr>
<tr>
<td>out</td>
<td><code>javax.servlet.jsp.JspWriter</code></td>
<td>字符输出流，相当于 printWriter对象</td>
</tr>
</tbody>
</table>
<h2 id="out"><a href="#out" class="headerlink" title="out"></a>out</h2><ul>
<li><code>out.write()</code>和<code>response.getWriter().write()</code><ul>
<li>区别<ul>
<li>最后响应时，tomcat总会先从response中获取数据，然后才会从out中获取数据。</li>
<li>所以无论何时，总是response先输出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h2><ul>
<li>可以获取其它八个内置对象<ul>
<li>自定义标签时为了获取九个内置对象不需要全部传入,传入pageContext即可</li>
</ul>
</li>
<li>是域对象<ul>
<li><code>void setAttribute(String name,Object value)</code></li>
<li><code>Object getAttribute(String name)</code></li>
<li><code>void removeAttribute(String name)</code></li>
</ul>
</li>
<li>可以操作其它域对象<ul>
<li><code>void setAttribute(String name,Object value,int Scope)</code></li>
<li><code>Object getAttribute(String name,int Scope)</code></li>
<li><code>void removeAttribute(String name,int Scope)</code><ul>
<li>Scope<ul>
<li><code>PageContext.PAGE_SCOP</code>E </li>
<li><code>PageContext.REQUEST_SCOPE</code></li>
<li><code>PageContext.SESSION_SCOPE</code></li>
<li><code>PageContext.APPLICATION_SCOPE</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Object findAttribute()</code><ul>
<li>自动从四个域对象找,找到就返回</li>
<li>顺序page-request-session-application</li>
</ul>
</li>
<li>提供了简易方法<ul>
<li><code>forward()</code></li>
<li><code>include()</code></li>
</ul>
</li>
</ul>
<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li><code>expression language</code></li>
<li>简化jsp中的java代码(主要是获取数据方面的简化)</li>
<li>不是开发语言是jsp中获取数据的一种规范<ul>
<li>只能用在jsp，html无法解析</li>
</ul>
</li>
</ul>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><ul>
<li><code>${表达式}</code></li>
</ul>
<h2 id="忽略EL表达式"><a href="#忽略EL表达式" class="headerlink" title="忽略EL表达式"></a>忽略EL表达式</h2><ol>
<li>设置jsp的page指令的<code>isElIgnored</code>为true，则当前jsp都不能使用EL表达式</li>
<li><code>\${表达式}</code><ul>
<li>忽略当前这个EL表达式</li>
</ul>
</li>
</ol>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>算术运算符<ul>
<li><code>+ - * /(div) %(mod)</code></li>
<li><code>3 / 4</code>也可以表示为<code>3 div 4</code></li>
</ul>
</li>
<li>比较运算符<ul>
<li><code>&gt; &lt; &gt;= &lt;= == !=</code></li>
</ul>
</li>
<li>逻辑运算符<ul>
<li><code>&amp;&amp;(and) ||(or) !(not)</code></li>
</ul>
</li>
<li>空运算符<ul>
<li><code>empty</code><ul>
<li>用于判断字符串，集合，数组对象是否为null或者长度是否为0</li>
<li>true<ul>
<li>空字符串<ul>
<li><code>String s=null</code></li>
<li><code>String s=&quot;&quot;</code></li>
</ul>
</li>
<li>没有元素的集合(即使集合对象本身不为null)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>三元运算<ul>
<li><code>${empty key?&quot;为空&quot;:&quot;不为空&quot;}</code></li>
<li><code>${key==1?&quot;男&quot;:&quot;女&quot;}</code></li>
</ul>
</li>
</ul>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>EL表达式只能从域中获取数据</li>
<li>EL获取的值若为null会显示为<code>&quot;&quot;</code></li>
</ul>
<h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><ol>
<li><code>${键名}</code><ul>
<li>相当于<code>pageContext.findAttribute()</code></li>
<li>依次从四个域中查找数据找到就返回，如果多个域存的key相同，则后边的无法取到。<ul>
<li><code>${pageScope.key}</code></li>
<li><code>${requestScope.key}</code></li>
<li><code>${sessionScope.key}</code></li>
<li><code>${applicationScope.key}</code></li>
</ul>
</li>
</ul>
</li>
<li><code>${域名.键名}</code><ul>
<li>从指定域中获取指定key的值</li>
</ul>
</li>
<li><code>${域名.键名.属性名}</code><ul>
<li>域中存的是对象</li>
<li>通过对象属性导航图获取属性值(本质调用对象get方法)</li>
</ul>
</li>
<li><code>${域名.键名[索引]}</code><ul>
<li>List集合</li>
</ul>
</li>
<li><code>${域名.键名.key}</code> 或 <code>${域名.键名[&quot;key&quot;]}</code><ul>
<li>Map集合</li>
</ul>
</li>
</ol>
<h2 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h2><table>
<thead>
<tr>
<th>隐式对象名</th>
<th>类型</th>
<th>对应jsp内置对象名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pageContext</td>
<td><code>javax.servlet.jsp.PageContex</code></td>
<td>pageContext</td>
<td>二者一样</td>
</tr>
<tr>
<td>pageScope</td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td>pageContext域</td>
</tr>
<tr>
<td>requestScope</td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td>request域</td>
</tr>
<tr>
<td>sessionScope</td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td>session域</td>
</tr>
<tr>
<td>applicationScope</td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td>application域</td>
</tr>
<tr>
<td>param</td>
<td><code>java.util.Map&lt;String,String&gt;</code></td>
<td>无</td>
<td>一个请求参数</td>
</tr>
<tr>
<td>paramValues</td>
<td><code>java.util.Map&lt;String,String[]&gt;</code></td>
<td>无</td>
<td>重名请求参数</td>
</tr>
<tr>
<td>header</td>
<td><code>java.util.Map&lt;String,String&gt;</code></td>
<td>无</td>
<td>一个请求消息头</td>
</tr>
<tr>
<td>headerValues</td>
<td><code>java.util.Map&lt;String,String[]&gt;</code></td>
<td>无</td>
<td>重名请求消息头</td>
</tr>
<tr>
<td>initParam</td>
<td><code>java.util.Map&lt;String,String&gt;</code></td>
<td>无</td>
<td>web.xml中全局参数</td>
</tr>
<tr>
<td>cookie</td>
<td><code>java.util.Map&lt;String,Cookie&gt;</code></td>
<td>无</td>
<td>key:cookie对象的name值</td>
</tr>
</tbody>
</table>
<h3 id="pageContext-1"><a href="#pageContext-1" class="headerlink" title="pageContext"></a>pageContext</h3><ul>
<li>跟jsp内置一样，可以获取jsp其它内置对象</li>
<li><code>${pageContext.request.contextpath}</code><ul>
<li>相当于pageContext.getRequest().getContextPah();<ul>
<li>但注意这句不能执行</li>
<li>因为pageContext.getRequest()得到的是ServletRequest而不是HttpServletRequest所以需要强转</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul>
<li><code>JavaServerPages Standard Tag Library</code></li>
<li>JSP标准标签库<ul>
<li>包含五个库<ul>
<li><strong>Core</strong> 前缀c</li>
<li>I18N 前缀fmt</li>
<li>SQL 前缀sql</li>
<li>XML 前缀x</li>
<li>Functions 前缀fn</li>
</ul>
</li>
</ul>
</li>
<li>简化java代码(主要是逻辑处理方面,判断循环..)</li>
<li>因为jstl存取都是在域对象中，所以jstl中不管是取值还是赋值都要用el<ul>
<li>因为jstl不会解析表达式，只能靠el去解析</li>
</ul>
</li>
</ul>
<h2 id="引入jstl"><a href="#引入jstl" class="headerlink" title="引入jstl"></a>引入jstl</h2><ul>
<li><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;自定义&quot; %&gt;</code></li>
</ul>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="通用标签"><a href="#通用标签" class="headerlink" title="通用标签"></a>通用标签</h3><ul>
<li>都可以指定scope</li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h4><ul>
<li><code>&lt;c:set var=&quot;num&quot; value=&quot;10&quot; scope=&quot;session&quot; /&gt;</code><ul>
<li>声明变量并赋值（放在了域中）</li>
<li>存数据到域中相当于<code>setAttribute()</code></li>
</ul>
</li>
</ul>
<h4 id="out-1"><a href="#out-1" class="headerlink" title="out"></a><code>out</code></h4><ul>
<li><code>&lt;c:out value=&quot;${num}&quot; scope=&quot;session&quot;/&gt;</code><ul>
<li>输出的value要写EL表达式(从域中取数据相当于<code>getAttribute()</code>)</li>
<li>可以直接用El表达式代替out标签</li>
</ul>
</li>
</ul>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a><code>remove</code></h4><ul>
<li>`&lt;c:remove var=”num” scope=”session”/&gt;<ul>
<li>从域中删除相当于<code>removeAttribute()</code></li>
</ul>
</li>
</ul>
<h3 id="条件标签"><a href="#条件标签" class="headerlink" title="条件标签"></a>条件标签</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h4><ul>
<li><code>&lt;c:if test=&quot;&quot;&gt;&lt;/c:if&gt;</code><ul>
<li>test通常会使用el表达式</li>
</ul>
</li>
</ul>
<h4 id="choose"><a href="#choose" class="headerlink" title="choose"></a><code>choose</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">	&lt;c:when test=&quot;&quot;&gt;1&lt;/c:when&gt;</span><br><span class="line">	&lt;c:when test=&quot;&quot;&gt;2&lt;/c:when&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;c:otherwise&gt;0&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<h3 id="迭代标签"><a href="#迭代标签" class="headerlink" title="迭代标签"></a>迭代标签</h3><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><code>forEach</code></h4><ul>
<li><code>&lt;c:forEach var=&quot;&quot; begin=&quot;&quot; end=&quot;&quot; step=&quot;&quot; varStatus=&quot;&quot;&gt;&lt;/c:forEach&gt;</code><ul>
<li>普通循环</li>
</ul>
</li>
<li><code>&lt;c:forEach items=&quot;&quot; var=&quot;&quot; varStatus=&quot;&quot;&gt;&lt;/c:forEach&gt;</code><ul>
<li>增强循环</li>
</ul>
</li>
</ul>
<h5 id="varStatus"><a href="#varStatus" class="headerlink" title="varStatus"></a>varStatus</h5><ul>
<li>底层：指向一个字符串，该字符串引用一个对象。这个对象记录着当前遍历的元素的一些信息：<ul>
<li>map.put(“vs”,对象)</li>
</ul>
</li>
<li>所以varStatus可以取到当前遍历元素的信息。<ul>
<li><code>${vs.index}</code><ul>
<li>返回索引 从0开始</li>
</ul>
</li>
<li><code>${vs.count}</code><ul>
<li>返回计数 从1开始</li>
</ul>
</li>
<li><code>${vs.current}</code><ul>
<li>返回当前元素</li>
</ul>
</li>
<li><code>${vs.first}</code><ul>
<li>是否第一个</li>
</ul>
</li>
<li><code>${vs.last}</code><ul>
<li>是否最后一个`</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="域对象"><a href="#域对象" class="headerlink" title="域对象"></a>域对象</h1><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><ul>
<li>创建<ul>
<li>服务器启动</li>
</ul>
</li>
<li>销毁<ul>
<li>服务器关闭</li>
</ul>
</li>
<li>作用域<ul>
<li>整个web应用</li>
</ul>
</li>
</ul>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><ul>
<li>创建<ul>
<li>第一次<code>request.getSession()</code></li>
</ul>
</li>
<li>销毁<ul>
<li>服务器关闭(非正常)</li>
<li>失效/过期 </li>
<li>手动<code>session.invalidate()</code></li>
</ul>
</li>
<li>作用域<ul>
<li>一次会话中</li>
</ul>
</li>
</ul>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><ul>
<li>创建<ul>
<li>客户端发送请求</li>
</ul>
</li>
<li>销毁<ul>
<li>响应结束</li>
</ul>
</li>
<li>作用域<ul>
<li>一次请求</li>
</ul>
</li>
</ul>
<h3 id="pageContext-2"><a href="#pageContext-2" class="headerlink" title="pageContext"></a>pageContext</h3><ul>
<li>作用域<ul>
<li>当前页面</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/xd-Filter和Listener/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/xd-Filter和Listener/" itemprop="url">
                  xd-Filter和Listener
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-03 14:53:38" itemprop="dateCreated datePublished" datetime="2019-01-03T14:53:38+08:00">2019-01-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:39:03" itemprop="dateModified" datetime="2019-03-08T14:39:03+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="监听器-Listener"><a href="#监听器-Listener" class="headerlink" title="监听器(Listener)"></a>监听器(Listener)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>web的三大组件之一。</li>
<li>用于监听web常见对象的创建销毁,属性变化</li>
<li>监听域对象HttpRequest HttpSession ServletContext</li>
</ul>
<h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><ul>
<li>事件    ：一件事情</li>
<li>事件源 ：事件发生的地方</li>
<li>监听器 ：用于监听指定的事件的对象</li>
<li>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</li>
</ul>
<h2 id="常见监听器"><a href="#常见监听器" class="headerlink" title="常见监听器"></a>常见监听器</h2><h3 id="监听域对象的创建与销毁"><a href="#监听域对象的创建与销毁" class="headerlink" title="监听域对象的创建与销毁"></a>监听域对象的创建与销毁</h3><ul>
<li><code>HttpSessionListener</code><ul>
<li>监听HttpSession创建与销毁</li>
</ul>
</li>
<li><code>ServletRequestListener</code><ul>
<li>监听HttpServletRequest创建与销毁</li>
</ul>
</li>
<li><code>ServletContextListener</code><ul>
<li>监听ServletContext创建与销毁</li>
</ul>
</li>
</ul>
<h3 id="监听域对象的属性变化"><a href="#监听域对象的属性变化" class="headerlink" title="监听域对象的属性变化"></a>监听域对象的属性变化</h3><ul>
<li><code>HttpSessionAttributeListener</code><ul>
<li>监听HttpSession属性变化</li>
</ul>
</li>
<li><code>ServletRequestAttributeListener</code><ul>
<li>监听HttpServletRequest属性变化</li>
</ul>
</li>
<li><code>ServletContextAttributeListener</code><ul>
<li>监听ServletContext属性变化</li>
</ul>
</li>
</ul>
<h3 id="监听session绑定javaBean"><a href="#监听session绑定javaBean" class="headerlink" title="监听session绑定javaBean"></a>监听session绑定javaBean</h3><ul>
<li>此种监听器不用配置注册</li>
<li>要用对象实现此种监听器</li>
<li><code>HttpSessionBindingListener</code><ul>
<li>监听javaBean对象是否绑定到了session域</li>
<li>绑定<ul>
<li>一个对象放到session域中</li>
</ul>
</li>
<li>解绑<ul>
<li>对象从session域中移除</li>
</ul>
</li>
</ul>
</li>
<li><code>HttpSessionActivationListener</code><ul>
<li>监听javaBean对象的活化与钝化</li>
<li>钝化<ul>
<li>session内存中的对象持久化（序列化）到磁盘</li>
<li>服务器关闭了，session中的数据序列化一个文件。(安)</li>
</ul>
</li>
<li>活化<ul>
<li>将磁盘的对象再次恢复到session内存中</li>
<li>服务器开启，通过文件恢复session数据。(安)</li>
<li>注意钝化活化的对象要实现serializable接口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>void contextDestroyed(ServletContextEvent sce)</code> <ul>
<li>ServletContext对象被销毁之前会调用该方法</li>
</ul>
</li>
<li><code>void contextInitialized(ServletContextEvent sce)</code> <ul>
<li>ServletContext对象创建后会调用该方法</li>
</ul>
</li>
</ul>
<h4 id="获取被监听的对象"><a href="#获取被监听的对象" class="headerlink" title="获取被监听的对象"></a>获取被监听的对象</h4><ul>
<li>方法中的参数(ServletContextEvent sce)可以获取被监听的对象</li>
</ul>
<ol>
<li><code>ServletContext sc = sce.getServletContext()</code></li>
<li><code>Object obj = sce.getSource();</code><ul>
<li>这个是通用的获取被监听的对象的方法，可以强转</li>
<li><code>ServletContext sc = (ServletContext)sce.getSource();</code></li>
</ul>
</li>
</ol>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>初始化工作<ul>
<li>初始化对象，数据，加载数据库驱动，连接池的初始化</li>
</ul>
</li>
<li>加载初始化配置文件<ul>
<li>如spring的配置文件</li>
<li>spring的核心监听器就是实现了ServletContextListener</li>
</ul>
</li>
<li>任务调度<ul>
<li>定时器 Timer/TimerTask</li>
</ul>
</li>
</ul>
<h2 id="创建监听器"><a href="#创建监听器" class="headerlink" title="创建监听器"></a>创建监听器</h2><ul>
<li>创建类实现指定监听器接口</li>
<li>实现接口方法</li>
<li>配置<ol>
<li>在web.xml中对监听器进行注册<code>&lt;listener&gt;</code></li>
<li>注解<code>@WebListener</code></li>
</ol>
</li>
</ul>
<h1 id="过滤器-Filter"><a href="#过滤器-Filter" class="headerlink" title="过滤器(Filter)"></a>过滤器(Filter)</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>可以过滤所有访问web资源的请求或响应操作</li>
<li>作用<ul>
<li>一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…</li>
</ul>
</li>
</ul>
<h2 id="创建过滤器"><a href="#创建过滤器" class="headerlink" title="创建过滤器"></a>创建过滤器</h2><ul>
<li>创建类实现Filter接口</li>
<li>实现接口方法</li>
<li>配置<ol>
<li>在web.xml中配置<code>&lt;filter&gt;</code> <code>&lt;filter-mapping&gt;</code></li>
<li>注解<code>@WebFilter</code></li>
</ol>
</li>
</ul>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li><code>init(FilterConfig config)</code><ul>
<li>服务器启动，创建Filter对象，只调用一次</li>
</ul>
</li>
<li><code>doFilter(req,res,chain)</code><ul>
<li>每次访问调用2次</li>
<li>每次访问前后都会调用一次。</li>
</ul>
</li>
<li><code>destroy()</code><ul>
<li>服务器正常关闭，Filter对象被销毁，调用一次</li>
</ul>
</li>
</ul>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol>
<li>过滤器链正序执行，放行前的代码</li>
<li>放行<ul>
<li><code>chain.doFilter(req,res);</code></li>
</ul>
</li>
<li>过滤器链倒叙执行放行后的代码</li>
</ol>
<h3 id="过滤器链执行顺序"><a href="#过滤器链执行顺序" class="headerlink" title="过滤器链执行顺序"></a>过滤器链执行顺序</h3><ol>
<li><code>web.xml</code><ul>
<li>由<code>&lt;filter-mapping&gt;</code>顺序确定</li>
</ul>
</li>
<li>注解<ul>
<li>按照类名的字符串比较规则比较，值小的先执行</li>
</ul>
</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><code>web.xml</code></h4><h5 id="lt-url-pattern-gt"><a href="#lt-url-pattern-gt" class="headerlink" title="&lt;url-pattern&gt;"></a><code>&lt;url-pattern&gt;</code></h5><ul>
<li><code>/xxx</code></li>
<li><code>/xxx/*</code></li>
<li><code>/*</code></li>
<li><code>*.do</code></li>
</ul>
<h5 id="lt-dispatcher-gt"><a href="#lt-dispatcher-gt" class="headerlink" title="&lt;dispatcher&gt;"></a><code>&lt;dispatcher&gt;</code></h5><ul>
<li>拦截指定跳转方式</li>
<li>当以什么方式去访问web资源时，进行拦截操作.</li>
<li><code>REQUEST</code>  <ul>
<li>当是从浏览器直接访问资源，或是重定向到某个资源时进行拦截方式配置的 默认值</li>
</ul>
</li>
<li><code>FORWARD</code><ul>
<li>请求转发的拦截方式配置</li>
</ul>
</li>
<li><code>ERROR</code><ul>
<li>如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用</li>
</ul>
</li>
<li><code>INCLUDE</code><ul>
<li>如果目标资源是通过<code>RequestDispatcher的include()</code>方法访问时，那么该过滤器将被调用</li>
</ul>
</li>
<li><code>ASYNC</code><ul>
<li>异步访问资源</li>
</ul>
</li>
</ul>
<h3 id="FilterConfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h3><ul>
<li><code>String getFilterName()</code></li>
<li><code>String getInitParameter(String name)</code></li>
<li><code>Enumeration getInitParameterNames()</code>    </li>
<li><code>ServletContext getServletContext()</code><ul>
<li>获取ServletContext</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/xd-会话/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/xd-会话/" itemprop="url">
                  xd-会话
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-28 01:30:11" itemprop="dateCreated datePublished" datetime="2018-12-28T01:30:11+08:00">2018-12-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:39:20" itemprop="dateModified" datetime="2019-03-08T14:39:20+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><h2 id="一次会话"><a href="#一次会话" class="headerlink" title="一次会话"></a>一次会话</h2><ul>
<li>浏览器第一次给服务器发送请求，会话建立，直到有一方断开为止。</li>
<li>包含多次请求和响应</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>在一次会话范围共享数据</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><code>Cookie</code></li>
<li><code>Session</code> </li>
</ul>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>客户端技术<ul>
<li>Cookie是由客户端保存和携带的。</li>
<li>只能存储字符串</li>
</ul>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>基于响应头<code>set-cookie</code>和请求头<code>cookie</code>实现</li>
<li>程序把每个用户的数据以cookie形式响应给用户各自的浏览器，存在本地。当用户再次请求访问服务器的web资源时，就会带着各自的(cookie)去。如此，web资源处理的就是用户各自的数据。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>创建Cookie(在服务端)<ul>
<li><code>Cookie cookie=new Cookie(String name,String value,[String path])</code><ul>
<li><code>path</code><ul>
<li>默认是创建cookie的应用的虚拟目录。</li>
<li>可以指定<ol>
<li>构造时指定path</li>
<li><code>cookie.setPath()</code></li>
</ol>
</li>
<li>只有以cookie的path开头的访问路径才会携带cookie。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>响应Cookie到客户端<ul>
<li><code>response.addCookie(Cookie c)</code><ul>
<li>响应头<code>set-Cookie</code></li>
</ul>
</li>
</ul>
</li>
<li>再次请求时获取Cookie<ul>
<li><code>Cookie[] cs=request.getCookies()</code><ul>
<li>获取cookie列表。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="一次可不可以发送多个Cookie"><a href="#一次可不可以发送多个Cookie" class="headerlink" title="一次可不可以发送多个Cookie"></a>一次可不可以发送多个Cookie</h3><ul>
<li>可以</li>
<li>创建多个Cookie对象，使用response调用多次<code>addCookie()</code>即可</li>
</ul>
<h3 id="Cookie的存活时间"><a href="#Cookie的存活时间" class="headerlink" title="Cookie的存活时间"></a>Cookie的存活时间</h3><ul>
<li><code>void setMaxAge(int time)</code><ul>
<li><code>time</code><ul>
<li>负数<ul>
<li>默认</li>
<li>默认cookie是会话级别的，即浏览器一关闭就会消失</li>
</ul>
</li>
<li>正数<ul>
<li>持久化存储，存活时间</li>
</ul>
</li>
<li>0<ul>
<li>删除Cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Cookie能否存中文"><a href="#Cookie能否存中文" class="headerlink" title="Cookie能否存中文"></a>Cookie能否存中文</h3><ul>
<li>tomcat8之前<ul>
<li>不可以</li>
<li>需要将中文转码，一般采用URL编码(%16进制)</li>
</ul>
</li>
<li>tomcat8之后，Cookie支持中文<ul>
<li>但是不支持特殊字符，建议使用URL编解码<ul>
<li>URL编码后会变成<code>%E7</code>这种形式的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h4><ul>
<li><code>URLEncoder</code><ul>
<li><code>encode(String s, String character)</code><ul>
<li>编码</li>
</ul>
</li>
<li><code>decode(String s, String character)</code><ul>
<li>解码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Cookie共享问题"><a href="#Cookie共享问题" class="headerlink" title="Cookie共享问题"></a>Cookie共享问题</h3><ol>
<li>同一个服务器下的多个we项目<ul>
<li>因为默认path是创建cookie的项目的虚拟目录，其它web项目是访问不到的。</li>
<li>即默认不能共享</li>
<li>共享<ul>
<li><code>setPath(&quot;/&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li>不同服务器间的共享<ul>
<li><code>setDomain(String path)</code><ul>
<li>如果设置一级域名相同，那么多个服务区间的Cookie可以共享</li>
<li><code>setDomain(&quot;.baidu.com&quot;)</code><ul>
<li>则<code>tieba.baidu.com</code>和<code>news.baidu.com</code>…之间就可以共享</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>服务端技术，session依赖于cookie<ul>
<li>可以存储任意对象</li>
</ul>
</li>
<li>在一次会话的多次请求间共享数据，将数据保存在服务端的对象种</li>
</ul>
<h2 id="获取Session"><a href="#获取Session" class="headerlink" title="获取Session"></a>获取Session</h2><ul>
<li><code>HttpSession session = request.getSession()</code><ul>
<li>若session不存在则创建，存在则获取</li>
</ul>
</li>
</ul>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><ul>
<li>第一次访问会创建session并分配<code>JSessionID</code></li>
<li>响应到客户端,并以cookie形式存储</li>
<li>以后访问会带着这个cookie<ul>
<li>若有此cookie则可以获取session</li>
<li>若无此cookie则视为第一次访问，循环…。</li>
</ul>
</li>
</ul>
<h2 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h2><ul>
<li><code>String getId()</code><ul>
<li>获取session的JSessionID</li>
</ul>
</li>
<li><code>setMaxInactiveInterval(int interval)</code><ul>
<li>设置session存活时间，默认30分</li>
</ul>
</li>
<li><code>invalidate()</code><ul>
<li>销毁session </li>
</ul>
</li>
</ul>
<h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h2><h3 id="客户端关闭，服务器不关闭，两次获取的session是否是同一个"><a href="#客户端关闭，服务器不关闭，两次获取的session是否是同一个" class="headerlink" title="客户端关闭，服务器不关闭，两次获取的session是否是同一个"></a>客户端关闭，服务器不关闭，两次获取的session是否是同一个</h3><ul>
<li>默认情况下，不是<ul>
<li>因为虽然session默认存活30分钟，但是session是以cookie的形式保存在客户端的，而cookie默认客户端已关闭就会消失。</li>
</ul>
</li>
<li>若想获取同一个<ul>
<li>可以创建Cookie，键为<code>JSessionID</code>，并设置存活时间</li>
</ul>
</li>
</ul>
<h3 id="客户端不关闭，服务器关闭，两次获取的session是否是同一个"><a href="#客户端不关闭，服务器关闭，两次获取的session是否是同一个" class="headerlink" title="客户端不关闭，服务器关闭，两次获取的session是否是同一个"></a>客户端不关闭，服务器关闭，两次获取的session是否是同一个</h3><ul>
<li>不是<ul>
<li>因为对象的地址值是有随机性的，服务器重启会重新创建。两次创建很难一样。</li>
</ul>
</li>
<li>对象虽然不是同一个，但需要保证数据不丢失<ul>
<li>使用<strong>Session的钝化和活化</strong></li>
<li>在服务器关闭时将session钝化，服务器再次开启时将session活化</li>
<li>注<ul>
<li>dos命令下，正常关闭tomcat，tomcat会自动钝化session，在<code>work</code>目录下生成<code>Session.ser</code>文件，再次启动，会活化。</li>
<li>idea中，idea使用虚拟目录方式部署应用，在idea中关闭tomcat时，也会钝化，但是再次启动时，idea会先删除<code>work</code>目录，钝化的文件被删除了，也就无法活化了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Session的销毁"><a href="#Session的销毁" class="headerlink" title="Session的销毁"></a>Session的销毁</h3><ol>
<li>服务器关闭</li>
<li>调用<code>invalidate()</code></li>
<li>tomcat的<code>/conf/web.xml</code>中的默认配置<code>&lt;session-config&gt;</code><ul>
<li>默认是30分钟，可以自己修改</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/xd-上传和下载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/xd-上传和下载/" itemprop="url">
                  xd-上传和下载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-28 00:43:09" itemprop="dateCreated datePublished" datetime="2018-12-28T00:43:09+08:00">2018-12-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:39:28" itemprop="dateModified" datetime="2019-03-08T14:39:28+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ol>
<li>提供form表单 method为post</li>
<li>enctype属性为<code>multipart/form-data</code></li>
<li>提供<code>&lt;input type=&quot;file&quot; name=&quot;mn&quot;&gt;</code>上传输入域</li>
</ol>
<h3 id="enctype"><a href="#enctype" class="headerlink" title="enctype"></a>enctype</h3><ul>
<li>告知服务器请求正文的MIME类型。（请求消息头：Content-Type作用是一致的）</li>
<li><p><code>application/x-www-form-urlencoded</code></p>
<ul>
<li>默认<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//请求信息</span><br><span class="line">//请求行</span><br><span class="line">//请求头</span><br><span class="line">...</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">...</span><br><span class="line">请求体</span><br><span class="line">name=an3&amp;mn(input中file的name)=文件名(mm.jpg)</span><br><span class="line">//服务器获取数据</span><br><span class="line">String name = request.getParameter(&quot;name&quot;)</span><br><span class="line">String name=request.getParameter(&quot;mm&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>multipart/form-data</code></p>
<ul>
<li>上传用</li>
<li>使用<code>request.getParameter(key)</code>取不到表单数据</li>
<li><p>获取数据要使用流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//请求信息</span><br><span class="line">//请求行</span><br><span class="line">//请求头</span><br><span class="line">...</span><br><span class="line">Content-Type:multipart/form-data; boundar=======7df24c3430fa2</span><br><span class="line">//请求体</span><br><span class="line"> boundar=======7df24c3430fa2</span><br><span class="line">Content-Disposition: form-data; name=&quot;name&quot;</span><br><span class="line">an3</span><br><span class="line"> boundar=======7df24c3430fa2</span><br><span class="line">Content-Disposition: form-data; name=&quot;mn&quot;; filename=&quot;mm.jpg&quot;</span><br><span class="line">Contenet-Type: image/pjpeg</span><br><span class="line">图片的二进制数据</span><br><span class="line">//服务器获取数据</span><br><span class="line">//用字节流获取请求体的所有内容</span><br><span class="line">request.getInputStream()</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明(安)</p>
<ul>
<li>可以看出enctype为<code>multipart/form-data</code>时<ul>
<li>请求体中包含了文件名，文件类型，文件具体内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件上传原理"><a href="#文件上传原理" class="headerlink" title="文件上传原理"></a>文件上传原理</h2><ul>
<li>解析请求体的每部分的内容</li>
</ul>
<h2 id="上传步骤-安"><a href="#上传步骤-安" class="headerlink" title="上传步骤(安)"></a>上传步骤(安)</h2><ul>
<li>获取上传的文件的输入流</li>
<li>确定服务器保存路径</li>
<li>确定服务器保存文件名</li>
<li>新建File对象(路径+文件名)</li>
<li>以新建的file对象创建输出流</li>
<li>然后读写操作。。</li>
</ul>
<h2 id="上传需要注意的问题-安"><a href="#上传需要注意的问题-安" class="headerlink" title="上传需要注意的问题(安)"></a>上传需要注意的问题(安)</h2><ul>
<li>文件路径<ul>
<li>存储在服务器端的路径</li>
</ul>
</li>
<li>文件名<ul>
<li>存储的文件名，避免重复</li>
<li>随机啊日期啊</li>
</ul>
</li>
</ul>
<h2 id="fileupload"><a href="#fileupload" class="headerlink" title="fileupload"></a>fileupload</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>第三方的上传组件用来解析上传文件，帮我们解析<code>request.getInputStream()</code></li>
</ul>
<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><ul>
<li><code>DiskFileItemFactory</code></li>
<li><code>ServletFileUpload</code></li>
<li><code>FileItem</code></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><code>DiskFileItemFactory factory = new DiskFileItemFactory()</code><ul>
<li>创建工厂类DiskFileItemFactory对象</li>
<li>创建工厂时还可以指定缓存文件的大小和临时文件的位置</li>
<li>或者先创建，然后set也行<ul>
<li><code>factory.setSizeThreshold(字节)</code></li>
<li><code>factory.setRepository(new File(path))</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ServletFileUpload fileUpload = new ServletFileUpload(factory)</code><ul>
<li>使用工厂创建解析器对象ServletFileUpload</li>
</ul>
</li>
<li><code>fileUpload.isMultipartContent(request)</code><ul>
<li>判断表单<code>enctype</code>是否是上传.</li>
</ul>
</li>
<li><code>List&lt;FileItem&gt; list = fileUpload.parseRequest(request)</code><ul>
<li>使用解析器来解析request对象</li>
</ul>
</li>
</ul>
<h4 id="FileItem"><a href="#FileItem" class="headerlink" title="FileItem"></a>FileItem</h4><ul>
<li>对应一个表单项（表单字段）。可以是文件字段或普通字段</li>
<li><code>boolean isFormField()</code><ul>
<li>判断当前表单字段是否为普通文本字段，如果返回false，说明是文件字段</li>
</ul>
</li>
<li><code>String getFieldName()</code><ul>
<li>获取字段名称</li>
</ul>
</li>
<li><code>String getString()</code><ul>
<li>获取字段的内容</li>
<li>如果是文件字段(必须是文本文件)，那么获取的是文件内容。</li>
<li>可以传入编码参数<ul>
<li><code>getString(&quot;utf-8&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>String getName()</code><ul>
<li>获取文件字段的文件名称(如：mm.jpg)</li>
</ul>
</li>
<li><code>String getContentType()</code><ul>
<li>获取上传的文件的MIME类型，例如：text/plain。</li>
</ul>
</li>
<li><code>int getSize()</code><ul>
<li>获取上传文件的大小</li>
</ul>
</li>
<li><code>InputStream getInputStream()</code><ul>
<li>获取上传文件对应的输入流；</li>
</ul>
</li>
<li><code>void write(File)</code><ul>
<li>把上传的文件保存到指定文件中</li>
</ul>
</li>
<li><code>IOUtils.copey(in,out)</code><ul>
<li>工具类保存</li>
</ul>
</li>
<li><code>delete()</code><ul>
<li>清理临时文件</li>
</ul>
</li>
</ul>
<h3 id="上传要考虑的问题"><a href="#上传要考虑的问题" class="headerlink" title="上传要考虑的问题"></a>上传要考虑的问题</h3><ul>
<li>文件名问题<ul>
<li>上传的文件名是全路径，有的浏览器会自动处理，有的不会，最好处理一下。<ol>
<li>手动处理</li>
<li><code>FilenameUtils</code></li>
</ol>
</li>
</ul>
</li>
<li>保证服务器安全<ul>
<li>把保存上传文件的目录放在用户直接访问不到的地方(web-inf下)</li>
</ul>
</li>
<li>避免文件被覆盖<ul>
<li>文件名唯一</li>
</ul>
</li>
<li>避免同一个文件夹中的文件过多<ul>
<li>按照日期进行打散存储目录</li>
<li>用文件名的hashCode计算打散的存储目录：二级目录</li>
</ul>
</li>
<li>限制文件的大小：web方式不适合上传大的文件<ul>
<li>单个文件大小<ul>
<li><code>ServletFileUpload.setFileSizeMax(字节)</code></li>
</ul>
</li>
<li>总文件大小：（多文件上传）<ul>
<li><code>ServletFileUpload.setSizeMax(字节)</code></li>
</ul>
</li>
</ul>
</li>
<li>上传字段用户没有上传的问题<ul>
<li>通过判断文件名是否为空即可</li>
</ul>
</li>
<li>临时文件的问题<ul>
<li><code>DiskFileItemFactory</code><ul>
<li>内部有一个缓存，缓存大小默认是10Kb。如果上传的文件超过10Kb，用磁盘作为缓存。</li>
<li>存放缓存文件的目录默认是系统的临时目录。</li>
<li>可以自己设置缓存大小，和临时目录（见上边）</li>
</ul>
</li>
<li>上传后，会在临时目录产生一个临时文件。</li>
<li>如果自己用IO流实现的文件上传，要在流关闭后，清理临时文件。<ul>
<li><code>FileItem.delete();</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><code>Content-disposition</code><ul>
<li>响应头，服务器告诉客户端以什么格式打开响应体数据</li>
<li><code>in-line</code><ul>
<li>默认值</li>
<li>在当前页面内打开</li>
</ul>
</li>
<li><code>attachment;filename=</code><ul>
<li>以附件形式打开响应体</li>
<li>文件下载</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li>设置响应头告诉浏览器是下载文件<ul>
<li><code>response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+fileName);</code></li>
</ul>
</li>
<li>设置响应头告诉浏览器下载的文件类型<ol>
<li><code>response.setHeader(&quot;content-type&quot;, &quot;image/jpeg&quot;);</code><ul>
<li>手动设置文件类型是图片</li>
</ul>
</li>
<li><code>response.setContentType(this.getServletContext().getMimeType(fileName))</code><ul>
<li>设置类型为根据文件名获取的类型</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>根据请求参数获取文件名<ul>
<li><code>String filename = request.getParameter(String filename)</code></li>
</ul>
</li>
<li>根据文件名获取文件服务器路径<ul>
<li><code>String path=this.getServletContext.getRealPath(&quot;/filename&quot;);</code></li>
</ul>
</li>
<li>根据文件路径创建输入流</li>
<li>设置响应头<ol>
<li>下载文件</li>
<li>文件类型</li>
</ol>
</li>
<li>获取响应输出流，不断读写</li>
</ol>
<h3 id="下载文件名中文问题"><a href="#下载文件名中文问题" class="headerlink" title="下载文件名中文问题"></a>下载文件名中文问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// agent就是请求头User-Agent的值</span><br><span class="line">public class DownLoadUtils &#123;</span><br><span class="line">    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException &#123;</span><br><span class="line">        if (agent.contains(&quot;MSIE&quot;)) &#123;</span><br><span class="line">            // IE浏览器</span><br><span class="line">            filename = URLEncoder.encode(filename, &quot;utf-8&quot;);</span><br><span class="line">            filename = filename.replace(&quot;+&quot;, &quot; &quot;);</span><br><span class="line">        &#125; else if (agent.contains(&quot;Firefox&quot;)) &#123;</span><br><span class="line">            // 火狐浏览器</span><br><span class="line">            BASE64Encoder base64Encoder = new BASE64Encoder();</span><br><span class="line">            filename = &quot;=?utf-8?B?&quot; + base64Encoder.encode(filename.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其它浏览器</span><br><span class="line">            filename = URLEncoder.encode(filename, &quot;utf-8&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return filename;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-JDBC/" itemprop="url">
                  xd-JDBC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:38:09" itemprop="dateCreated datePublished" datetime="2018-12-11T00:38:09+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:41:47" itemprop="dateModified" datetime="2019-03-08T14:41:47+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>Java DataBase Connectivity</code></li>
<li>SUN公司提供的一套操作数据库的标准规范</li>
<li>是一种用于执行SQL语句的Java API,是一种技术规范，可以方便连接各种常用数据库。</li>
<li>数据库提供的驱动<code>.jar</code>文件实现了jdbc接口。</li>
<li>JDBC主要完成三件事<ul>
<li>建立连接</li>
<li>发送SQL语句</li>
<li>处理返回的结果</li>
</ul>
</li>
</ul>
<h1 id="核心接口类"><a href="#核心接口类" class="headerlink" title="核心接口类"></a>核心接口类</h1><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><ul>
<li>驱动管理对象。用于注册驱动</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>static void registerDriver(Driver driver)</code><ul>
<li>注册驱动</li>
</ul>
</li>
<li><code>static Connection getConnection(String url)</code><ul>
<li>user和password用参数的形式写在url上</li>
</ul>
</li>
<li><code>static Connection getConnection(String url, Properties prop)</code><ul>
<li>将信息写入一个properties集合中</li>
</ul>
</li>
<li><code>static Connection getConnection(String url, String user, String password)</code></li>
</ul>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ul>
<li>数据库连接对象</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>Statement createStatement()</code></li>
<li><code>PreparedStatement prepareStatement(String sql)</code></li>
<li><code>CallableStatement prepareCall(String sql)</code><ul>
<li>用于执行对数据库存储过程的调用</li>
</ul>
</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li><code>void setAutoCommit(boolean autoCommit)</code><ul>
<li>将自动提交设置为false即视为开启事务。</li>
</ul>
</li>
<li><code>void commit()</code></li>
<li><code>void rollback()</code></li>
<li><code>void setTransactionIsolation(int level)</code><ul>
<li>设置隔离级别(必须在开启事务之前)<ul>
<li>level 常量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><ul>
<li>用于执行静态 SQL 语句并返回它所生成结果的对象</li>
</ul>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>ResultSet executeQuery(String sql)</code><ul>
<li>根据查询(select)语句，返回结果集</li>
</ul>
</li>
<li><code>int executeUpdate(String sql)</code><ul>
<li>根据执行的DML（insert update delete）语句，返回受影响的行数。</li>
</ul>
</li>
<li><code>boolean execute(String sql)</code><ul>
<li>可以执行任意sql语句。返回boolean值，表示是否返回ResultSet结果集。</li>
<li>仅当执行select语句，且有返回结果时返回true, 其它语句都返回false;</li>
</ul>
</li>
</ul>
<h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><ul>
<li>预编译对象。</li>
<li>性能高，会预编译sql语句。</li>
<li>是<code>Statement</code>子接口</li>
</ul>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>ResultSet executeQuery()</code></li>
<li><code>int executeUpdate()</code></li>
<li><code>boolean execute()</code></li>
<li><code>setXxx(int index, Xxx value)</code><ul>
<li>为占位符参数赋值，index从1开始</li>
</ul>
</li>
</ul>
<h3 id="Sql注入"><a href="#Sql注入" class="headerlink" title="Sql注入"></a>Sql注入</h3><ul>
<li><code>x&#39; or &#39;a&#39;=&#39;a</code><ul>
<li>使用字符串拼接，导致判断条件总是为true，安全隐患</li>
</ul>
</li>
</ul>
<h3 id="PreparedStatement解决sql注入"><a href="#PreparedStatement解决sql注入" class="headerlink" title="PreparedStatement解决sql注入"></a>PreparedStatement解决sql注入</h3><ul>
<li>sql语句中用<code>?</code>作为占位符</li>
<li>给<code>?</code>赋值(根据类型)<ul>
<li><code>setXxx(int index, value)</code></li>
</ul>
</li>
</ul>
<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><ul>
<li>表示数据库结果集的数据表</li>
<li>提供一个游标，默认游标指向结果集第一行之前</li>
</ul>
<h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>boolean next()</code><ul>
<li>将光标从当前位置向下移一行</li>
</ul>
</li>
<li>每个可能的数据类型都有一个get方法，每个get方法有两个版本<ul>
<li><code>rs.getInt(&quot;id&quot;)</code><ul>
<li>一个是采用列名称。</li>
</ul>
</li>
<li><code>rs.getInt(1)</code><ul>
<li>另一个采用列索引。</li>
<li>注意索引从1开始</li>
</ul>
</li>
<li>不确定类型也可以用Object<ul>
<li><code>rs.getObject(&quot;id&quot;)</code></li>
<li><code>rs.getObject(1)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="不同数据库的-driver-amp-url"><a href="#不同数据库的-driver-amp-url" class="headerlink" title="不同数据库的 driver &amp; url"></a>不同数据库的 driver &amp; url</h1><table>
<thead>
<tr>
<th>数据库</th>
<th>JDBC驱动程序名称</th>
<th>URL格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL</td>
<td><code>com.mysql.jdbc.Driver</code></td>
<td><code>jdbc:mysql://hostname/databaseName</code></td>
</tr>
<tr>
<td>ORACLE</td>
<td><code>oracle.jdbc.driver.OracleDriver</code></td>
<td><code>jdbc:oracle:thin:@hostname:portNumber:databaseName</code></td>
</tr>
<tr>
<td>PostgreSQL</td>
<td><code>org.postgresql.Driver</code></td>
<td><code>jdbc:postgresql://hostname:port/dbname</code></td>
</tr>
<tr>
<td>DB2</td>
<td><code>com.ibm.db2.jdbc.net.DB2Driver</code></td>
<td><code>jdbc:db2:hostname:port Number/databaseName</code></td>
</tr>
<tr>
<td>Sybase</td>
<td><code>com.sybase.jdbc.SybDriver</code></td>
<td><code>jdbc:sybase:Tds:hostname: portNumber/databaseName</code></td>
</tr>
</tbody>
</table>
<h1 id="JDBC使用步骤"><a href="#JDBC使用步骤" class="headerlink" title="JDBC使用步骤"></a>JDBC使用步骤</h1><ol>
<li>导入数据库驱动包</li>
<li>注册JDBC驱动<ol>
<li>(不推荐)<ul>
<li><code>void DriverManager.registerDriver(Driver driver)</code><ul>
<li>会造成DriverManager中产生两个一样的驱动<ul>
<li>装载Driver类(Driver类中有静态代码块，调用了<code>registerDriver</code>方法)时注册一次驱动，执行此代码时，又注册一次</li>
</ul>
</li>
<li>对具体的驱动类产生依赖<ul>
<li>由于实例化了<code>com.mysql.jdbc.Driver.class</code>，导致必须import该类，从而具体驱动产生了依赖。不方便扩展代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>(推荐)<ul>
<li><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code><ul>
<li>Driver类一加载，就会执行静态代码块中的注册方法。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>获取连接Connection</li>
<li>执行sql语句，获取结果集<ol>
<li><code>Statement</code>（不推荐）<ol>
<li>书写静态sql语句</li>
<li><code>Statement createStatement()</code><ul>
<li>使用连接创建Statement对象</li>
</ul>
</li>
<li>使用Statement对象执行静态sql语句，获取结果集</li>
</ol>
</li>
<li><code>PreparedStatement</code>（推荐）<ol>
<li>书写动态sql语句</li>
<li><code>PreparedStatement prepareStatement(String sql)</code><ul>
<li>使用连接创建PreparedStatement对象</li>
</ul>
</li>
<li>使用PreparedStatement对象为动态sql设置参数</li>
<li>执行，获取结果集</li>
</ol>
</li>
</ol>
</li>
<li>处理结果</li>
<li>关闭资源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (rs != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        rs.close();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    rs=null;</span><br><span class="line">&#125;</span><br><span class="line">if (ps != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    ps=null;</span><br><span class="line">&#125;</span><br><span class="line">if (conn != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    conn=null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-SQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-SQL/" itemprop="url">
                  xd-SQL
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:37:56" itemprop="dateCreated datePublished" datetime="2018-12-11T00:37:56+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:41:35" itemprop="dateModified" datetime="2019-03-08T14:41:35+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>Structure Query Language</code></li>
<li><ul>
<li>第一代：机器语言</li>
<li>第二代：汇编        </li>
<li>第三代：C/C++/C#/Java/VB/…</li>
<li>第四代：SQL【结构化查询语言，面向关系的】</li>
</ul>
</li>
<li>SQL92/【99】标准的四大分类<ul>
<li>DDL(数据定义语言Data Definition Language)<ul>
<li><code>create alter drop truncate</code></li>
<li>用来操作库,表…</li>
</ul>
</li>
<li>DML(数据操纵语言Data Manipulation Language)<ul>
<li><code>insert update delete</code></li>
<li>用来操作数据</li>
</ul>
</li>
<li>DQL (数据查询语言Data Query Language) <ul>
<li>select</li>
</ul>
</li>
<li>DCL(数据控制语言 Data Control Language)<ul>
<li><code>grant revoke</code></li>
</ul>
</li>
<li>TCL(事务控制语言)(自定义的。。。)<ul>
<li><code>commit，rollback，rollback to savepoint 。。。</code></li>
</ul>
</li>
</ul>
</li>
<li>sql的注释<ul>
<li><code>--</code><ul>
<li>单行</li>
</ul>
</li>
<li><code>/* */</code><ul>
<li>多行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>存储数据的仓库</li>
<li>高效的存储和处理数据的介质（介质：磁盘和内存）</li>
</ul>
<h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><ul>
<li>DBS<ul>
<li><code>Database System</code></li>
<li><code>DBS = DBMS + DB</code></li>
</ul>
</li>
<li>DBMS<ul>
<li><code>Database Management System</code></li>
<li>数据库管理系统</li>
</ul>
</li>
<li>DBA<ul>
<li><code>Database Administrator</code></li>
<li>数据库管理员</li>
</ul>
</li>
<li><code>行/记录</code><ul>
<li><code>row/record</code></li>
<li>本质是一个东西: 都是指表中的一行(一条记录)</li>
<li>行是从结构角度出发</li>
<li>记录是从数据角度出发</li>
</ul>
</li>
<li><code>列/字段</code><ul>
<li><code>column/field</code></li>
<li>本质是一个东西</li>
</ul>
</li>
</ul>
<h2 id="分类（按介质）"><a href="#分类（按介质）" class="headerlink" title="分类（按介质）"></a>分类（按介质）</h2><h3 id="关系型数据库（SQL）"><a href="#关系型数据库（SQL）" class="headerlink" title="关系型数据库（SQL）"></a>关系型数据库（SQL）</h3><ul>
<li>安全（保存磁盘不易丢失）容易理解，浪费空间（二维表）</li>
<li><code>Oracle DB2</code></li>
<li><code>Sql-Server Mysql</code></li>
<li><code>access</code></li>
</ul>
<h3 id="非关系型数据库（NoSQL：not-only-sql）"><a href="#非关系型数据库（NoSQL：not-only-sql）" class="headerlink" title="非关系型数据库（NoSQL：not only sql）"></a>非关系型数据库（NoSQL：not only sql）</h3><ul>
<li>效率高，不安全（断电丢失）</li>
<li><code>memcached mongodb redis</code></li>
</ul>
<h1 id="Mysql概述"><a href="#Mysql概述" class="headerlink" title="Mysql概述"></a>Mysql概述</h1><ul>
<li>是一种c/s结构的软件：若想访问服务器，必须通过客户端（服务器一直运行，客户端在需要时运行）</li>
<li><code>mysql.exe</code><ul>
<li>mysql自带客户端</li>
</ul>
</li>
<li><code>mysqld.exe</code><ul>
<li>服务端</li>
</ul>
</li>
</ul>
<h2 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h2><ol>
<li>客户端连接认证<ul>
<li>连接服务器</li>
<li>认证身份<ul>
<li><code>mysql.exe -hPup</code><ul>
<li><code>mysql.exe -hlocalhost -p3306 -uroot -proot</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>发送sql指令</li>
<li>服务器接收sql指令<ul>
<li>处理sql指令，返回操作结果</li>
</ul>
</li>
<li>客户端接收结果，显示结果</li>
<li>断开连接（释放资源：服务器并发限制）<ul>
<li><code>exit/quit/\q</code></li>
</ul>
</li>
</ol>
<h2 id="mysql服务器对象"><a href="#mysql服务器对象" class="headerlink" title="mysql服务器对象"></a>mysql服务器对象</h2><ul>
<li>没有办法完全了解服务器内部的内容：只能粗略去分析数据库服务器的内部结构</li>
<li>分为四层<ul>
<li>系统（DBMS）</li>
<li>数据库（DB）</li>
<li>数据表（Table）</li>
<li>字段（Field）</li>
</ul>
</li>
</ul>
<h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><ol>
<li>配置环境变量</li>
<li><p>配置mysql目录下的<code>.ini</code>配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//安装目录</span><br><span class="line">basedir =C:/soft/mysql-5.7.18-winx64</span><br><span class="line">//data目录</span><br><span class="line">datadir =C:/soft/mysql-5.7.18-winx64/data</span><br><span class="line">port = 3306</span><br><span class="line">character-set-server=utf8</span><br><span class="line">character_set_filesystem=utf8</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
<ul>
<li>注<ul>
<li>mysql解压版没有data目录</li>
<li>初始化后会出现data目录</li>
</ul>
</li>
</ul>
</li>
<li>初始化<ul>
<li><strong>windows</strong><ul>
<li><code>mysqld --initialize</code><ul>
<li>随机密码</li>
</ul>
</li>
<li><code>mysqld --initialize-insecure</code><ul>
<li>无密码</li>
</ul>
</li>
</ul>
</li>
<li><strong>unix</strong><ul>
<li><code>mysqld --initialize-insecure --user=mysql</code><ul>
<li>无密码</li>
</ul>
</li>
<li><code>mysqld --initialize --user=mysql --console</code><ul>
<li>有密码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>服务<ul>
<li><code>mysqld --install</code><ul>
<li>将MySQL添加到系统服务</li>
<li><code>Service successfully installed</code>服务安装成功。</li>
</ul>
</li>
<li><code>net start mysql</code><ul>
<li>启动服务</li>
</ul>
</li>
<li><code>net stop mysql</code><ul>
<li>停止服务</li>
</ul>
</li>
<li><code>mysqld remove</code> &amp; <code>sc delete mysql</code>？<ul>
<li>移除服务</li>
</ul>
</li>
</ul>
</li>
<li>登陆<ul>
<li><code>mysql -uroot -p</code><ul>
<li><code>msql&gt;</code>登录成功</li>
</ul>
</li>
</ul>
</li>
<li>修改密码<ul>
<li><code>alter user &#39;root&#39; @&#39;localhost&#39; identified by &#39;root&#39;;;</code><ul>
<li>将登陆账户密码修改为root</li>
</ul>
</li>
</ul>
</li>
<li>退出<ul>
<li><code>exit</code></li>
</ul>
</li>
<li>其它操作<ul>
<li><code>\c</code><ul>
<li>输错了想结束</li>
</ul>
</li>
<li><code>tee D;/xx.sql;</code><ul>
<li>存储输入的sql到xx.sql文件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="SQL基本操作"><a href="#SQL基本操作" class="headerlink" title="SQL基本操作"></a>SQL基本操作</h1><ul>
<li><code>CRUD</code></li>
<li>按操作对象分为<ul>
<li>库操作</li>
<li>表操作（字段）</li>
<li>数据操作</li>
</ul>
</li>
</ul>
<h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li><code>create database 库名 [库选项]</code><ul>
<li>数据库名<ul>
<li>不要用关键字和保留字</li>
<li>非要用的话使用单引号包括关键字</li>
</ul>
</li>
<li>库选项：用来约束数据库<ul>
<li>字符集设定<ul>
<li><code>charset/character set 字符集(数据存储的编码格式)</code></li>
</ul>
</li>
<li>校对设定<ul>
<li><code>collate 校对集(数据比较的规则)</code></li>
<li>校对集依赖字符集</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>创建数据库sql语句执行后<ol>
<li>在数据库系统中,增加了对应的数据库信息</li>
<li>在保存数据的文件夹（Data目录）下，创建一个对应数据库名字的文件夹</li>
<li>每个数据库下都有一个opt文件: 保存了库选项</li>
</ol>
</li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li><code>drop database 库名</code></li>
<li>删除数据库sql语句执行之后<ol>
<li>在数据库内部看不到对应的数据库</li>
<li>Data目录下，数据库名字对应的文件夹也被删除（级联删除：里面的数据表全部删除）<ul>
<li>删除不可逆</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul>
<li>数据库的修改<ul>
<li>名字不可修改</li>
<li>仅限库选项：字符集和校对集</li>
</ul>
</li>
<li><code>alter database 库名 [库选项];</code><ul>
<li><code>charset/character set [=] 字符集</code></li>
<li><code>collate 校对集</code></li>
</ul>
</li>
</ul>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li><code>show databases</code><ul>
<li>查看所有数据库</li>
</ul>
</li>
<li><code>show databases like &#39;pattern&#39;</code><ul>
<li>查看部分数据库</li>
<li><code>pattern</code>：匹配模式<ul>
<li><code>%</code><ul>
<li>匹配多个</li>
</ul>
</li>
<li><code>_</code><ul>
<li>匹配一个</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>show create database 库名</code><ul>
<li>查看数据库的创建语句</li>
</ul>
</li>
</ul>
<h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><ul>
<li>任何一个表的设计都必须指定数据库。<ol>
<li>显示的指定表所属数据库<ul>
<li><code>create table 库名.表明();</code></li>
</ul>
</li>
<li>隐式的指定所属数据库：先进入数据库<ul>
<li><code>use 库名;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table [if not exists] 表名(</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	字段名 数据类型	-- 最后一行不需要逗号</span><br><span class="line">)[表选项]</span><br></pre></td></tr></table></figure>
<ul>
<li>表选项：控制表的表现<ul>
<li>字符集<ul>
<li><code>charset/character set 字符集</code></li>
</ul>
</li>
<li>校对集<ul>
<li><code>collate 校对集</code></li>
</ul>
</li>
<li>存储引擎<ul>
<li><code>engine 存储引擎(innodb 和 myisam)</code></li>
</ul>
</li>
</ul>
</li>
<li>创建数据表的SQL指令执行之后<ol>
<li>指定数据库下已经存在对应的表</li>
<li>在数据库对应的文件夹下,会产生对应表的结构文件(跟存储引擎有关系)<ul>
<li><code>xxx.frm ...</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h3><ul>
<li><code>drop table 表名1,表名2...</code></li>
<li>删除数据表的SQL指令执行之后<ol>
<li>在表空间中,没有了指定的表(数据也没有了)</li>
<li>在数据库对应的文件夹下, 表对应的文件(与存储引擎有关)也会被删除</li>
</ol>
</li>
</ul>
<h3 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h3><ul>
<li>表的修改<ol>
<li>表本身<ul>
<li>表名</li>
<li>表选项<ul>
<li>字符集</li>
<li>校对集</li>
<li>存储引擎</li>
</ul>
</li>
</ul>
</li>
<li>字段<ul>
<li>增</li>
<li>删</li>
<li>改</li>
<li>重命名</li>
</ul>
</li>
</ol>
</li>
<li><code>rename table 表名 to 新表名</code></li>
<li><code>alter table 表名 表选项 [=] 值</code><ul>
<li>修改表选项</li>
</ul>
</li>
<li><code>alter table 表名 add [column] 字段名 数据类型 [列属性] [位置]</code><ul>
<li>新增字段</li>
<li>位置<ul>
<li>字段可以存放表中的任意位置</li>
<li><code>first</code></li>
<li><code>after</code><ul>
<li>默认再最后一个字段之后</li>
<li><code>after 字段名</code>新增到哪个字段之后</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>alter table 表名 drop 字段名</code><ul>
<li>删除字段</li>
</ul>
</li>
<li><code>alter table 表名 modify 字段名 数据类型 [列属性] [位置]</code><ul>
<li>修改字段</li>
</ul>
</li>
<li><code>alter table 表名 change 字段名 新字段名 数据类型 [列属性] [位置]</code><ul>
<li>重命名字段</li>
</ul>
</li>
</ul>
<h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><ul>
<li><code>show tables</code></li>
<li><code>show tables like &#39;pattern&#39;</code></li>
<li><code>show create table 表名</code><ul>
<li><code>\g</code><ul>
<li>横向显示</li>
</ul>
</li>
<li><code>\G</code><ul>
<li>纵向显示</li>
</ul>
</li>
</ul>
</li>
<li><code>desc/describe/show columns from 表名</code><ul>
<li>查看表中字段</li>
</ul>
</li>
</ul>
<h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h3><ul>
<li><code>insert into 表名 values(值列表)[,(值列表)]</code><ul>
<li>给全表字段插入数据，不需要指定字段列表<ul>
<li>值数据顺序与表字段顺序一致</li>
<li>非数值数据，都要使用引号(建议单引号)</li>
</ul>
</li>
<li>可以一次性插入多条记录</li>
</ul>
</li>
<li><code>insert into 表名(字段列表) values(值列表)[,(值列表)]</code><ul>
<li>插入指定字段</li>
</ul>
</li>
</ul>
<h3 id="删-2"><a href="#删-2" class="headerlink" title="删"></a>删</h3><ul>
<li><code>delete from 表名 [where条件]</code></li>
<li><code>truncate 表名;</code><ul>
<li>清空表</li>
</ul>
</li>
<li>truncate和delete区别<ul>
<li>DELETE 删除表中的数据，表结构还在，删除后的数据可以找回<ul>
<li>如果表中存在主键自增长,那么当删除之后, 自增长不会还原</li>
</ul>
</li>
<li>TRUNCATE 是把表直接DROP掉，然后再创建一个同样数据结构的新表</li>
</ul>
</li>
</ul>
<h3 id="改-2"><a href="#改-2" class="headerlink" title="改"></a>改</h3><ul>
<li><code>update 表名 set 字段 = 值 [where条件]</code><ul>
<li>更新不一定会成功: 如没有真正要更新的数据</li>
</ul>
</li>
</ul>
<h3 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h3><ul>
<li><code>select */字段列表 from 表名 [where条件]</code></li>
</ul>
<h1 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><ul>
<li><strong><code>tinyint</code></strong><ul>
<li>1个字节 </li>
</ul>
</li>
<li><code>smallint</code><ul>
<li>2个字节</li>
</ul>
</li>
<li><code>mediumint</code><ul>
<li>3个字节</li>
</ul>
</li>
<li><strong><code>int</code></strong><ul>
<li>4个字节</li>
</ul>
</li>
<li><code>bigint</code><ul>
<li>8个字节</li>
</ul>
</li>
</ul>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h5><ul>
<li><code>字段名 数值型 unsigned</code><ul>
<li>无符号 从0开始</li>
<li>sql中的数值型默认都是有符号的。<ul>
<li>一个字节有符号<code>-128 ~ 127</code></li>
<li>一个字节无符号<code>0 ~ 255</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="M-amp-zerofill"><a href="#M-amp-zerofill" class="headerlink" title="(M) &amp; zerofill"></a>(M) &amp; zerofill</h5><ul>
<li><code>字段名 整型(M) zerofill</code><ul>
<li><code>(M)</code><ul>
<li>总共M位数（包含符号）</li>
<li>与<code>zerofill</code>配合使用才有意义（不足M位的用0补）</li>
</ul>
</li>
<li><code>zerofill</code><ul>
<li>用零填充</li>
<li>如果声明零填充，则会自动声明为<code>unsigned</code>无符号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="小数型"><a href="#小数型" class="headerlink" title="小数型"></a>小数型</h3><ul>
<li>浮点型<ul>
<li>小数点浮动, 精度有限,而且会丢失精度</li>
<li>整数部分不能超出长度（整数部分可能会被四舍五入进位），小数部分可以（系统自动四舍五入）<ul>
<li>如果因为系统四舍五入使整数部分超出长度也可以</li>
</ul>
</li>
</ul>
</li>
<li>定点型<ul>
<li>小数点固定, 精度固定, 不会丢失精度</li>
<li>整数部分不能超出长度（整数部分不会被四舍五入进位），小数部分可以（系统自动四舍五入）<ul>
<li>如果因为系统四舍五入使整数部分超出长度不可以</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><ul>
<li><code>float</code><ul>
<li>单精度 4个字节</li>
</ul>
</li>
<li><code>double</code><ul>
<li>双精度 8个字节</li>
</ul>
</li>
</ul>
<h4 id="定点型"><a href="#定点型" class="headerlink" title="定点型"></a>定点型</h4><ul>
<li><code>decimal</code><ul>
<li>变长，大致每9个数字采用4个字节存储，整数小数分开计算。</li>
</ul>
</li>
</ul>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><h5 id="unsigned-1"><a href="#unsigned-1" class="headerlink" title="unsigned"></a>unsigned</h5><h5 id="M-D-amp-zerofill"><a href="#M-D-amp-zerofill" class="headerlink" title="(M,D) &amp; zerofill"></a>(M,D) &amp; zerofill</h5><ul>
<li><code>字段名 小数型(M,D)</code><ul>
<li>M<ul>
<li>精度 表示总位数</li>
</ul>
</li>
<li>D<ul>
<li>标度 表示小数部分位数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ul>
<li><code>char</code><ul>
<li>定长字符串，磁盘（二维表）再定义结构时，就已经确定了最终数据的存储长度。</li>
<li><code>char(L)</code><ul>
<li>L表示存储长度(字符数)，单位为字符</li>
<li>最大长度255</li>
<li>char存储时如果不够L个字符，则内部用空格补齐，取出时去掉右侧空格。速度比varchar快。<ul>
<li>如果存的数据右侧本身带空格，会丢失。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>varchar</code><ul>
<li>变长字符串，在分配空间时按照最大的空间分配，但实际使用空间根据具体数据来确定。</li>
<li><code>varchar(L)</code><ul>
<li>最大长度65536</li>
<li>varcar存储时在列内容前，用1-2个字节来标志该列的内容长度。<ul>
<li>这样知道长度，才知道取值时到哪里结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
<th>可存字符</th>
<th>实存字符(i&lt;=M)</th>
<th>实占空间</th>
<th>利用率</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>M</td>
<td>M</td>
<td>i</td>
<td>M*3字节</td>
<td>i/M&lt;=100%</td>
</tr>
<tr>
<td>varchar</td>
<td>M</td>
<td>M</td>
<td>i</td>
<td>i*3+(1~2)字节</td>
<td>i/i+(1~2)&lt;=100%</td>
</tr>
</tbody>
</table>
<ul>
<li>定长与变长的选择<ul>
<li>定长磁盘空间比较浪费，但效率高，如果数据确定长度一致<ul>
<li>身份证，电话，手机号</li>
</ul>
</li>
<li>变长磁盘空间比较节省，但效率低，如果数据不能确定长度</li>
</ul>
</li>
<li><strong>nchar &amp; nvarchar</strong><ul>
<li>前缀n表示Unicode字符</li>
<li>使用Unicode字符，即所有字符都占两个字节</li>
<li>char &amp; varchar<ul>
<li>最多8000个英文，4000个汉字</li>
</ul>
</li>
<li>nchar &amp; nvarchar<ul>
<li>可存储4000个字符，无论英文还是汉字</li>
</ul>
</li>
<li>(网)<ul>
<li>如果纯英文数字<ul>
<li>char varchar</li>
</ul>
</li>
<li>如果有中文<ul>
<li>nchar nvarchar</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>text</code><ul>
<li>长文本数据</li>
<li>如果数据超过255个字符</li>
<li>存储二进制数据<ul>
<li>实际上都是存储路径</li>
</ul>
</li>
</ul>
</li>
<li><code>blob</code><ul>
<li>二进制形式的长文本数据（图像,音频等二进制信息）(通常不用)</li>
<li>防止因为字符集的问题导致信息丢失。</li>
</ul>
</li>
<li><code>enum</code><ul>
<li>枚举</li>
<li>事先将所有可能的结果设计好，实际存储数据必须是规定好的数据之一。</li>
<li>枚举存储的数据是数值，节省空间</li>
<li>定义<ul>
<li><code>enum(可能出现的元素列表)</code><ul>
<li><code>enum(&#39;value1&#39;,&#39;value2&#39;,...)</code></li>
</ul>
</li>
</ul>
</li>
<li>使用<ul>
<li>只能添加给出的枚举值中的一个</li>
<li>可以直接插入数值</li>
</ul>
</li>
<li>原理<ul>
<li>枚举在进行数据规范的时候(定义的时候),系统会自动建立一个数字与枚举元素的对应关系(关系放到日志中): 然后在进行数据插入的时候,系统自动将字符转换成对应的数字存储, 然后在进行数据提取的时候, 系统自动将数值转换成对应的字符串显示</li>
<li>从1开始编号，最大65535</li>
</ul>
</li>
</ul>
</li>
<li><code>set</code><ul>
<li>集合类似枚举，实际存储的是整型数值而不是字符串。集合是多选。</li>
<li>定义<ul>
<li><code>set(元素列表)</code></li>
</ul>
</li>
<li>使用<ul>
<li>一次插入可以选其中一个值，也可以选多个值(<code>,</code>隔开)</li>
<li>可以直接插入数值</li>
</ul>
</li>
<li>原理<ul>
<li>类似枚举，集合中每一个元素都是对应一个二进制位<ul>
<li>被选中为1，未选中0，最后反过来就是最终的数值</li>
</ul>
</li>
<li>插入元素的顺序没有关系: 最终系统都会去匹配集合，匹配到的置为1.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="时间日期类型"><a href="#时间日期类型" class="headerlink" title="时间日期类型"></a>时间日期类型</h2><ul>
<li><code>date</code><ul>
<li>日期 <code>yyyy-mm-dd</code></li>
</ul>
</li>
<li><code>time</code><ul>
<li>时间（段） <code>hh:mm:ss</code></li>
<li>可以使用负数</li>
</ul>
</li>
<li><code>datetime</code><ul>
<li>日期时间 <code>yyyy-mm-dd hh:mm:ss</code></li>
<li>表示范围从1000到9999年</li>
<li>有0值<code>0000-00-00 00:00:00</code></li>
</ul>
</li>
<li><code>timestamp</code><ul>
<li>时间戳 ，并不是时间戳，只是从1970年开始的<code>yyyy-mm-dd hh:mm:ss</code></li>
<li>只要当前所在记录被更新，时间戳就会被修改为当前时间。</li>
</ul>
</li>
<li><code>year</code><ul>
<li>年份 <code>YYYY</code></li>
<li><code>year(2)</code><ul>
<li><code>1970~2069</code></li>
</ul>
</li>
<li><code>year(4)</code><ul>
<li><code>1901~2155</code></li>
<li>(0000表示错误)共255</li>
</ul>
</li>
</ul>
</li>
<li>注<ul>
<li>日期格式的列不支持默认值（timestamp支持）</li>
</ul>
</li>
</ul>
<h1 id="Mysql记录长度"><a href="#Mysql记录长度" class="headerlink" title="Mysql记录长度"></a>Mysql记录长度</h1><ul>
<li>任何一条记录最长不能超过65535个字节(varchar永远达不到理论值)<ul>
<li>varchar的实际存储长度要看字符编码<ul>
<li>utf-8：21844个字符<ul>
<li>21844*3 + 2 = 65532 + 2 = 65534</li>
</ul>
</li>
<li>gbk：32766个字符<ul>
<li>32766*2 +2 = 65532 + 2 = 65534</li>
</ul>
</li>
</ul>
</li>
<li>但是一个记录中一个varchar字段一个tiny字段会超出长度，因为null会占用一个字节。</li>
</ul>
</li>
<li>mysql记录中，如果有任何一个字段允许为空，那么系统会自动从整个记录中保留一个字节来存储NULL<ul>
<li>若想释放NULL所占用的字节: 必须保证所有的字段都不允许为空</li>
</ul>
</li>
<li>Mysql中text文本字符串,不占用记录长度: 额外存储. 但是text文本字符串也是属于记录的一部分: 一定需要占据记录中的部分长度: 10个字节(保存数据的地址以及长度).</li>
</ul>
<h1 id="列属性"><a href="#列属性" class="headerlink" title="列属性"></a>列属性</h1><h2 id="空属性"><a href="#空属性" class="headerlink" title="空属性"></a>空属性</h2><ul>
<li><code>null</code><ul>
<li>默认</li>
<li>null没有意义，且运算一律返回null，效率不高，影响索引结果，所以建表时通常<code>not null default&#39;&#39;/0/0.00</code><ul>
<li><code>null==null</code><ul>
<li><code>null</code></li>
</ul>
</li>
<li><code>null!=null</code><ul>
<li><code>null</code><ul>
<li>结果还是null，即为false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>not null</code></li>
</ul>
<h2 id="列描述"><a href="#列描述" class="headerlink" title="列描述"></a>列描述</h2><ul>
<li><code>字段名 数据类型 comment &#39;描述信息&#39;</code><ul>
<li><code>comment</code><ul>
<li>注释，没有实际含义，是专门用来描述字段，会根据表创建语句保存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><ul>
<li><code>字段名 数据类型 default 值</code></li>
<li>默认值的生效<ul>
<li>插入数据时，不给有默认值的字段插入数据</li>
</ul>
</li>
<li>使用默认值时插入数据可以使用<code>default</code>关键字</li>
</ul>
<h2 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><ul>
<li><code>primary key</code></li>
</ul>
<h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ul>
<li>非null 唯一</li>
</ul>
<h4 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h4><ol>
<li>建表时在字段后跟primary key<ul>
<li><code>字段名 数据类型 primary key</code><ul>
<li><code>id int primary key</code></li>
</ul>
</li>
<li>优点<ul>
<li>非常直接</li>
</ul>
</li>
<li>缺点<ul>
<li>只能使用一个字段作为主键</li>
</ul>
</li>
</ul>
</li>
<li><p>建表时，在所有字段后使用primary key，可以是复合主键</p>
<ul>
<li><code>primary key(主键字段列表)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id int ,</span><br><span class="line">name varchar(10),</span><br><span class="line">primary key(id,name)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>表已经创建好之后，追加主键</p>
<ul>
<li>前提<ul>
<li>表中字段对应的数据本身是独立的(不重复)</li>
</ul>
</li>
</ul>
<ol>
<li><code>alter table 表名 modify 字段名 数据类型 primary key</code><ul>
<li>通过修改表字段</li>
</ul>
</li>
<li><code>alter table 表名 add primary key(主键字段列表)</code><ul>
<li>通过给字段添加主键</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="更新主键-amp-删除主键"><a href="#更新主键-amp-删除主键" class="headerlink" title="更新主键 &amp; 删除主键"></a>更新主键 &amp; 删除主键</h4><ul>
<li>主键无法更新，必须先删除才能添加。</li>
<li>删除<ul>
<li><code>alter table 表名 drop primary key</code></li>
</ul>
</li>
</ul>
<h4 id="主键分类"><a href="#主键分类" class="headerlink" title="主键分类"></a>主键分类</h4><ul>
<li>业务主键<ul>
<li>数据的属性字段。</li>
</ul>
</li>
<li>逻辑主键<ul>
<li>实际很少使用数据属性，而是使用没有实际含义的逻辑字段</li>
</ul>
</li>
</ul>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><ul>
<li>外面的键(键不在自己表中): 如果一张表中有一个字段(非主键)指向另外一张表的主键,那么将该字段称之为外键. </li>
</ul>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><ul>
<li>外键约束有三种约束模式: 都是针对父表的约束<ul>
<li><code>District</code><ul>
<li>严格模式(默认的), 父表不能删除或者更新一个已经被子表数据引用的记录</li>
</ul>
</li>
<li><code>Cascade</code><ul>
<li>级联模式: 父表的操作, 对应子表关联的数据也跟着被删除</li>
</ul>
</li>
<li><code>Set null</code><ul>
<li>置空模式: 父表的操作之后,子表对应的数据(外键字段)被置空</li>
</ul>
</li>
</ul>
</li>
<li><code>Foreign key(外键字段) references 父表(主键字段) on delete set null on update cascade</code><ul>
<li>通常合理的做法（约束模式）<ul>
<li>删除的时候子表置空<ul>
<li>前提条件: 外键字段允许为空(如果不满足条件,外键无法创建)</li>
</ul>
</li>
<li>更新的时候子表级联操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="新增外键"><a href="#新增外键" class="headerlink" title="新增外键"></a>新增外键</h4><ol>
<li>建表时，在所有字段之后<ul>
<li><code>foreign key(外键字段) references 外部表(主键字段)</code></li>
</ul>
</li>
<li>建表后，追加外键<ul>
<li><code>Alter table 表名 add [constraint 外键名字] foreign key(外键字段) references 父表(主键字段)</code></li>
</ul>
</li>
</ol>
<h4 id="修改-amp-删除外键"><a href="#修改-amp-删除外键" class="headerlink" title="修改 &amp; 删除外键"></a>修改 &amp; 删除外键</h4><ul>
<li>外键不可修改: 只能先删除后新增.</li>
<li>删除<ul>
<li><code>Alter table 表名 drop foreign key 外键名</code> </li>
</ul>
</li>
</ul>
<h4 id="外键作用"><a href="#外键作用" class="headerlink" title="外键作用"></a>外键作用</h4><ul>
<li>对子表约束<ul>
<li>子表数据进行写操作(增和改)的时候, 如果对应的外键字段在父表找不到对应的匹配: 那么操作会失败.(约束子表数据操作)</li>
</ul>
</li>
<li>对父表约束<ul>
<li>父表数据进行写操作(删和改: 都必须涉及到主键本身), 如果对应的主键在子表中已经被数据所引用, 那么就不允许操作</li>
<li>即先删除外键所在数据，才能删除主键数据</li>
</ul>
</li>
</ul>
<h4 id="外键条件"><a href="#外键条件" class="headerlink" title="外键条件"></a>外键条件</h4><ol>
<li>外键要存在，首先必须保证表的存储引擎是innodb(默认的存储引擎)<ul>
<li>如果不是innodb存储引擎,那么外键可以创建成功,但是没有约束效果</li>
</ul>
</li>
<li>外键字段的字段类型(列类型)必须与父表的主键类型完全一致</li>
<li>一张表中的外键名字不能重复.</li>
<li>增加外键的字段(数据已经存在),必须保证数据与父表主键要求对应</li>
</ol>
<h3 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h3><ul>
<li><code>auto_increment</code></li>
<li>当对应的字段,不给值,或者说给默认值,或者给NULL的时候, 会自动的被系统触发, 系统会从当前字段中已有的最大值再进行+1操作</li>
<li>自增长通常搭配主键</li>
</ul>
<h4 id="新增自增长"><a href="#新增自增长" class="headerlink" title="新增自增长"></a>新增自增长</h4><ol>
<li>任何一个字段要做自增长必须前提是本身是一个索引(key一栏有值)</li>
<li>自增长字段必须是数字(整型)</li>
<li>3.一张表最多只能有一个自增长</li>
</ol>
<h4 id="自增长使用"><a href="#自增长使用" class="headerlink" title="自增长使用"></a>自增长使用</h4><ul>
<li>当自增长被给定的值为NULL或者默认值的时候会触发自动增长</li>
<li>自增长如果对应的字段输入了值,那么自增长失效: 但是下一次还是能够正确的自增长(从最大值+1)</li>
<li>可以通过查看表创建语句查看下一次自增长的值</li>
</ul>
<h4 id="修改自增长"><a href="#修改自增长" class="headerlink" title="修改自增长"></a>修改自增长</h4><ul>
<li>如果涉及到字段改变<ul>
<li>必须先删除自增长,后增加</li>
</ul>
</li>
<li>修改当前自增长已经存在的值<ul>
<li><code>alter table 表名 auto_increment = 值</code></li>
<li>只能比当前已有的自增长的最大值大,不能小(小不生效)</li>
</ul>
</li>
</ul>
<h4 id="删除自增长"><a href="#删除自增长" class="headerlink" title="删除自增长"></a>删除自增长</h4><ul>
<li><code>alter table 表名 modify 字段名 数据类型</code><ul>
<li>自增长是字段的一个属性: 可以通过modify来进行修改，只要保证字段没有auto_increment即可</li>
</ul>
</li>
</ul>
<h4 id="自增长初始值-amp-种子"><a href="#自增长初始值-amp-种子" class="headerlink" title="自增长初始值 &amp; 种子"></a>自增长初始值 &amp; 种子</h4><ul>
<li><code>show variables like ‘auto_increment%’</code><ul>
<li>查看自增长对应变量</li>
<li>初始值<ul>
<li><code>auto_increment_increment</code></li>
</ul>
</li>
<li>种子<ul>
<li><code>auto_increment_offset</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h3><ul>
<li><code>unique key</code></li>
</ul>
<h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><ul>
<li>唯一，可以为null，且可以有多个null(null不参与唯一性比较)</li>
</ul>
<h4 id="新增唯一键"><a href="#新增唯一键" class="headerlink" title="新增唯一键"></a>新增唯一键</h4><ol>
<li>建表时，字段后跟unique key<ul>
<li><code>字段名 数据类型 unique/unique key</code></li>
</ul>
</li>
<li>建表时，在所有字段后增加<code>unique key(字段列表)</code></li>
<li>建表之后，追加唯一键<ul>
<li><code>alter table 表名 add unique key(字段列表)</code></li>
</ul>
</li>
</ol>
<h4 id="删除唯一键"><a href="#删除唯一键" class="headerlink" title="删除唯一键"></a>删除唯一键</h4><ul>
<li><code>alter table 表名 drop index 索引名字</code><ul>
<li>唯一键默认的使用字段名作为索引名字</li>
</ul>
</li>
</ul>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul>
<li><code>alter table 表名 add constraint 约束名 约束类型 约束说明</code><ul>
<li>约束名命名规则<ul>
<li>约束类型_约束列</li>
<li>主键(primary key) <ul>
<li>pk_uId</li>
</ul>
</li>
<li>唯一(unique) <ul>
<li>uq_uId</li>
</ul>
</li>
<li>默认(default key)<ul>
<li>dk_uId</li>
</ul>
</li>
<li>检查(check key)<ul>
<li>ck_uId</li>
</ul>
</li>
<li>外键(foreign key)<ul>
<li>fk_uid </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>alter table 表名 drop constraint 约束名</code></li>
</ul>
<h2 id="主键约束-1"><a href="#主键约束-1" class="headerlink" title="主键约束"></a>主键约束</h2><ul>
<li><code>alter table 表名 add constraint 主键约束名 primary key(字段列表);</code></li>
</ul>
<h2 id="外键约束-1"><a href="#外键约束-1" class="headerlink" title="外键约束"></a>外键约束</h2><ul>
<li><code>ALTER TABLE 表名 ADD FOREIGN KEY (字段名) REFERENCES 表名(字段名)</code></li>
</ul>
<h1 id="高级数据操作"><a href="#高级数据操作" class="headerlink" title="高级数据操作"></a>高级数据操作</h1><h2 id="增-3"><a href="#增-3" class="headerlink" title="增"></a>增</h2><h3 id="主键冲突"><a href="#主键冲突" class="headerlink" title="主键冲突"></a>主键冲突</h3><ul>
<li>在数据插入的时候, 假设主键对应的值已经存在: 插入一定会失败</li>
<li>当主键存在冲突的时候(Duplicate key)<ol>
<li>更新<ul>
<li><code>Insert into 表名[字段列表(包含主键)] values(值列表) on duplicate key update 字段 = 新值</code></li>
</ul>
</li>
<li>替换<ul>
<li><code>Replace into 表名 [字段列表(包含主键)] values(值列表)</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="蠕虫复制"><a href="#蠕虫复制" class="headerlink" title="蠕虫复制"></a>蠕虫复制</h3><ul>
<li>从已有的数据中去获取数据,然后将数据又进行新增操作: 数据成倍的增加</li>
<li>从已有表创建新表(复制表结构)<ul>
<li><code>create table 表名 like 数据库.表名</code></li>
</ul>
</li>
<li>蠕虫复制<ul>
<li>先查出数据, 然后将查出的数据新增一遍</li>
<li><code>insert into 表名[字段列表] select 字段类别/* from 数据表名</code></li>
</ul>
</li>
<li>蠕虫复制的意义<ol>
<li>从已有表拷贝数据到新表中</li>
<li>可以迅速的让表中的数据膨胀到一定的数量级: 测试表的压力以及效率</li>
</ol>
</li>
</ul>
<h2 id="删-3"><a href="#删-3" class="headerlink" title="删"></a>删</h2><ul>
<li><code>Delete from 表名 [where条件] [limit 数量]</code></li>
</ul>
<h2 id="改-3"><a href="#改-3" class="headerlink" title="改"></a>改</h2><ul>
<li><code>Update 表名 set 字段 = 值 [where条件] [limit 更新数量]</code></li>
</ul>
<h2 id="查-3"><a href="#查-3" class="headerlink" title="查"></a>查</h2><h3 id="查询完整语法"><a href="#查询完整语法" class="headerlink" title="查询完整语法"></a>查询完整语法</h3><ul>
<li><code>Select [select选项] 字段列表[字段别名]/* from 数据源 [where条件子句] [group by子句] [having子句] [order by子句] [limit 子句]</code><ol>
<li>where从表中查询出符合条件的数据形成一个概念中的临时结果集，存入内存</li>
<li>列之间的运算(select子句中)及分组(group by)统计进行完毕，临时结果形成结果集。</li>
<li>having对结果集进行筛选。</li>
<li>order by对筛选后的结果集进行排序。</li>
<li>limit对排序后的结果集进行条目限制，形成最终结果集。</li>
</ol>
<ul>
<li>问题<ul>
<li>1<code>select id (salary*12) as 年薪 from persons where (salary*12)&gt;100</code></li>
<li>2<code>select id (salary*12) as 年薪 from persons where 年薪&gt;100</code></li>
<li>2是错误的。因为where是对表中的数据发挥作用，查询出数据来。发挥完作用形成的结果中才有列’年薪’,在where中直接使用列’年薪’时，显然表中并没有这个列。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="select选项"><a href="#select选项" class="headerlink" title="select选项"></a>select选项</h3><ul>
<li>select对查出来的结果的处理方式<ul>
<li><code>all</code><ul>
<li>默认，保留所有结果</li>
</ul>
</li>
<li><code>distinct</code><ul>
<li>去重, 查出来的结果,将重复给去除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字段别名"><a href="#字段别名" class="headerlink" title="字段别名"></a>字段别名</h3><ul>
<li><code>字段名 [as] 别名</code></li>
</ul>
<h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><ul>
<li>本质上只要保证数据类似二维表,最终都可以作为数据源</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>单表数据源<ul>
<li><code>select * from 表名</code></li>
</ul>
</li>
<li>多表数据源<ul>
<li><code>select * from 表1,表2...</code><ul>
<li>笛卡儿积</li>
</ul>
</li>
</ul>
</li>
<li>查询语句<ul>
<li><code>select * from (select语句) as 表名</code><ul>
<li>子查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h3><ul>
<li><code>&gt;</code> <code>&lt;</code> <code>=</code>  <code>!=</code>  <code>&lt;&gt;</code>  <code>&lt;=</code>  <code>&gt;=</code></li>
<li><code>and(&amp;&amp;)</code> <code>or(||)</code> <code>not(!)</code></li>
<li><code>between and</code></li>
<li><code>in()</code></li>
<li><code>any()</code><ul>
<li>代表括号中任意一个即可，同<code>in()</code></li>
</ul>
</li>
<li><code>all()</code><ul>
<li>代表括号中的所有</li>
</ul>
</li>
<li><code>is null</code> <code>is not null</code></li>
<li><code>like</code><ul>
<li><code>%</code><ul>
<li>代表任意字符。</li>
</ul>
</li>
<li><code>_</code><ul>
<li>代表一个任意字符。</li>
</ul>
</li>
</ul>
</li>
<li>where原理<ul>
<li>where是唯一一个直接从磁盘获取数据的时候就开始判断的条件: 从磁盘取出一条记录, 开始进行where判断: 判断的结果如果成立保存到内存;如果失败直接放弃</li>
<li>where保证进入内存的数据都是有效的</li>
<li>where子句中只能用表中有的列，且不能使用别名</li>
</ul>
</li>
</ul>
<h3 id="group-by子句"><a href="#group-by子句" class="headerlink" title="group by子句"></a>group by子句</h3><ul>
<li>通常结合聚合函数使用</li>
<li>分组会自动排序: 根据分组字段:默认升序<ul>
<li><code>Group by 字段 [asc|desc]</code><ul>
<li>对分组后的整个结果进行排序</li>
</ul>
</li>
</ul>
</li>
<li>多字段分组<ul>
<li>先根据一个字段进行分组,然后对分组后的结果再次按照其他字段进行分组</li>
</ul>
</li>
<li>注意:<ul>
<li>select子句中出现的非聚合函数的列,必须出现在group by子句中。<ul>
<li>充分不必要</li>
<li>即select的列如果不是函数，那么必须是用来group by的列</li>
<li>而用来group by的列，不必非要select。</li>
<li>这是sql标准，mysql中违反也不报错，但强烈不推荐。</li>
</ul>
</li>
</ul>
</li>
<li><code>group_concat(字段)</code><ul>
<li>可以对分组的结果中的某个字段进行字符串连接(保留该组所有的此字段)</li>
<li>用在select中，比如按班级分组，<code>select class,group_concat(name)</code><ul>
<li>可以按照班级分组后，并查出每个班级的人的名字</li>
</ul>
</li>
</ul>
</li>
<li><code>with rollup</code><ul>
<li>回溯统计<ul>
<li>任何一个分组后都会有一个小组, 最后都需要向上级分组进行汇报统计</li>
</ul>
</li>
<li>我的认为就是在原有分组结果上对每一层的每一个分组都做一下统计<ul>
<li>按班级分组<ul>
<li>原结果是3班 3条记录</li>
<li>回溯结果<ul>
<li>班级向上层回溯，1条记录</li>
<li>原3+1=4条记录</li>
</ul>
</li>
</ul>
</li>
<li>按班级，性别分组<ul>
<li>原结果1班没男的，2班没女的，3班都有，4条记录</li>
<li>回溯结果<ul>
<li>性别那一层向上一层(班级)回溯，就会有3条记录，因为有3个班级</li>
<li>班级那一层向上层回溯，1条记录</li>
<li>原4+3+1=8条记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul>
<li><code>max()</code></li>
<li><code>min()</code></li>
<li><code>sum()</code></li>
<li><code>avg()</code></li>
<li><code>count()</code><ul>
<li>可以使用两种参数<ol>
<li><code>*</code><ul>
<li>代表统计记录，即使某行所有字段皆为null也统计</li>
<li>安（用数字，字母等代替也可以。。）<ul>
<li><code>count(1) count(0) count(x)</code><ul>
<li><code>count(1)</code>相当于数了总行数次1</li>
<li><code>count(0)</code>相当于数了总行数次0</li>
<li><code>count(x)</code>相当于数了总行数次x</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>字段名</code><ul>
<li>统计对应的字段，如果某行该字段为空，不会统计</li>
</ul>
</li>
</ol>
<ul>
<li><code>count(表达式)</code><ul>
<li>表达式没用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h3><ul>
<li>Where是针对磁盘数据进行判断: 进入到内存之后,会进行分组统计，列运算…就需要having来处理.</li>
<li>where只能用表中存在的字段名</li>
<li>having可以使用别名</li>
</ul>
<h3 id="order-by子句"><a href="#order-by子句" class="headerlink" title="order by子句"></a>order by子句</h3><ul>
<li>依赖校对集</li>
<li><code>asc</code><ul>
<li>升序，默认。</li>
</ul>
</li>
<li><code>desc</code><ul>
<li>降序</li>
</ul>
</li>
<li><code>order by 列1 asc,列2 desc...</code><ul>
<li>前一个条件排序结果相同才会按照下一个条件排序。</li>
</ul>
</li>
</ul>
<h3 id="limit子句"><a href="#limit子句" class="headerlink" title="limit子句"></a>limit子句</h3><ul>
<li><code>limit index length</code><ul>
<li>从index开始，取length条数据。</li>
<li>index<ul>
<li>起始索引，若省略相当于0。</li>
</ul>
</li>
<li>length<ul>
<li>条目数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ul>
<li>length<ul>
<li>每页数据量，基本不变</li>
</ul>
</li>
<li>index<ul>
<li>index=(页码-1)*length</li>
</ul>
</li>
</ul>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><ul>
<li><code>from 左表 cross join 右表</code> == <code>from 左表,右表</code></li>
</ul>
<h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li>从一张表中循环取出每一条记录, 每条记录都去另外一张表进行匹配: 匹配一定保留(没有条件匹配), 而连接本身字段就会增加(保留),最终形成的结果: 笛卡尔积.</li>
</ul>
<h4 id="笛卡儿积"><a href="#笛卡儿积" class="headerlink" title="笛卡儿积"></a>笛卡儿积</h4><ul>
<li>指数学中两个集合的笛卡儿积<ul>
<li>`集合A={a, b}，集合B={0, 1, 2}<ul>
<li>则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}`</li>
</ul>
</li>
<li>注意笛卡儿积是元素相组合，不是数学相乘。</li>
<li>集合A有m个元素，集合B有n个元素<ul>
<li>笛卡儿积总共<code>m*n</code>个元素。</li>
</ul>
</li>
</ul>
</li>
<li>数据库中的笛卡儿积<ul>
<li>表A中有m条数据，表B中有n条数据<ul>
<li><code>select * from 表A,表B;</code><ul>
<li><code>行=m*n</code></li>
<li><code>列=表A的列数+表B的列数</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><ul>
<li><code>from 左表 [inner] join 右表 on</code>  ==  <code>from 左表,右表 where</code></li>
</ul>
<h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ul>
<li>从左表中取出每一条记录,去右表中与所有的记录进行匹配: 匹配必须是某个条件在左表中与右表中相同最终才会保留结果,否则不保留</li>
<li>查出两表符合条件的数据。</li>
<li>内连接相当于左外连接与右外连接的交集。</li>
<li>内连接可以没有on条件，就相当于交叉连接会形成笛卡儿积，可以参考where形式没有where条件。</li>
</ul>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><ul>
<li>以某张表为主,取出里面的所有记录, 然后每条与另外一张表进行连接: 不管能不能匹配上条件,最终都会保留: 能匹配,正确保留; 不能匹配,其他表的字段都置空NULL.</li>
</ul>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><ul>
<li><code>左表 left join 右表 on</code><ul>
<li>以左表为主，无论条件是否成立，都会查出左表的数据。</li>
<li>条件成立，保留右表数据</li>
<li>条件不成立，右表字段置为null</li>
</ul>
</li>
</ul>
<h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><ul>
<li><code>左表 right join 右表 on</code></li>
</ul>
<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><ul>
<li>自然连接, 就是自动匹配连接条件: 系统以字段名字作为匹配模式(同名字段就作为条件, 多个同名字段都作为条件).</li>
</ul>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><ul>
<li>把自己看作两张表，自己连接自己</li>
</ul>
<h3 id="连接-例"><a href="#连接-例" class="headerlink" title="连接 例"></a>连接 例</h3><ul>
<li>表<strong>t1</strong></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
</tr>
</tbody>
</table>
<ul>
<li>表<strong>t2</strong></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>4</td>
<td>F</td>
</tr>
</tbody>
</table>
<h3 id="inner-join-on"><a href="#inner-join-on" class="headerlink" title="inner join on"></a>inner join on</h3><ul>
<li><code>select * from t1 inner join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>a</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
</tbody>
</table>
<h3 id="left-join-on"><a href="#left-join-on" class="headerlink" title="left join on"></a>left join on</h3><ul>
<li><code>select * from t1 left join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
</tbody>
</table>
<h3 id="right-join-on"><a href="#right-join-on" class="headerlink" title="right join on"></a>right join on</h3><ul>
<li><code>select * from t1 right join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody>
</table>
<h3 id="full-join-on-mysql不支持"><a href="#full-join-on-mysql不支持" class="headerlink" title="full join on(mysql不支持)"></a>full join on(mysql不支持)</h3><ul>
<li><code>select * from t1 full join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody>
</table>
<h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><ul>
<li>将多次查询(多条select语句), 在记录上进行拼接(字段不会增加)<ul>
<li>联合查询只要求字段一样, 跟数据类型无关</li>
</ul>
</li>
<li><code>select 语句1 union [union选项] select 语句2</code><ul>
<li>union选项<ul>
<li><code>distinct</code><ul>
<li>去除重复，默认</li>
</ul>
</li>
<li><code>all</code><ul>
<li>保留所有</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ol>
<li>查询同一张表,但是需求不同:<ul>
<li>如查询学生信息, 男生身高升序, 女生身高降序</li>
</ul>
</li>
<li>多表查询: 多张表的结构是完全一样的,保存的数据(结构)也是一样的</li>
</ol>
<h3 id="order-by-使用"><a href="#order-by-使用" class="headerlink" title="order by 使用"></a>order by 使用</h3><ul>
<li>在联合查询中: order by不能直接使用,需要对查询语句使用括号才行</li>
<li>若要orderby生效<ul>
<li>必须搭配limit: limit使用限定的最大数即可</li>
</ul>
</li>
<li>外层语句可能还要对最终结果集排序，所以内层的两个语句的排序没有意义，所以内层(sql1,sql2)的order by在执行期间会被MySQL的代码分析器给优化掉。<ul>
<li>如果内层语句排序（order by）之后还限制条目（limit）了，那么排序会影响结果集，此时的order by就会发挥作用。</li>
<li>总结：<ul>
<li>如果两个合并的sql语句中有排序（order by），如果排序会对两个sql的结果集产生影响(如limit)那么排序就会生效，否则，排序语句不会生效。</li>
<li>外层的order by针对的是最终结果集。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul>
<li>查询是在某个查询结果之上进行的.(一条select语句内部包含了另外一条select语句).</li>
</ul>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><h4 id="按位置"><a href="#按位置" class="headerlink" title="按位置"></a>按位置</h4><h5 id="From子查询"><a href="#From子查询" class="headerlink" title="From子查询"></a>From子查询</h5><ul>
<li><code>from (sql)</code><ul>
<li>将子查询结果集看作是一张表。</li>
</ul>
</li>
</ul>
<h5 id="Where子查询"><a href="#Where子查询" class="headerlink" title="Where子查询"></a>Where子查询</h5><ul>
<li><code>where 字段 = (sql)</code></li>
<li><code>where 字段 in (sql)</code></li>
<li><code>where (字段1,字段2) = (sql)</code></li>
</ul>
<h5 id="Exists子查询"><a href="#Exists子查询" class="headerlink" title="Exists子查询"></a>Exists子查询</h5><ul>
<li><code>where exists(sql)</code><ul>
<li>exists子查询就是用来判断某些条件是否满足(跨表), exists是接在where之后: exists返回的结果只有0和1</li>
<li>exists里的条件语句能够返回记录行时,条件就为真,select的查询就返回结果，否则，select的查询结果就舍弃。<ul>
<li>即如果sql有查询结果，则select查询有结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="按结果"><a href="#按结果" class="headerlink" title="按结果"></a>按结果</h4><h5 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h5><ul>
<li>子查询得到的结果是一行一列</li>
<li>出现的位置在where之后 where子查询</li>
<li>例<ul>
<li>学生表，班级表</li>
<li>根据班级名查询班级id，根据班级id查询学生信息</li>
<li><code>select * from student where cid = (select id from class where name = &#39;1ban&#39;)</code></li>
</ul>
</li>
</ul>
<h5 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h5><ul>
<li>子查询得到的结果是一列多行</li>
<li>出现的位置在where之后 where子查询</li>
<li>例<ul>
<li>查询所有在读的学生即所有班级的学生</li>
<li><code>select * from student where cid in (select id from class)</code></li>
</ul>
</li>
</ul>
<h5 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h5><ul>
<li>子查询得到的结果是多列一行(多行多列)</li>
<li>出现的位置在where之后 where子查询</li>
<li>例<ul>
<li>查询身高最高，年龄最大的学生信息</li>
<li><code>select * from student where age=(select max(age) from student) and height=(select max(height) from student)</code></li>
<li><code>select * from student where (age,height) = (select max(age),max(height) from student)</code></li>
</ul>
</li>
</ul>
<h5 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h5><ul>
<li>子查询得到的结果是多行多列</li>
<li>出现的位置是在from之后 from子查询</li>
</ul>
<h1 id="Mysql-字符集"><a href="#Mysql-字符集" class="headerlink" title="Mysql 字符集"></a>Mysql 字符集</h1><ul>
<li><code>show character set</code><ul>
<li>查看服务器支持的字符集</li>
</ul>
</li>
<li><code>show variables like &#39;character_set%&#39;</code><ul>
<li>查看服务器默认的对外处理的字符集</li>
<li><code>character_set_client</code></li>
<li><code>character_set_connection</code></li>
<li><code>character_set_database</code><ul>
<li>创建数据库的编码格式，没有指定就默认</li>
</ul>
</li>
<li><code>character_set_filesystem</code><ul>
<li>文件系统的编码格式，把操作系统上的文件名转化成此字符集，即把 <code>character_set_client</code>转换<code>character_set_filesystem</code>， 默认binary是不做任何转换的</li>
</ul>
</li>
<li><code>character_set_results</code></li>
<li><code>character_set_server</code></li>
<li><code>character_set_system</code><ul>
<li>数据库系统使用的编码格式，这个值一直是utf8，不需要设置，它是为存储系统元数据的编码格式</li>
</ul>
</li>
<li><code>character_sets_dir</code><ul>
<li>字符集安装的目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h2><ul>
<li><code>character_set_client</code><ul>
<li>客户端字符集（服务器认为的要存储的数据的字符集）</li>
</ul>
</li>
<li><code>character_set_connection</code><ul>
<li>连接器字符集</li>
</ul>
</li>
<li><code>character_set_server</code><ul>
<li>服务端字符集(存储到服务器的字符集)</li>
</ul>
</li>
<li><code>character_set_results</code><ul>
<li>服务器返回数据(查询结果)字符集</li>
</ul>
</li>
</ul>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><ul>
<li><code>set 变量 = 值</code><ul>
<li>修改只是会话级别(当前客户端,当次连接有效: 关闭失效)</li>
</ul>
</li>
<li><code>set names 值</code><ul>
<li>相当于同时设置</li>
<li><code>character_set_client</code></li>
<li><code>character_set_connection</code></li>
<li><code>character_set_results</code></li>
</ul>
</li>
</ul>
<h2 id="存"><a href="#存" class="headerlink" title="存"></a>存</h2><ul>
<li><code>数据字符集 ↔ character_set_client → character_set_connection → character_set_server</code><ul>
<li><code>数据</code>↔<code>客户端</code>→<code>连接器</code>→<code>服务端</code></li>
<li>存数据最终是按照服务端设置的编码存的</li>
<li>连接器的字符集不应太小，否则转换过程会损失数据。</li>
</ul>
</li>
<li>过程<ol>
<li>数据本身的字符集要与<code>character_set_client</code>一致<ul>
<li>因为服务器认为提交的数据是<code>character_set_client</code>的，如果不是就会出问题。</li>
</ul>
</li>
<li>把数据从<code>character_set_client</code>转为<code>character_set_connection</code><ul>
<li>若一致则不转换</li>
</ul>
</li>
<li>把数据从<code>character_set_connection</code>转为<code>character_set_server</code><ul>
<li>若一致则不转换</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="取"><a href="#取" class="headerlink" title="取"></a>取</h2><ul>
<li><code>character_set_server → character_set_connection → character_set_results ↔ character_set_client</code><ul>
<li><code>服务端</code>→<code>连接器</code>→<code>查询结果</code>↔<code>客户端</code></li>
<li>取数据最终是按照结果集的字符集返回给客户端。</li>
<li>保证结果集和客户端字符集一致即可。</li>
</ul>
</li>
<li>过程<ol>
<li>把数据从<code>character_set_server</code>转为<code>character_set_connection</code><ul>
<li>若一致则不转换</li>
</ul>
</li>
<li>把数据从<code>character_set_connection</code>转为<code>character_set_results</code><ul>
<li>若一致则不转换</li>
</ul>
</li>
<li>比较<code>character_set_results</code>和<code>character_set_client</code>的字符集<ul>
<li>不一致则乱码</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="Mysql校对集"><a href="#Mysql校对集" class="headerlink" title="Mysql校对集"></a>Mysql校对集</h1><ul>
<li>校对集<ul>
<li>数据比较的方式</li>
</ul>
</li>
<li>校对集依赖字符集<ul>
<li>例如<ul>
<li><code>default-character-set=utf8</code></li>
<li><code>default-collation=utf8_general_ci</code></li>
</ul>
</li>
</ul>
</li>
<li><code>show collation</code><ul>
<li>查看数据库支持的校对集</li>
</ul>
</li>
<li>只有当数据产生比较的时候,校对集才会生效<ul>
<li>如<code>order by</code></li>
</ul>
</li>
<li>必须在没有数据之前声明好校对集，如果有了数据再进行校对集修改，修改无效</li>
</ul>
<h2 id="校对集格式"><a href="#校对集格式" class="headerlink" title="校对集格式"></a>校对集格式</h2><ul>
<li><code>_bin</code><ul>
<li><code>binary</code></li>
<li>二进制比较, 取出二进制位,一位一位的比较, 区分大小写</li>
</ul>
</li>
<li><code>_cs</code><ul>
<li><code>case sensitive</code></li>
<li>大小写敏感, 即区分大小写</li>
</ul>
</li>
<li><code>_ci</code><ul>
<li><code>case insensitice</code></li>
<li>大小写不敏感,即不区分大小写</li>
</ul>
</li>
</ul>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li><code>Normal Format</code><ul>
<li>是一种离散数学中的知识, 是为了解决一种数据的存储与优化的问题: 保存数据的存储之后, 凡是能够通过关系寻找出来的数据,坚决不再重复存储: 终极目标是为了减少数据的冗余.</li>
</ul>
</li>
<li>范式是一种分层结构的规范, 分为六层: 每一次层都比上一层更加严格: 若要满足下一层范式,前提是满足上一层范式.<ul>
<li>1NF,2NF,3NF…6NF</li>
<li>1NF是最底层,要求最低;6NF最高层,最严格</li>
</ul>
</li>
</ul>
<h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h2><ul>
<li>第一范式: 在设计表存储数据的时候, 如果表中设计的字段存储的数据,在取出来使用之前还需要额外的处理(拆分),那么说表的设计不满足第一范式</li>
<li>第一范式要求字段的数据具有原子性: 不可再分</li>
<li>解决<ul>
<li>拆分字段</li>
</ul>
</li>
</ul>
<h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><ul>
<li>第二范式: 在数据表设计的过程中,如果有复合主键(多字段主键), 且表中有字段并不是由整个主键来确定, 而是依赖主键中的某个字段(主键的部分): 存在字段依赖主键的部分的问题, 称之为部分依赖:</li>
<li>第二范式就是要解决表设计不允许出现部分依赖</li>
<li>解决<ol>
<li>可以将复合主键字段单独成表</li>
<li>取消复合主键，使用逻辑主键 </li>
</ol>
</li>
</ul>
<h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><ul>
<li>第三范式: 理论上讲,应该一张表中的所有字段都应该直接依赖主键(逻辑主键: 代表的是业务主键), 如果表设计中存在一个字段, 并不直接依赖主键,而是通过某个非主键字段依赖,最终实现依赖主键: 把这种不是直接依赖主键,而是依赖非主键字段的依赖关系称之为传递依赖</li>
<li>第三范式就是要解决传递依赖的问题.</li>
<li>解决<ul>
<li>将存在传递依赖的字段,以及依赖的字段本身单独取出,形成一个单独的表, 然后在需要对应的信息的时候, 使用对应的实体表的主键加进来.</li>
</ul>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul>
<li>系统根据某种算法, 将已有的数据(未来可能新增的数据),单独建立一个文件: 文件能够实现快速的匹配数据, 并且能够快速的找到对应表中的记录</li>
<li>几乎所有的索引都是建立在字段之上</li>
<li>索引本身会产生索引文件(有时候有可能比数据文件还大) ,会非常耗费磁盘空间.<ul>
<li>就像字典前边的目录，会提高速度，但也会增加书的厚度</li>
<li>索引提高了查询速度，但降低了增删改的速度，并非越多越好</li>
</ul>
</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>提升查询数据的效率<ul>
<li>如果某个字段需要作为查询的条件经常使用，那么可以使用索引</li>
</ul>
</li>
<li>约束数据的有效性(唯一性等)<ul>
<li>如果某个字段需要进行数据的有效性约束, 也可能使用索引(主键,唯一键)</li>
</ul>
</li>
</ol>
<h2 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h2><ul>
<li><strong>key</strong><ul>
<li>普通索引</li>
<li><code>key 索引名(列名)</code></li>
</ul>
</li>
<li><strong>unique key</strong><ul>
<li>唯一索引</li>
<li><code>unique key 索引名(列名)</code></li>
</ul>
</li>
<li><strong>primary key</strong><ul>
<li>主键索引</li>
<li><code>primary key 索引名(列名)</code></li>
</ul>
</li>
<li><strong>funlltext</strong><ul>
<li>全文索引</li>
<li>中文环境下无效，要分词+索引，一般用第三方解决方案<ul>
<li>如<code>sphinx</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>索引长度</strong><ul>
<li>建索引时，可以只索引列的一部分内容，如前10个字符<ul>
<li><code>key 索引名(列名(10))</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>多列索引</strong><ul>
<li>就是把多个列的值，看成一个整体，然后建立索引<ul>
<li>如有两个列<code>xing</code>,<code>ming</code></li>
<li><code>key xm(xing,ming)</code><ul>
<li>查询时按照姓名查就会使用索引</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>冗佘索引</strong><ul>
<li>某个列上存在多个索引<ul>
<li>比如一个列有个索引，还有个多列索引。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><ul>
<li>查看表的索引<ul>
<li><code>show index from 表名</code></li>
</ul>
</li>
<li>添加普通和唯一索引<ul>
<li><code>alter table 表名 add index/unique 索引名(列名)</code></li>
</ul>
</li>
<li>添加主键索引<ul>
<li><code>alter table 表名 add primary key(列名)</code></li>
</ul>
</li>
<li>删除索引<ul>
<li><code>alter table 表名 drop index 索引名</code></li>
<li><code>drop index 索引名 on 表名</code></li>
</ul>
</li>
</ul>
<h1 id="视图view"><a href="#视图view" class="headerlink" title="视图view"></a>视图view</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul>
<li>view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。</li>
<li>视图中并没有真正存储数据。</li>
<li>表的改变会影响视图(视图就好像表的影子一样)</li>
<li>视图的改变也能影响表。(如果可以改变的话)</li>
<li>可以跟基本表一样，进行增删改查操作</li>
</ul>
<h2 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h2><ul>
<li>主要是用来查询</li>
<li>增删改操作有条件限制<ul>
<li>如果视图的数据与表的数据是一一对应出来的，改变不会影响其它数据，就可以增删改。</li>
<li>如果视图的数据是通过计算得来的，改变则会影响表中的其它数据，不可以增删改。</li>
</ul>
</li>
</ul>
<h2 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h2><ol>
<li>方便操作，特别是查询操作，减少复杂的SQL语句<ul>
<li>将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作</li>
</ul>
</li>
<li>数据安全<ul>
<li>视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全).</li>
<li>可以对外提供有用的数据, 但是隐藏关键(无用)的数据</li>
<li>数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别</li>
</ul>
</li>
<li>权限控制<ul>
<li>不希望用户访问表中某些含敏感信息的列,可以通过view开放某几个列</li>
</ul>
</li>
<li>数据过多时，分表用</li>
</ol>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><ul>
<li><code>create view 视图名 as select语句</code></li>
</ul>
<h2 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h2><ul>
<li><code>show create table/view 视图名</code></li>
<li><code>show tables [like]/desc 视图名</code><ul>
<li>视图是一张虚拟表，表的所有查看方式，视图都能用，且视图比表多一个关键字view</li>
</ul>
</li>
</ul>
<h2 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h2><ul>
<li>视图本身不可修改，但视图来源可以修改</li>
<li><code>alter view 视图名 as 新的select语句</code></li>
</ul>
<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><ul>
<li><code>drop view 视图名</code></li>
</ul>
<h2 id="视图算法-algorithm"><a href="#视图算法-algorithm" class="headerlink" title="视图算法(algorithm)"></a>视图算法(algorithm)</h2><ul>
<li>系统对视图以及外部查询视图的Select语句的一种解析方式</li>
<li><code>create algorithm=xxx view 视图名 as select 语句</code><ul>
<li>是对标准sql的mysql的扩展</li>
</ul>
</li>
</ul>
<h3 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h3><ul>
<li><code>undefined</code><ul>
<li>未定义(默认的), 这不是一种实际使用算法, 是一种推卸责任的算法: 告诉系统,视图没有定义算法, 系统自己看着办<ul>
<li>未定义由系统定义，它倾向于MERGE而不是TEMPTABLE</li>
<li>因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。</li>
</ul>
</li>
</ul>
</li>
<li><code>temptable</code><ul>
<li>临时表算法: 系统应该先执行视图的select语句,后执行外部查询语句<ul>
<li>视图的结果将被置于临时表中，然后使用它执行语句</li>
<li>适合复杂查询形成的view</li>
</ul>
</li>
</ul>
</li>
<li><code>merge</code><ul>
<li>合并算法: 系统应该先将视图对应的select语句与外部查询视图的select语句进行合并,然后执行(效率高: 常态)<ul>
<li>将查询视图的语句与视图定义语句合并起来<ul>
<li>查询视图的语句+视图定义语句=查询物理表的语句</li>
</ul>
</li>
<li>合并查询语句，不会创建临时表</li>
<li>适合简单查询形成的view</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算法选择"><a href="#算法选择" class="headerlink" title="算法选择"></a>算法选择</h3><ul>
<li>如果视图的select语句中会包含一个查询子句(五子句), 而且很有可能顺序比外部的查询语句要靠后, 一定要使用算法temptable,其他情况可以不用指定(默认即可)</li>
</ul>
<h1 id="存储引擎engine"><a href="#存储引擎engine" class="headerlink" title="存储引擎engine"></a>存储引擎engine</h1><ul>
<li>MySQL进行存储数据的方式。</li>
</ul>
<h2 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h2><h3 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h3><ul>
<li>只有表结构,数据全部存储到ibdata1文件中</li>
<li>支持事务(新版MySQL默认)</li>
</ul>
<h3 id="myisam"><a href="#myisam" class="headerlink" title="myisam"></a>myisam</h3><ul>
<li>速度快，不支持事务，安全性不够</li>
<li>表,数据和索引全部单独分开存储<ul>
<li><code>.frm</code>是结构</li>
<li><code>.myd</code>是数据</li>
<li><code>.myi</code>是索引</li>
</ul>
</li>
</ul>
<h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><ul>
<li>数据存在内存中，不存在磁盘，一关闭服务器就消失。适合临时数据。</li>
</ul>
<h1 id="数据备份-amp-还原"><a href="#数据备份-amp-还原" class="headerlink" title="数据备份&amp;还原"></a>数据备份&amp;还原</h1><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><h3 id="数据表备份"><a href="#数据表备份" class="headerlink" title="数据表备份"></a>数据表备份</h3><ul>
<li>不需要通过SQL来备份: 直接进入到数据库文件夹复制对应的表结构以及数据文件, 以后还原的时候,直接将备份的内容放进去即可</li>
<li>根据不同的存储引擎有不同的区别.<ul>
<li><code>myisam</code><ul>
<li>直接拷贝三个文件即可使用</li>
</ul>
</li>
<li><code>innodb</code><ul>
<li>也能拷贝，但不能使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="单表数据备份"><a href="#单表数据备份" class="headerlink" title="单表数据备份"></a>单表数据备份</h3><ul>
<li>每次只能备份一张表; 只能备份数据(表结构不能备份)</li>
<li>通常的使用<ul>
<li>将表中的数据进行导出到文件</li>
</ul>
</li>
</ul>
<h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><ul>
<li>前提：文件不存在</li>
<li><code>Select */字段列表 into outfile 文件所在路径 from 数据源</code></li>
<li><code>Select */字段列表 into outfile 文件所在路径 fields 字段处理 lines 行处理 from 数据源</code><ul>
<li>自己制定字段和行的处理方式</li>
<li><code>fields 字段处理</code><ul>
<li><code>Enclosed by</code><ul>
<li>字段使用什么内容包裹, 默认是<code>&quot;&quot;</code>空字符串</li>
</ul>
</li>
<li><code>Terminated by</code><ul>
<li>字段以什么结束, 默认是<code>\t</code>, tab键</li>
</ul>
</li>
<li><code>Escaped by</code><ul>
<li>特殊符号用什么方式处理,默认是<code>\</code> 使用反斜杠转义</li>
</ul>
</li>
</ul>
</li>
<li><code>lines 行处理</code><ul>
<li><code>Starting by</code><ul>
<li>每行以什么开始, 默认是<code>&quot;&quot;</code>空字符串</li>
</ul>
</li>
<li><code>erminated by</code><ul>
<li>每行以什么结束,默认是<code>\r\n</code>,换行符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h4><ul>
<li>将一个在外部保存的数据重新恢复到表中(表结构不存在，失败)</li>
<li><code>Load data infile 文件所在路径 into table 表名[(字段列表)] fields字段处理 lines 行处理</code></li>
</ul>
<h3 id="SQL备份"><a href="#SQL备份" class="headerlink" title="SQL备份"></a>SQL备份</h3><ul>
<li>备份的是SQL语句: 系统会对表结构以及数据进行处理,变成对应的SQL语句, 然后进行备份: 还原的时候只要执行SQL指令即可.(主要就是针对表结构)</li>
</ul>
<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><ul>
<li>不是针对数据或者SQL指令进行备份: 是针对mysql服务器的日志文件进行备份</li>
<li>指定时间段开始进行备份., 备份数据不会重复, 而且所有的操作都会备份(大项目都用增量备份)</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><ul>
<li>系统定义好的变量: 大部分的时候用户根本不需要使用系统变量: 系统变量是用来控制服务器的表现的<ul>
<li>如<code>autocommit auto_increment_increment...</code></li>
</ul>
</li>
</ul>
<h3 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h3><ul>
<li><code>Show variables</code><ul>
<li>查看所有变量</li>
</ul>
</li>
<li><code>Select @@变量名</code><ul>
<li>查看具体变量</li>
</ul>
</li>
</ul>
<h3 id="修改系统变量"><a href="#修改系统变量" class="headerlink" title="修改系统变量"></a>修改系统变量</h3><ul>
<li><code>et 变量名 = 值</code>  / <code>Set @@变量名 = 值</code><ul>
<li>会话级别</li>
</ul>
</li>
<li><code>Set global 变量名 = 值</code><ul>
<li>永久生效</li>
</ul>
</li>
</ul>
<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><ul>
<li>为了区分系统变量, 规定用户自定义变量必须使用一个<code>@</code>符号</li>
<li>所有自定义的变量都是会话级别</li>
<li>所有自定义变量不区分数据库(用户级别)</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>Mysql中的作用域与js中的作用域完全一样<ul>
<li>全局变量可以在任何地方使用</li>
<li>局部变量只能在函数内部使用</li>
</ul>
</li>
<li>全局变量<ul>
<li>使用set关键字定义, 使用@符号标志</li>
</ul>
</li>
<li>局部变量<ul>
<li>使用declare关键字声明, 没有@符号: 所有的局部变量的声明,必须在函数体开始之前</li>
</ul>
</li>
</ul>
<h3 id="定义自定义变量"><a href="#定义自定义变量" class="headerlink" title="定义自定义变量"></a>定义自定义变量</h3><ul>
<li><code>Set @变量名 = 值</code></li>
</ul>
<h3 id="查看自定义变量"><a href="#查看自定义变量" class="headerlink" title="查看自定义变量"></a>查看自定义变量</h3><ul>
<li><code>select @变量名</code></li>
</ul>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><ul>
<li><code>:=</code><ul>
<li>在mysql中, <code>=</code>会默认的当做比较符号处理(很多地方), mysql为了区分比较和赋值的概念: 重新定义了一个新的的赋值符号</li>
</ul>
</li>
</ul>
<ol>
<li><code>Select @变量名 := 字段名 from 数据源</code><ul>
<li>一边查看结果一边赋值，如果用<code>=</code>会变成比较</li>
</ul>
</li>
<li><code>Select 字段列表 from 表名 into 变量列表</code><ul>
<li>要求: 数据记录最多只允许获取一条: mysql不支持数组<ul>
<li><code>select name,age from user into @name,@age</code><ul>
<li>错误</li>
</ul>
</li>
<li><code>select name,age from user where id=1 into @name,@age</code><ul>
<li>正确，只获取一条数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="触发器Trigger"><a href="#触发器Trigger" class="headerlink" title="触发器Trigger"></a>触发器Trigger</h1><ul>
<li>事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候(增删改)系统会自动触发代码,执行</li>
</ul>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><ul>
<li>一张表中只能拥有一种触发时间的一种类型的触发器<ul>
<li>一张表最多能有6个触发器<ul>
<li>增删改/前后 6种组合</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><ul>
<li>增(insert)</li>
<li>删(delete)</li>
<li>改(update)</li>
</ul>
<h3 id="触发时间"><a href="#触发时间" class="headerlink" title="触发时间"></a>触发时间</h3><ul>
<li>前(before)</li>
<li>后(after)</li>
</ul>
<h3 id="触发对象"><a href="#触发对象" class="headerlink" title="触发对象"></a>触发对象</h3><ul>
<li>表中的每一条记录(行)</li>
</ul>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><ul>
<li>在mysql高级结构中: 没有大括号,  都是用对应的字符符号代替</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 临时修改语句结束符</span><br><span class="line">Delimiter 自定义符号: 后续代码中只有碰到自定义符号才算结束</span><br><span class="line"></span><br><span class="line">Create trigger 触发器名字 触发时间 事件类型 on 表名 for each row</span><br><span class="line"></span><br><span class="line">Begin		-- 代表左大括号: 开始</span><br><span class="line">-- 里面就是触发器的内容: 每行内容都必须使用语句结束符: 分号</span><br><span class="line">End			-- 代表右带括号: 结束</span><br><span class="line"></span><br><span class="line">-- 语句结束符</span><br><span class="line">自定义符号</span><br><span class="line"></span><br><span class="line">-- 将临时修改修正过来</span><br><span class="line">Delimiter  ;</span><br></pre></td></tr></table></figure>
<h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><ul>
<li><code>Information_schema.triggers</code><ul>
<li>所有的触发器都会保存这一张表中</li>
</ul>
</li>
<li><code>Show triggers [like ‘pattern’]</code><ul>
<li>查看所有或者模糊匹配</li>
</ul>
</li>
<li><code>Show create trigger 触发器名</code><ul>
<li>查看触发器创建语句</li>
</ul>
</li>
</ul>
<h2 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h2><ul>
<li>不需要手动调用, 而是当某种情况发生时会自动触发.</li>
</ul>
<h2 id="修改-amp-删除触发器"><a href="#修改-amp-删除触发器" class="headerlink" title="修改&amp;删除触发器"></a>修改&amp;删除触发器</h2><ul>
<li>触发器不能修改</li>
<li><code>Drop trigger 触发器名</code><ul>
<li>删除</li>
</ul>
</li>
</ul>
<h2 id="代码执行结构"><a href="#代码执行结构" class="headerlink" title="代码执行结构"></a>代码执行结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">If  条件判断  then</span><br><span class="line">	-- 满足条件要执行的代码;</span><br><span class="line">Else</span><br><span class="line">	-- 不满足条件要执行的代码;</span><br><span class="line">End if;</span><br></pre></td></tr></table></figure>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">While 条件判断 do</span><br><span class="line">	-- 满足条件要执行的代码</span><br><span class="line">	-- 变更循环条件</span><br><span class="line">End while;</span><br></pre></td></tr></table></figure>
<ul>
<li>Mysql中没有对应continue和break. 但是有替代品.<ul>
<li>Iterate: 迭代 , 类似continue, 后面的代码不执行, 循环重新来过</li>
<li>Leave: 离开, 类似break,整个循环接收</li>
<li>使用<ul>
<li><code>itrate/leave 循环名字</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环名字:While 条件判断 do</span><br><span class="line">	-- 满足条件要执行的代码</span><br><span class="line">	-- 变更循环条件</span><br><span class="line">	itrate/leave 循环名字;</span><br><span class="line">End while;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul>
<li>系统定义好的函数, 直接调用即可</li>
<li>任何函数都有返回值, 因此函数的调用是通过select调用</li>
</ul>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul>
<li><code>abs(x)</code><ul>
<li>绝对值</li>
</ul>
</li>
<li><code>bin(x)</code> <ul>
<li>二进制</li>
</ul>
</li>
<li><code>floor(x)</code><ul>
<li>返回小于x的最大整数</li>
</ul>
</li>
</ul>
<h3 id="聚合函数-1"><a href="#聚合函数-1" class="headerlink" title="聚合函数"></a>聚合函数</h3><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li><code>substring(s,index,length)</code><ul>
<li>截取字符串，以字符为单位</li>
</ul>
</li>
<li><code>instr(s,key)</code><ul>
<li>判断字符串s中是否存在字符串key，返回位置</li>
</ul>
</li>
<li><code>insert(s,index,length,key)</code><ul>
<li>替换</li>
</ul>
</li>
<li><code>strcmp(s1,s2)</code><ul>
<li>字符串比较</li>
</ul>
</li>
</ul>
<h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h3><ul>
<li><code>now()</code><ul>
<li>返回当前时间。(yyyy-MM–dd HH:mm:ss)</li>
</ul>
</li>
<li><code>curdate() current_date()</code><ul>
<li>返回日期(yyyy-MM-dd)</li>
</ul>
</li>
<li><code>curtime() current_time()</code><ul>
<li>返回时间(HH:mm:ss)</li>
</ul>
</li>
<li><code>dayofweek(date)</code><ul>
<li>一周的第几天(周日是第一天)</li>
</ul>
</li>
<li><code>dayofmonth(date)</code></li>
<li><code>dayofyear(date)</code></li>
</ul>
<h3 id="条件判断函数"><a href="#条件判断函数" class="headerlink" title="条件判断函数"></a>条件判断函数</h3><ul>
<li><code>if(expr,v1,v2)</code><ul>
<li>如果表达式expr成立，返回结果v1；否则，返回结果v2</li>
</ul>
</li>
<li><code>ifnull(v1,v2)</code><ul>
<li>如果v1的值不为NULL，则返回v1，否则返回v2。</li>
</ul>
</li>
<li><p><code>case</code></p>
<ul>
<li><p><code>case when e1 then v1 when e2 then e2 ... else vn end</code></p>
<ul>
<li>CASE表示函数开始，END表示函数结束。如果e1成立，则返回v1,如果e2成立，则返回v2，当全部不成立则返回vn，而当有一个成立之后，后面的就不执行了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">　　WHEN e1</span><br><span class="line">　　THEN v1</span><br><span class="line">　　WHEN e2</span><br><span class="line">　　THEN e2</span><br><span class="line">　　...</span><br><span class="line">　　ELSE vn</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>case expr when e1 then v1 when e2 then v2...else vn end</code></p>
<ul>
<li>如果表达式expr的值等于e1，返回v1；如果等于e2,则返回e2。否则返回vn。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE expr </span><br><span class="line">　　WHEN e1 THEN v1</span><br><span class="line">　　WHEN e2 THEN v2</span><br><span class="line">　　...</span><br><span class="line">　　ELSE vn</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h3><ul>
<li><code>USER()</code><ul>
<li>返回当前用户及所在主机</li>
</ul>
</li>
<li><code>database()</code><ul>
<li>返回当前数据库名</li>
</ul>
</li>
<li><code>version()</code><ul>
<li>返回数据库的版本号</li>
</ul>
</li>
</ul>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Create function  函数名([形参列表]) returns 数据类型 -- 规定要返回的数据类型</span><br><span class="line">Begin</span><br><span class="line">	-- 函数体</span><br><span class="line">	-- 返回值: return 类型(指定数据类型);</span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><ul>
<li>自定义函数与系统函数的调用方式是一样:</li>
<li><code>select 函数名(实参列表)</code></li>
</ul>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ul>
<li><code>show function status [like ‘pattern’]</code><ul>
<li>查看所有函数或模糊匹配</li>
</ul>
</li>
<li><code>show create function 函数名</code><ul>
<li>查看函数的创建语句</li>
</ul>
</li>
</ul>
<h3 id="修改-amp-删除函数"><a href="#修改-amp-删除函数" class="headerlink" title="修改&amp;删除函数"></a>修改&amp;删除函数</h3><ul>
<li>函数不能修改</li>
<li><code>Drop function 函数名</code><ul>
<li>删除</li>
</ul>
</li>
</ul>
<h3 id="参数-amp-变量作用域"><a href="#参数-amp-变量作用域" class="headerlink" title="参数&amp;变量作用域"></a>参数&amp;变量作用域</h3><ul>
<li>在函数内部使用@定义的变量在函数外部也可以访问</li>
</ul>
<h1 id="存储过程procedure"><a href="#存储过程procedure" class="headerlink" title="存储过程procedure"></a>存储过程procedure</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ul>
<li>是一种用来处理数据的方式.</li>
<li>存储过程是一种没有返回值的函数</li>
</ul>
<h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Create procedure 过程名字([参数列表])</span><br><span class="line">Begin</span><br><span class="line">	-- 过程体</span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<h2 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h2><ul>
<li><code>show procedure status [like ‘pattern’]</code><ul>
<li>查看所有存储过程或模糊匹配</li>
</ul>
</li>
<li><code>show create procedure 过程名</code><ul>
<li>查看过程创建语句:</li>
</ul>
</li>
</ul>
<h2 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h2><ul>
<li>过程没有返回值: select是不能访问的.</li>
<li><code>call 存储过程名(参数)</code></li>
</ul>
<h2 id="修改-amp-删除"><a href="#修改-amp-删除" class="headerlink" title="修改&amp;删除"></a>修改&amp;删除</h2><ul>
<li>不可修改</li>
<li><code>drop procedure 过程名</code><ul>
<li>删除</li>
</ul>
</li>
</ul>
<h2 id="存储过程参数"><a href="#存储过程参数" class="headerlink" title="存储过程参数"></a>存储过程参数</h2><ul>
<li>函数的参数需要数据类型指定, 过程比函数更严格</li>
<li>过程还有自己的类型限定</li>
<li><code>Create procedure 过程名(in 形参名字 数据类型, out 形参名字 数据类型, inout 形参名字 数据类型)</code></li>
</ul>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><ul>
<li>数据只是从外部传入给内部使用(值传递): 可以是数值也可以是变量</li>
</ul>
<h3 id="out"><a href="#out" class="headerlink" title="out"></a>out</h3><ul>
<li>只允许过程内部使用(不用外部数据), 给外部使用的.(引用传递: 外部的数据会被先清空才会进入到内部)</li>
<li>只能传变量</li>
</ul>
<h3 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h3><ul>
<li>外部可以在内部使用,内部修改也可以给外部使用: 典型的引用传递</li>
<li>只能传变量</li>
</ul>
<h1 id="Myql数据库驱动"><a href="#Myql数据库驱动" class="headerlink" title="Myql数据库驱动"></a>Myql数据库驱动</h1><ul>
<li><code>mysql-connector-java-5x</code><ul>
<li><code>driverClass=com.mysql.jdbc.Driver</code></li>
<li><code>url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</code></li>
<li><code>username=root</code></li>
<li><code>password=root</code></li>
</ul>
</li>
<li><code>mysql-connector-java-6x</code><ul>
<li><code>driverClass=com.mysql.cj.jdbc.Driver</code></li>
<li><code>url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</code><ul>
<li>如果参数不是‘？’后的第一个<ul>
<li>会提示<code>The reference to entity “serverTimezone” must end with the ‘;’ delimiter</code></li>
<li>对实体xxx引用必须以 ‘;’ 分隔符结尾</li>
</ul>
</li>
<li>将<code>&amp;</code>改为<code>&amp;amp;</code></li>
</ul>
</li>
<li><code>username=root</code></li>
<li><code>password=root</code></li>
</ul>
</li>
<li><strong>5x和6x的区别</strong><ul>
<li>6x driver发生了变化</li>
<li>6x需要设置时区<code>serverTimezone</code><ul>
<li>UTC<ul>
<li>协调世界时，又称世界统一时间、世界标准时间、国际协调时间</li>
</ul>
</li>
</ul>
</li>
<li>综合分析<ul>
<li>5.1.X的确存在一些问题，只是我们没有开发用于多时区的应用，或者已经习以为常认为合理罢了，甚至总结出了用BigInt存储跨时区的信息那种经验。</li>
<li>6.X彻底解决了跨时区的应用问题，让我们开发中顾虑更少。</li>
</ul>
</li>
<li>建议<ul>
<li>数据库服务器的时间设置<ul>
<li>对于纯产生数据的应用，没有数据回流到数仓的话，数据库时区随意设置，知道机制就可以了</li>
<li>对于需要数据回流到数仓，或者数仓的数据会回流到前台应用数据库的话，那么需要设置成和数仓的时区一致，避免两个库之间同步时发生时区异常的问题</li>
</ul>
</li>
<li>应用<ul>
<li>老应用用5.1.X，如果没有useTimezone的参数，那么谨慎升级Driver到6.X，如果要升级，记得做好测试，先修改数据库的TimeZone，然后升级Driver</li>
<li>新的应用建议使用6.X的Driver，但必须事先调整数据库服务器时区，做好测试，避免一开始数据库时区有问题，造成脏数据或数据不一致现象</li>
</ul>
</li>
</ul>
</li>
<li>查询mysql时区<ul>
<li><code>select timediff(now(),convert_tz(now(),@@session.time_zone,&#39;+00:00&#39;));</code></li>
<li><code>SELECT TIMEDIFF(NOW(), UTC_TIMESTAMP);</code></li>
<li>两个都可以，如果是中国标准时间，会输出08:00</li>
</ul>
</li>
</ul>
</li>
<li><strong>安</strong><ul>
<li>当查询返回了一个空的结果集ResultSet<ul>
<li>注：<ul>
<li><code>rs=ps.executeQuery()</code>这个方法不会返回null</li>
<li>所以rs不可能为空，而是数据为空<br>*使用5x时</li>
</ul>
</li>
<li><code>rs.next()</code>返回false</li>
</ul>
</li>
<li>使用6x时<ul>
<li><code>rs.next()</code>返回true</li>
</ul>
</li>
<li>这是我在写一个登录时发现的，明明账号密码错误查询的结果集是空的，可是使用6x，<code>rs.next()</code>返回true这样就给user的各个属性赋了默认值，返回了一个各个属性都是默认的0，null。。。的user对象。 </li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/xd-JNDI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/21/xd-JNDI/" itemprop="url">
                  xd-JNDI
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-21 14:00:02" itemprop="dateCreated datePublished" datetime="2019-01-21T14:00:02+08:00">2019-01-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:42:02" itemprop="dateModified" datetime="2019-03-08T14:42:02+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>Java Naming and Directory Interface</code></li>
<li>Java命名和目录接口</li>
<li>是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="https://gitee.com/3noanswer/pics/raw/master/JNDI原理.png" alt=""></p>
<h1 id="用JavaWeb服务器管理数据源"><a href="#用JavaWeb服务器管理数据源" class="headerlink" title="用JavaWeb服务器管理数据源"></a>用JavaWeb服务器管理数据源</h1><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li>拷贝数据库连接的jar(mysql-Connector)到tomcatlib目录下<ul>
<li>maven好像不用拷贝</li>
</ul>
</li>
<li><p>配置数据源XML文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context&gt;</span><br><span class="line">		&lt;Resource </span><br><span class="line">			name=&quot;jdbc/TestDB&quot;		 	//数据源名称</span><br><span class="line">			auth=&quot;Container&quot; 			  //数据源提供者</span><br><span class="line">			type=&quot;javax.sql.DataSource&quot;	//数据源类型</span><br><span class="line">			maxTotal=&quot;100&quot; 			</span><br><span class="line">			maxIdle=&quot;30&quot; 				</span><br><span class="line">			maxWaitMillis=&quot;10000&quot;</span><br><span class="line">			username=&quot;root&quot; </span><br><span class="line">			password=&quot;root&quot; </span><br><span class="line">			driverClassName=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">			url=&quot;jdbc:mysql://localhost:3306/javatest&quot;/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>在当前应用的<code>META-INF</code>中创建<code>context.xml</code>, 编写配置信息，那么只有当前应用可以使用。</li>
<li>在tomcat下的conf目录的<code>context.xml</code>中，编写配置信息，那么tomcat下所有应用都能使用此数据源。<ul>
<li>可以多个Resource如mysql，Oracle，sqlserver…</li>
<li>多个就构成了<strong>JNDI</strong>(安)</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Context initContext = new InitialContext();</span><br><span class="line">//Context envContext  = (Context)initContext.lookup(&quot;java:/comp/env&quot;);</span><br><span class="line">//DataSource ds = (DataSource)envContext.lookup(&quot;jdbc/TestDB&quot;);</span><br><span class="line">//上面两句可以合写成下面这一句</span><br><span class="line">DataSource ds = (DataSource)=initContext.lookup(&quot;java:/comp/env/jdbc/TestDB&quot;);</span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>java:/comp/env</code><ul>
<li>是固定写法</li>
</ul>
</li>
<li><code>jdbc/TestDB</code><ul>
<li>数据源XML配置中的Resource的name，自定义。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/xd-事务和连接池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/xd-事务和连接池/" itemprop="url">
                  xd-事务和连接池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-20 13:06:35" itemprop="dateCreated datePublished" datetime="2018-12-20T13:06:35+08:00">2018-12-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:42:22" itemprop="dateModified" datetime="2019-03-08T14:42:22+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h1><h2 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h2><ul>
<li>一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
</ul>
<h2 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h2><ul>
<li>事务必须是使数据库从一个一致性状态变到另一个一致性状态。即事务操作的前后, 数据表中的数据没有变化</li>
<li>一致性与原子性是密切相关的。</li>
</ul>
<h2 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h2><ul>
<li>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
</ul>
<h2 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h2><ul>
<li>持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>
<h1 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h1><ul>
<li>事务开启之后, 所有的操作都会临时保存到事务日志, 事务日志只有在得到commit命令才会同步到数据表,其他任何情况都会清空(rollback, 断电, 断开连接)</li>
</ul>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><ul>
<li>在一个事务处理过程里读取了另一个事务未提交的数据。</li>
<li><strong>例</strong><ul>
<li>我开启查看工资的事务,老板给我发工资，本来是1万，老板不小心多打了个0，发了10万，但老板没提交事务，我看到发了10万，高兴坏了，然后老板发现后回滚了。</li>
<li>最后实际还是发了1万工资，可我确看到10万，这就是脏读。</li>
</ul>
</li>
</ul>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><ul>
<li>在一个事务内读取表中的某一行数据，多次读取结果不同。一个事务读取到了另一个事务提交后的数据。(update)</li>
<li><strong>例</strong><ul>
<li>我开启事务查看卡里有多少钱，发现还有1万，还个事务没提交，这时我媳妇用我的卡转了1万并提交了。然后我想确认一下，又查了一遍，发现没钱了，我就懵逼了。</li>
<li>在一个事务中，有另一个事务进行了update操作并提交，导致两次读取数据不一致，就是不可重复读.</li>
</ul>
</li>
</ul>
<h3 id="虚读-幻读"><a href="#虚读-幻读" class="headerlink" title="虚读(幻读)"></a>虚读(幻读)</h3><ul>
<li>是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。(insert)</li>
<li><strong>例</strong><ul>
<li>我开启事务查询班里多少人，发现有24个人，还没提交，然后老师又插入了一个人，我确认一下，又查了一遍，发现25个人了，我又懵逼了。</li>
<li>在一个事务中，有另一个事务进行了insert操作并提交，导致两次读取数据不一致，就是虚读(幻读).</li>
</ul>
</li>
</ul>
<h3 id="总"><a href="#总" class="headerlink" title="总"></a>总</h3><ul>
<li>读了未提交的事务的数据即<strong>脏读</strong></li>
<li>读了已提交的事务的数据(update)即<strong>不可重复读</strong></li>
<li>读了已提交的事务的数据(insert)即<strong>虚读(幻读)</strong></li>
</ul>
<h2 id="隔离级别解决问题"><a href="#隔离级别解决问题" class="headerlink" title="隔离级别解决问题"></a>隔离级别解决问题</h2><ul>
<li>设置隔离级别要在开启事务之前。</li>
</ul>
<h3 id="1-READ-UNCOMMITTED"><a href="#1-READ-UNCOMMITTED" class="headerlink" title="1 READ UNCOMMITTED"></a><code>1 READ UNCOMMITTED</code></h3><ul>
<li>读未提交<ul>
<li>就是一个事务可以读取另一个未提交事务的数据</li>
</ul>
</li>
<li>脏读，不可重复读，虚读（幻读）都可能发生</li>
</ul>
<h3 id="2-READ-COMMITTED"><a href="#2-READ-COMMITTED" class="headerlink" title="2 READ COMMITTED"></a><code>2 READ COMMITTED</code></h3><ul>
<li>读已提交<ul>
<li>就是一个事务要等另一个事务提交后才能读取数据</li>
</ul>
</li>
<li>可避免脏读的发生</li>
<li>不可重复度，虚读(幻读)有可能发生.</li>
<li>Sql Server,oracle默认</li>
</ul>
<h3 id="4-REPEATABLE-READ"><a href="#4-REPEATABLE-READ" class="headerlink" title="4 REPEATABLE READ"></a><code>4 REPEATABLE READ</code></h3><ul>
<li>可重复读<ul>
<li>开始读取数据(事务开启)时，不允许别的事务进行update操作,但可以进行inser操作。</li>
</ul>
</li>
<li>可避免脏读、不可重复读的发生</li>
<li>虚读(幻读)有可能发生</li>
<li>mysql默认</li>
</ul>
<h3 id="8-SERIALIZABLE"><a href="#8-SERIALIZABLE" class="headerlink" title="8 SERIALIZABLE"></a><code>8 SERIALIZABLE</code></h3><ul>
<li>串行化</li>
<li>最高级别，都可以避免。</li>
<li>级别越高，性能越低，数据越安全</li>
</ul>
<h1 id="jdbc的事务"><a href="#jdbc的事务" class="headerlink" title="jdbc的事务"></a>jdbc的事务</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>自动提交事务（默认）<ul>
<li>每条单独的语句都是一个事务。每个语句后都隐含一个commit。 </li>
</ul>
</li>
<li><code>Connection.setAutoCommit(false)</code><ul>
<li>将自动提交设置为false即视为开启事务。</li>
</ul>
</li>
<li><code>Connection.commit()</code></li>
<li><code>Connection.rollback()</code></li>
</ul>
<h2 id="隔离级别-1"><a href="#隔离级别-1" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul>
<li><code>Connection.setTransactionIsolation(int level)</code><ul>
<li>设置隔离级别(必须在开启事务之前)<ul>
<li>level 常量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="mysql的事务"><a href="#mysql的事务" class="headerlink" title="mysql的事务"></a>mysql的事务</h1><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><ul>
<li>在mysql命令行下，默认事务都是自动提交的<ul>
<li><code>set autocommit=0/off</code><ul>
<li>关闭自动提交</li>
</ul>
</li>
</ul>
</li>
<li><code>begin</code> | <code>start transction</code> | <code>set autocommit=0/off</code><ul>
<li>开启事务</li>
</ul>
</li>
<li><code>commit</code></li>
<li><code>rollback</code></li>
</ul>
<h2 id="隔离级别-2"><a href="#隔离级别-2" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul>
<li><code>SELECT @@TX_ISOLATION;</code><ul>
<li>查看隔离级别</li>
</ul>
</li>
<li><code>SET TRANSACTION ISOLATION LEVEL 四个级别之一</code><ul>
<li>设置隔离级别</li>
<li>必须在开启事务之前</li>
</ul>
</li>
</ul>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><h2 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h2><ul>
<li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>解决建立数据库连接耗费资源和时间很多的问题，提高性能</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</li>
</ul>
<h2 id="javax-sql-DataSorce"><a href="#javax-sql-DataSorce" class="headerlink" title="javax.sql.DataSorce"></a><code>javax.sql.DataSorce</code></h2><ul>
<li>sun官方标准的连接池接口</li>
<li>自定义连接池实现此接口，数据库厂商自己实现。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>Connection getConnection()</code></li>
<li><code>Connection getConnection(String username, String password)</code></li>
</ul>
<h2 id="常用连接池"><a href="#常用连接池" class="headerlink" title="常用连接池"></a>常用连接池</h2><h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h3><ul>
<li><code>Database Connection Pool</code></li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>导包</li>
<li>配置文件</li>
<li>获取数据源<ul>
<li><code>BasicDataSourceFactory</code><ul>
<li><code>static DataSource createDataSource(properties prop)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = new Properties();</span><br><span class="line">prop.load(DBCPUtils.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;));</span><br><span class="line">DataSource ds = BasicDataSourceFactory.createDataSource(prop);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul>
<li>导包</li>
<li>配置文件<ul>
<li><code>c3p0-config.xml</code></li>
<li>名称必须为c3p0-config.xml，否则找不到</li>
</ul>
</li>
<li>获取数据源<ul>
<li><code>ComboPooledDataSource</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ComboPooledDataSource ds=new ComboPooledDataSource();</span><br><span class="line">ds.setDriver()</span><br><span class="line">ds.setJdbcUrl()</span><br><span class="line">ds.setUser()</span><br><span class="line">ds.setPassword;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><ul>
<li><code>com.alibaba.druid.pool.DruidDataSource</code></li>
<li>阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池(据说是目前最好的连接池）</li>
</ul>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><ul>
<li>导包</li>
<li>配置文件<ul>
<li>任意位置，任意名称<code>.properties</code></li>
</ul>
</li>
<li>获取数据源<ul>
<li><code>DruidDataSourceFactory</code><ul>
<li><code>DataSource createDataSource(Properties prop)</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用JavaWeb服务器管理数据源"><a href="#用JavaWeb服务器管理数据源" class="headerlink" title="用JavaWeb服务器管理数据源"></a>用JavaWeb服务器管理数据源</h2><h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>拷贝数据库连接的jar(mysql-Connector)到tomcat的lib目录下</li>
<li><p>配置数据源XML文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context&gt;</span><br><span class="line">	&lt;Resource name=&quot;jdbc/TestDB&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot;</span><br><span class="line">           maxTotal=&quot;100&quot; maxIdle=&quot;30&quot; maxWaitMillis=&quot;10000&quot;</span><br><span class="line">           username=&quot;root&quot; password=&quot;root&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">           url=&quot;jdbc:mysql://localhost:3306/javatest&quot;/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是在当前应用的META-INF中创建<code>context.xml</code>, 编写配置信息，那么只有当前应用可以使用。</li>
<li>如果把配置信息写在tomcat下的conf目录的<code>context.xml</code>中，那么所有应用都能使用此数据源。<ul>
<li>可以多个Resource如mysql，Oracle，sqlserver…</li>
<li>多个就构成了<strong>JNDI</strong>(安)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Context initContext = new InitialContext();</span><br><span class="line"></span><br><span class="line">//Context envContext  = (Context)initContext.lookup(&quot;java:/comp/env&quot;);</span><br><span class="line">//DataSource ds = (DataSource)envContext.lookup(&quot;jdbc/TestDB&quot;);</span><br><span class="line"></span><br><span class="line">//上面两句可以合写成下面这一句</span><br><span class="line">DataSource ds = (DataSource)=initContext.lookup(&quot;java:/comp/env/jdbc/TestDB&quot;);</span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>java:/comp/env</code><ul>
<li>是固定写法</li>
</ul>
</li>
<li><code>jdbc/TestDB</code><ul>
<li>是Resource的name，自定义。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png"
                alt="安₃" />
            
              <p class="site-author-name" itemprop="name">安₃</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">62</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安₃</span>

  

  
</div>



<!--





-->





        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  


<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
