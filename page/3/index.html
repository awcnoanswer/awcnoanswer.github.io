<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="安₃">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="安₃">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安₃">






  <link rel="canonical" href="http://yoursite.com/page/3/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>安₃</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<!--github start-->
	<a href="https://github.com/awcnoanswer" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	<!--github end-->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安₃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Hibernate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Hibernate/" itemprop="url">
                  xd-Hibernate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:39:59" itemprop="dateCreated datePublished" datetime="2018-12-11T00:39:59+08:00">2018-12-11</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Struts2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Struts2/" itemprop="url">
                  xd-Struts2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:39:49" itemprop="dateCreated datePublished" datetime="2018-12-11T00:39:49+08:00">2018-12-11</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-JSP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-JSP/" itemprop="url">
                  xd-JSP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:38:44" itemprop="dateCreated datePublished" datetime="2018-12-11T00:38:44+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-29 17:29:00" itemprop="dateModified" datetime="2018-12-29T17:29:00+08:00">2018-12-29</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>Java Server Pages</code></li>
<li>JSP本质上就是Servlet<ul>
<li>jsp翻译的<code>.java</code>文件间接继承了<code>HttpServlet</code></li>
</ul>
</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="jsp执行过程"><a href="#jsp执行过程" class="headerlink" title="jsp执行过程"></a>jsp执行过程</h2><ul>
<li>第一次访问会把<code>.jsp</code>先翻译成<code>.java</code>文件</li>
<li>把<code>.java</code>编译成<code>.class</code>文件</li>
<li>执行<code>.class</code>文件</li>
<li>以后访问直接执行.class文件</li>
<li>如果.jsp发生变化,则视为第一次访问，循环…。</li>
</ul>
<h2 id="jsp的html排版标签是如何展示的"><a href="#jsp的html排版标签是如何展示的" class="headerlink" title="jsp的html排版标签是如何展示的"></a>jsp的html排版标签是如何展示的</h2><ul>
<li>在service方法中调用<code>out.write(标签)</code>写出。</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li><p><code>test.jsp</code>生成的<code>.java</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.jasper.runtime.HttpJspBase;</span><br><span class="line">public final class test_jsp extends HttpJspBase &#123;</span><br><span class="line">	public void _jspService(req,res)&#123;&#125;</span><br><span class="line">	public void _jspInit() &#123;&#125;</span><br><span class="line">	public void _jspDestroy() &#123;&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HttpJspBase</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class HttpJspBase extends HttpServlet &#123;</span><br><span class="line">	public void _jspInit()&#123;&#125;</span><br><span class="line">	public void init(ServletConfig config)&#123;</span><br><span class="line">		_jspInit();</span><br><span class="line">	&#125;</span><br><span class="line">	public abstract void _jspService(req,res);</span><br><span class="line">	public void service(req,res)&#123;</span><br><span class="line">		_jspService(req,res);</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>jsp翻译成的<code>.java</code>文件，继承了<code>HttpJspBase</code>，而<code>HttpJspBase</code>继承了<code>HttpServlet</code>，所以说jsp就是一个Servlet。</li>
<li>可以看到方法调用，最终还是servlet的那几个方法。</li>
</ul>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li>静态内容 如:html标签和文本。</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><code>&lt;!-- --&gt;</code><ul>
<li>不能注释脚本</li>
</ul>
</li>
<li><code>&lt;%-- --%&gt;</code><ul>
<li>可以注释脚本</li>
<li>不会被写出到最终的页面中，安全省流量。</li>
</ul>
</li>
</ul>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h3><ul>
<li><code>&lt;% java代码 %&gt;</code><ul>
<li>最终在翻译成的<code>.java</code>文件的<code>service()</code>中</li>
</ul>
</li>
</ul>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ul>
<li><code>&lt;%= %&gt;</code><ul>
<li><code>out.write()</code></li>
<li>最终在翻译成的<code>.java</code>文件的<code>service()</code>中</li>
</ul>
</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li><code>&lt;%! %&gt;</code><ul>
<li>声明成员变量，静态块…</li>
<li>最终在翻译成的<code>.java</code>文件的成员位置。</li>
</ul>
</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul>
<li>jsp指令不直接产生任何可见输出，而只告诉jsp引擎如何处理jsp页面中的内容。</li>
</ul>
<h3 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h3><ul>
<li><code>&lt;%@指令名 属性1=&quot;值&quot; 属性2=&quot;值&quot;... %&gt;</code><ul>
<li>页面中可出现多次</li>
</ul>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h4><ul>
<li>用于定义jsp页面的各种属性</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><code>import</code><ul>
<li>用于导包</li>
<li>jsp默认自动导入的包<ul>
<li><code>import java.lang.*;</code></li>
<li><code>import javax.servlet.*;</code></li>
<li><code>import javax.servlet.http.*;</code></li>
<li><code>import javax.servlet.jsp.*</code></li>
</ul>
</li>
</ul>
</li>
<li><code>language</code><ul>
<li><code>java</code>： 默认</li>
</ul>
</li>
<li><strong><code>pageEncoding</code></strong><ul>
<li>告诉服务器用什么编码把<code>.jsp</code>翻译成<code>.java</code>文件</li>
</ul>
</li>
<li><code>session</code><ul>
<li><code>true</code>： 默认</li>
<li><code>false</code></li>
</ul>
</li>
<li><code>buffer</code><ul>
<li>输出数据的缓存大小(out的缓冲区)</li>
<li>值<ul>
<li><code>8kb</code> ：默认</li>
<li><code>none</code></li>
<li><code>自定义size kb</code></li>
</ul>
</li>
</ul>
</li>
<li><code>errorPage</code><ul>
<li>如果页面中有错误，则跳转到指定的资源</li>
<li><code>errorPage=&quot;/xx.jsp&quot;</code></li>
</ul>
</li>
<li><code>isErrorPage</code><ul>
<li>是否创建throwable内置对象</li>
<li>是否是错误页面</li>
<li>值<ul>
<li><code>true</code></li>
<li><code>false</code>： 默认</li>
</ul>
</li>
</ul>
</li>
<li><code>contentType</code><ul>
<li>等价于<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code></li>
<li>告诉浏览器用什么格式和编码解析</li>
<li>如果不赋值，默认使用<code>pageEncoding</code>的编码</li>
</ul>
</li>
<li><code>isELIgnored</code><ul>
<li>是否忽略EL表达式</li>
<li>值<ul>
<li><code>true</code></li>
<li><code>false</code>： 默认</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="taglib指令"><a href="#taglib指令" class="headerlink" title="taglib指令"></a>taglib指令</h4><ul>
<li><code>&lt;%@ taglib uri=&quot;&quot; prefix=&quot;&quot; %&gt;</code><ul>
<li>在JSP页面中导入标签库。</li>
</ul>
</li>
</ul>
<h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h4><ul>
<li><code>&lt;%@ include file=&quot;&quot; %&gt;</code><ul>
<li><strong>静态包含</strong></li>
<li>先合并成一个文件，再翻译。所以静态包含，被包含的文件可以不写重复的标签</li>
</ul>
</li>
</ul>
<h2 id="jsp编码问题"><a href="#jsp编码问题" class="headerlink" title="jsp编码问题"></a>jsp编码问题</h2><h3 id="jsp编解码过程"><a href="#jsp编解码过程" class="headerlink" title="jsp编解码过程"></a>jsp编解码过程</h3><ol>
<li><code>.jsp</code>的存储编码<ul>
<li>即文件本身的存储编码</li>
<li>我的ide通常用utf-8，所以<code>.jsp</code>也是用utf-8存的</li>
<li>注意用什么存的，<code>pageEncoding</code>就要写什么,不然翻译就会乱码</li>
</ul>
</li>
<li><code>.jsp</code>→<code>.java</code><ul>
<li>使用<code>pageEncoding</code>指定的码表翻译</li>
</ul>
</li>
<li><code>.java</code>→<code>.class</code><ul>
<li>jvm使用utf-8编译，不可修改</li>
</ul>
</li>
<li>用户浏览器解析<ul>
<li>使用的是<code>contentType</code>指定的编码</li>
</ul>
</li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>想要不乱码，保证以下三码一致即可。<ol>
<li><code>.jsp</code>的存储编码</li>
<li><code>pageEncoding</code>的编码</li>
<li><code>contentType</code>的编码</li>
</ol>
</li>
<li>而由于<code>contentType</code>如果不赋值，默认会使用<code>pageEncoding</code>的编码。所以，保证<code>.jsp</code>的存储编码和<code>pageEncoding</code>的编码一致即可。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>设置jsp的<code>pageEncoding</code>的编码为<code>.jsp</code>的文件存储编码即可</li>
</ul>
<h3 id="jsp中的html乱码"><a href="#jsp中的html乱码" class="headerlink" title="jsp中的html乱码"></a>jsp中的html乱码</h3><ul>
<li>因为html本身也有编码格式，而jsp中包含有html的内容</li>
<li>如果html的内容乱码设置好content中的charset即可<ul>
<li><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h2><h3 id="lt-jsp-include-gt"><a href="#lt-jsp-include-gt" class="headerlink" title="&lt;jsp:include&gt;"></a><code>&lt;jsp:include&gt;</code></h3><ul>
<li><code>&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;</code><ul>
<li><strong>动态包含</strong></li>
<li>不会合并文件，当代码执行到include时，才包含另一个文件的内容</li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-forward-gt"><a href="#lt-jsp-forward-gt" class="headerlink" title="&lt;jsp:forward&gt;"></a><code>&lt;jsp:forward&gt;</code></h3><ul>
<li><code>&lt;jsp:forward page=&quot;path&quot;/&gt;</code><ul>
<li>转发</li>
<li>相当于<code>req.getRequestDispatcher(path).forward(req,res);</code></li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-param-gt"><a href="#lt-jsp-param-gt" class="headerlink" title="&lt;jsp:param&gt;"></a><code>&lt;jsp:param&gt;</code></h3><ul>
<li><code>&lt;jsp:param name=&quot;&quot; value=&quot;&quot; /&gt;</code><ul>
<li>请求参数</li>
<li>相当于<code>url?name=value</code></li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-useBean-gt"><a href="#lt-jsp-useBean-gt" class="headerlink" title="&lt;jsp:useBean&gt;"></a><code>&lt;jsp:useBean&gt;</code></h3><ul>
<li><code>&lt;jsp:useBean id=&quot;p&quot; class=&quot;cn.an.Person&quot;/&gt;</code><ul>
<li>创建对象</li>
<li>相当于<code>cn.an.Person p=new Person();</code></li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-setProperty-gt"><a href="#lt-jsp-setProperty-gt" class="headerlink" title="&lt;jsp:setProperty&gt;"></a><code>&lt;jsp:setProperty&gt;</code></h3><ul>
<li><code>&lt;jsp:setProperty property=&quot;age&quot; name=&quot;p&quot; value=&quot;8&quot;/&gt;</code><ul>
<li>为对象属性赋值</li>
<li>相当于<code>p.setAge(8);</code></li>
</ul>
</li>
</ul>
<h3 id="lt-jsp-getProperty-gt"><a href="#lt-jsp-getProperty-gt" class="headerlink" title="&lt;jsp:getProperty&gt;"></a><code>&lt;jsp:getProperty&gt;</code></h3><ul>
<li><code>&lt;jsp:getProperty property=&quot;age&quot; name=&quot;p&quot;/&gt;</code><ul>
<li>获取对象属性值</li>
<li>相当于<code>p.getAge();</code></li>
</ul>
</li>
</ul>
<h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><ul>
<li>在<code>&lt;%= %&gt;</code>和<code>&lt;% %&gt;</code>中可以直接使用的对象。即<code>service()</code>中的对象</li>
</ul>
<table>
<thead>
<tr>
<th>对象名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td><code>javax.servlet.http.HttpServletRequest</code></td>
<td>request域</td>
</tr>
<tr>
<td>response</td>
<td><code>javax.servlet.http.HttpServletResponse</code></td>
<td>response域</td>
</tr>
<tr>
<td>session</td>
<td><code>javax.servlet.http.HttpSession</code></td>
<td>session域 page指令的session属性开关</td>
</tr>
<tr>
<td>application</td>
<td><code>javax.servlet.ServletContext</code></td>
<td>application域</td>
</tr>
<tr>
<td>pageContext</td>
<td><code>javax.servlet.jsp.PageContext</code></td>
<td>pageContext域</td>
</tr>
<tr>
<td>exception</td>
<td><code>java.lang.Throwable</code></td>
<td>page指令的isErrorPage属性开关</td>
</tr>
<tr>
<td>page</td>
<td><code>java.lang.Object</code></td>
<td>当前servlet实例 this</td>
</tr>
<tr>
<td>config</td>
<td><code>javax.servlet.ServletConfig</code></td>
<td></td>
</tr>
<tr>
<td>out</td>
<td><code>javax.servlet.jsp.JspWriter</code></td>
<td>字符输出流，相当于 printWriter对象</td>
</tr>
</tbody>
</table>
<h2 id="out"><a href="#out" class="headerlink" title="out"></a>out</h2><ul>
<li><code>out.write()</code>和<code>response.getWriter().write()</code><ul>
<li>区别<ul>
<li>最后响应时，tomcat总会先从response中获取数据，然后才会从out中获取数据。</li>
<li>所以无论何时，总是response先输出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pageContext"><a href="#pageContext" class="headerlink" title="pageContext"></a>pageContext</h2><ul>
<li>可以获取其它八个内置对象<ul>
<li>自定义标签时为了获取九个内置对象不需要全部传入,传入pageContext即可</li>
</ul>
</li>
<li>是域对象<ul>
<li><code>void setAttribute(String name,Object value)</code></li>
<li><code>Object getAttribute(String name)</code></li>
<li><code>void removeAttribute(String name)</code></li>
</ul>
</li>
<li>可以操作其它域对象<ul>
<li><code>void setAttribute(String name,Object value,int Scope)</code></li>
<li><code>Object getAttribute(String name,int Scope)</code></li>
<li><code>void removeAttribute(String name,int Scope)</code><ul>
<li>Scope<ul>
<li><code>PageContext.PAGE_SCOP</code>E </li>
<li><code>PageContext.REQUEST_SCOPE</code></li>
<li><code>PageContext.SESSION_SCOPE</code></li>
<li><code>PageContext.APPLICATION_SCOPE</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Object findAttribute()</code><ul>
<li>自动从四个域对象找,找到就返回</li>
<li>顺序page-request-session-application</li>
</ul>
</li>
<li>提供了简易方法<ul>
<li><code>forward()</code></li>
<li><code>include()</code></li>
</ul>
</li>
</ul>
<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li><code>expression language</code></li>
<li>简化jsp中的java代码(主要是获取数据方面的简化)</li>
<li>不是开发语言是jsp中获取数据的一种规范<ul>
<li>只能用在jsp，html无法解析</li>
</ul>
</li>
</ul>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><ul>
<li><code>${表达式}</code></li>
</ul>
<h2 id="忽略EL表达式"><a href="#忽略EL表达式" class="headerlink" title="忽略EL表达式"></a>忽略EL表达式</h2><ol>
<li>设置jsp的page指令的<code>isElIgnored</code>为true，则当前jsp都不能使用EL表达式</li>
<li><code>\${表达式}</code><ul>
<li>忽略当前这个EL表达式</li>
</ul>
</li>
</ol>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li>算术运算符<ul>
<li><code>+ - * /(div) %(mod)</code></li>
<li><code>3 / 4</code>也可以表示为<code>3 div 4</code></li>
</ul>
</li>
<li>比较运算符<ul>
<li><code>&gt; &lt; &gt;= &lt;= == !=</code></li>
</ul>
</li>
<li>逻辑运算符<ul>
<li><code>&amp;&amp;(and) ||(or) !(not)</code></li>
</ul>
</li>
<li>空运算符<ul>
<li><code>empty</code><ul>
<li>用于判断字符串，集合，数组对象是否为null或者长度是否为0</li>
<li>true<ul>
<li>空字符串<ul>
<li><code>String s=null</code></li>
<li><code>String s=&quot;&quot;</code></li>
</ul>
</li>
<li>没有元素的集合(即使集合对象本身不为null)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>三元运算<ul>
<li><code>${empty key?&quot;为空&quot;:&quot;不为空&quot;}</code></li>
<li><code>${key==1?&quot;男&quot;:&quot;女&quot;}</code></li>
</ul>
</li>
</ul>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>EL表达式只能从域中获取数据</li>
<li>EL获取的值若为null会显示为<code>&quot;&quot;</code></li>
</ul>
<h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><ol>
<li><code>${键名}</code><ul>
<li>相当于<code>pageContext.findAttribute()</code></li>
<li>依次从四个域中查找数据找到就返回，如果多个域存的key相同，则后边的无法取到。<ul>
<li><code>${pageScope.key}</code></li>
<li><code>${requestScope.key}</code></li>
<li><code>${sessionScope.key}</code></li>
<li><code>${applicationScope.key}</code></li>
</ul>
</li>
</ul>
</li>
<li><code>${域名.键名}</code><ul>
<li>从指定域中获取指定key的值</li>
</ul>
</li>
<li><code>${域名.键名.属性名}</code><ul>
<li>域中存的是对象</li>
<li>通过对象属性导航图获取属性值(本质调用对象get方法)</li>
</ul>
</li>
<li><code>${域名.键名[索引]}</code><ul>
<li>List集合</li>
</ul>
</li>
<li><code>${域名.键名.key}</code> 或 <code>${域名.键名[&quot;key&quot;]}</code><ul>
<li>Map集合</li>
</ul>
</li>
</ol>
<h2 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h2><table>
<thead>
<tr>
<th>隐式对象名</th>
<th>类型</th>
<th>对应jsp内置对象名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pageContext</td>
<td><code>javax.servlet.jsp.PageContex</code></td>
<td>pageContext</td>
<td>二者一样</td>
</tr>
<tr>
<td>pageScope</td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td>pageContext域</td>
</tr>
<tr>
<td>requestScope</td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td>request域</td>
</tr>
<tr>
<td>sessionScope</td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td>session域</td>
</tr>
<tr>
<td>applicationScope</td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td>application域</td>
</tr>
<tr>
<td>param</td>
<td><code>java.util.Map&lt;String,String&gt;</code></td>
<td>无</td>
<td>一个请求参数</td>
</tr>
<tr>
<td>paramValues</td>
<td><code>java.util.Map&lt;String,String[]&gt;</code></td>
<td>无</td>
<td>重名请求参数</td>
</tr>
<tr>
<td>header</td>
<td><code>java.util.Map&lt;String,String&gt;</code></td>
<td>无</td>
<td>一个请求消息头</td>
</tr>
<tr>
<td>headerValues</td>
<td><code>java.util.Map&lt;String,String[]&gt;</code></td>
<td>无</td>
<td>重名请求消息头</td>
</tr>
<tr>
<td>initParam</td>
<td><code>java.util.Map&lt;String,String&gt;</code></td>
<td>无</td>
<td>web.xml中全局参数</td>
</tr>
<tr>
<td>cookie</td>
<td><code>java.util.Map&lt;String,Cookie&gt;</code></td>
<td>无</td>
<td>key:cookie对象的name值</td>
</tr>
</tbody>
</table>
<h3 id="pageContext-1"><a href="#pageContext-1" class="headerlink" title="pageContext"></a>pageContext</h3><ul>
<li>跟jsp内置一样，可以获取jsp其它内置对象</li>
<li><code>${pageContext.request.contextpath}</code><ul>
<li>相当于pageContext.getRequest().getContextPah();<ul>
<li>但注意这句不能执行</li>
<li>因为pageContext.getRequest()得到的是ServletRequest而不是HttpServletRequest所以需要强转</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul>
<li><code>JavaServerPages Standard Tag Library</code></li>
<li>JSP标准标签库<ul>
<li>包含五个库<ul>
<li><strong>Core</strong> 前缀c</li>
<li>I18N 前缀fmt</li>
<li>SQL 前缀sql</li>
<li>XML 前缀x</li>
<li>Functions 前缀fn</li>
</ul>
</li>
</ul>
</li>
<li>简化java代码(主要是逻辑处理方面,判断循环..)</li>
<li>因为jstl存取都是在域对象中，所以jstl中不管是取值还是赋值都要用el<ul>
<li>因为jstl不会解析表达式，只能靠el去解析</li>
</ul>
</li>
</ul>
<h2 id="引入jstl"><a href="#引入jstl" class="headerlink" title="引入jstl"></a>引入jstl</h2><ul>
<li><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;自定义&quot; %&gt;</code></li>
</ul>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="通用标签"><a href="#通用标签" class="headerlink" title="通用标签"></a>通用标签</h3><ul>
<li>都可以指定scope</li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h4><ul>
<li><code>&lt;c:set var=&quot;num&quot; value=&quot;10&quot; scope=&quot;session&quot; /&gt;</code><ul>
<li>声明变量并赋值（放在了域中）</li>
<li>存数据到域中相当于<code>setAttribute()</code></li>
</ul>
</li>
</ul>
<h4 id="out-1"><a href="#out-1" class="headerlink" title="out"></a><code>out</code></h4><ul>
<li><code>&lt;c:out value=&quot;${num}&quot; scope=&quot;session&quot;/&gt;</code><ul>
<li>输出的value要写EL表达式(从域中取数据相当于<code>getAttribute()</code>)</li>
<li>可以直接用El表达式代替out标签</li>
</ul>
</li>
</ul>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a><code>remove</code></h4><ul>
<li>`&lt;c:remove var=”num” scope=”session”/&gt;<ul>
<li>从域中删除相当于<code>removeAttribute()</code></li>
</ul>
</li>
</ul>
<h3 id="条件标签"><a href="#条件标签" class="headerlink" title="条件标签"></a>条件标签</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h4><ul>
<li><code>&lt;c:if test=&quot;&quot;&gt;&lt;/c:if&gt;</code><ul>
<li>test通常会使用el表达式</li>
</ul>
</li>
</ul>
<h4 id="choose"><a href="#choose" class="headerlink" title="choose"></a><code>choose</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">	&lt;c:when test=&quot;&quot;&gt;1&lt;/c:when&gt;</span><br><span class="line">	&lt;c:when test=&quot;&quot;&gt;2&lt;/c:when&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;c:otherwise&gt;0&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<h3 id="迭代标签"><a href="#迭代标签" class="headerlink" title="迭代标签"></a>迭代标签</h3><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><code>forEach</code></h4><ul>
<li><code>&lt;c:forEach var=&quot;&quot; begin=&quot;&quot; end=&quot;&quot; step=&quot;&quot; varStatus=&quot;&quot;&gt;&lt;/c:forEach&gt;</code><ul>
<li>普通循环</li>
</ul>
</li>
<li><code>&lt;c:forEach items=&quot;&quot; var=&quot;&quot; varStatus=&quot;&quot;&gt;&lt;/c:forEach&gt;</code><ul>
<li>增强循环</li>
</ul>
</li>
</ul>
<h5 id="varStatus"><a href="#varStatus" class="headerlink" title="varStatus"></a>varStatus</h5><ul>
<li>底层：指向一个字符串，该字符串引用一个对象。这个对象记录着当前遍历的元素的一些信息：<ul>
<li>map.put(“vs”,对象)</li>
</ul>
</li>
<li>所以varStatus可以取到当前遍历元素的信息。<ul>
<li><code>${vs.index}</code><ul>
<li>返回索引 从0开始</li>
</ul>
</li>
<li><code>${vs.count}</code><ul>
<li>返回计数 从1开始</li>
</ul>
</li>
<li><code>${vs.current}</code><ul>
<li>返回当前元素</li>
</ul>
</li>
<li><code>${vs.first}</code><ul>
<li>是否第一个</li>
</ul>
</li>
<li><code>${vs.last}</code><ul>
<li>是否最后一个`</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="域对象"><a href="#域对象" class="headerlink" title="域对象"></a>域对象</h1><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><ul>
<li>创建<ul>
<li>服务器启动</li>
</ul>
</li>
<li>销毁<ul>
<li>服务器关闭</li>
</ul>
</li>
<li>作用域<ul>
<li>整个web应用</li>
</ul>
</li>
</ul>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><ul>
<li>创建<ul>
<li>第一次<code>request.getSession()</code></li>
</ul>
</li>
<li>销毁<ul>
<li>服务器关闭(非正常)</li>
<li>失效/过期 </li>
<li>手动<code>session.invalidate()</code></li>
</ul>
</li>
<li>作用域<ul>
<li>一次会话中</li>
</ul>
</li>
</ul>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><ul>
<li>创建<ul>
<li>客户端发送请求</li>
</ul>
</li>
<li>销毁<ul>
<li>响应结束</li>
</ul>
</li>
<li>作用域<ul>
<li>一次请求</li>
</ul>
</li>
</ul>
<h3 id="pageContext-2"><a href="#pageContext-2" class="headerlink" title="pageContext"></a>pageContext</h3><ul>
<li>作用域<ul>
<li>当前页面</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Servlet/" itemprop="url">
                  xd-Servlet
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:38:28" itemprop="dateCreated datePublished" datetime="2018-12-11T00:38:28+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-14 20:42:51" itemprop="dateModified" datetime="2019-01-14T20:42:51+08:00">2019-01-14</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>server applet</code><ul>
<li>运行在服务端的小程序</li>
</ul>
</li>
<li>客户端请求服务器动态资源时，怎么就是动态资源呢？需要写代码逻辑来实现动态，也就是java类。而这种java类不是自己使用main方法执行的，而是依赖服务器执行的。那么什么样的java类服务器都认可吗？这就要求java类符合一定的规范，这规范就是Servlet</li>
<li>Servlet就是一个接口，定义了java类被浏览器访问到（tomcat识别）的规则。</li>
</ul>
<h2 id="Servlet规范包含三个技术点"><a href="#Servlet规范包含三个技术点" class="headerlink" title="Servlet规范包含三个技术点"></a>Servlet规范包含三个技术点</h2><ul>
<li>servlet技术</li>
<li>filter技术</li>
<li>listener技术</li>
</ul>
<h1 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h1><p><img src="https://gitee.com/3noanswer/pics/raw/master/Servle体系图.png" alt=""></p>
<h1 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h1><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>默认第一请求访问时实例化servlet</li>
<li><p>通过配置<code>&lt;load-on-startup&gt;</code>服务器一启动就实例化servlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;load-on-startup&gt;x&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>x&gt;0<ul>
<li>web容器启动的时候做实例化处理，顺序是由小到大，正整数小的先被实例化(1-2-3…)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li><code>init(ServletConfig config)</code><ul>
<li>只会调用一次</li>
<li>说明<strong>Servlet是单例</strong>的<ul>
<li>不要使用成员变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><ul>
<li><code>service(ServletRequest req, ServletResponse res)</code><ul>
<li>每次请求都会调用</li>
</ul>
</li>
</ul>
<h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><ul>
<li><code>destroy()</code><ul>
<li>只会调用一次</li>
<li>在Servlet销毁前调用，服务器关闭，Servlet销毁</li>
<li>tomcat正常关闭,才会调用</li>
</ul>
</li>
</ul>
<h1 id="Servelt执行过程"><a href="#Servelt执行过程" class="headerlink" title="Servelt执行过程"></a>Servelt执行过程</h1><ol>
<li>客户端发送请求<code>http://localhost:8080/应用名/资源名</code></li>
<li>tomcat接收请求</li>
<li>tomcat根据请求路径<ul>
<li><code>应用名</code><ul>
<li>查找tomcat服务器下是否有此名称应用</li>
</ul>
</li>
<li><code>资源名</code><ul>
<li>查找<code>web.xml</code>的<code>&lt;url-pattern&gt;</code>是否有次资源名</li>
<li>根据<code>&lt;url-pattern&gt;</code>匹配到相应的<code>&lt;Servlet-name&gt;</code></li>
<li>根据<code>&lt;Servlet-name&gt;</code>匹配到相应的<code>&lt;Servlet-class&gt;</code></li>
<li>根据<code>&lt;Servlet-class&gt;</code>的全类名通过反射将字节码文件加载进内存</li>
<li>然后通过反射创建Servlet对象(默认第一次访问创建)，初始化…</li>
<li>然后调用<code>service()</code></li>
</ul>
</li>
</ul>
</li>
<li>响应数据给客户端。</li>
</ol>
<h1 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h1><ol>
<li>实现Servlet接口(不推荐)</li>
<li>继承GenericServlet(不推荐)</li>
<li>继承HttpServlet(常用)</li>
</ol>
<h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><ul>
<li>一个Servlet可以有多个匹配路径，即<code>url-pattern</code>的值可以有多个</li>
</ul>
<h2 id="映射规则"><a href="#映射规则" class="headerlink" title="映射规则"></a>映射规则</h2><ul>
<li><code>/xxx/xx/x</code><ul>
<li>绝对匹配    </li>
</ul>
</li>
<li><code>/*</code><ul>
<li>拦截所有</li>
</ul>
</li>
<li><code>*.do</code><ul>
<li>指定扩展名</li>
</ul>
</li>
<li>优先级<ul>
<li><code>绝对匹配 &gt; /开头匹配 &gt; 扩展名方式匹配</code></li>
</ul>
</li>
</ul>
<h2 id="为什么可以访问xxx-jsp-安"><a href="#为什么可以访问xxx-jsp-安" class="headerlink" title="为什么可以访问xxx.jsp(安)"></a>为什么可以访问<code>xxx.jsp</code>(安)</h2><h3 id="DefaultServlet"><a href="#DefaultServlet" class="headerlink" title="DefaultServlet"></a><code>DefaultServlet</code></h3><ul>
<li>缺省Servlet     </li>
<li>其实web服务器中的资源(包含静态资源)都是由servlet响应的</li>
<li><p>tomcat中<code>/conf/web.xml</code>中的默认配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;default&lt;servlet-name&gt;</span><br><span class="line">		&lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;jsp&lt;servlet-name&gt;</span><br><span class="line">		&lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">// ------------------------------------------------------------------</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">		&lt;servlet-name&gt;default&lt;servlet-name&gt;</span><br><span class="line">		&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">		&lt;servlet-name&gt;jsp&lt;servlet-name&gt;</span><br><span class="line">		&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">		&lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看出对于所有资源如果没有优先的匹配<ul>
<li>默认找的是<code>DefaultServlet</code></li>
<li>我们配置<code>/</code>会覆盖默认</li>
</ul>
</li>
<li>对于<code>.jsp .jspx</code>默认找的是<code>JspServlet</code></li>
</ul>
</li>
</ul>
<h2 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h2><ul>
<li>支持注解</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="WebServlet"><a href="#WebServlet" class="headerlink" title="@WebServlet"></a><code>@WebServlet</code></h4><ul>
<li><code>String name() default &quot;&quot;</code><ul>
<li>相当于<code>&lt;Servlet-name&gt;</code></li>
</ul>
</li>
<li><code>String[] value() default {}</code><ul>
<li>代表<code>urlPatterns()</code>属性配置</li>
</ul>
</li>
<li><code>String[] urlPatterns() default {}</code><ul>
<li>相当于<code>&lt;url-pattern&gt;</code></li>
</ul>
</li>
<li><code>int loadOnStartup() default -1</code></li>
<li><code>WebInitParam[] initParams() default {}</code></li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>由于注解作用在类上，所以不用配置<code>&lt;servlet-name&gt;</code>来匹配<code>&lt;servlet-class&gt;</code>了，即不用配置<code>name</code></li>
<li>只需配置<code>urlPattern()</code>即可找到servlet，而<code>value</code>又代表了<code>urlPatterns()</code>的值，所以配置<code>value</code>也是一样的，而注解中如果只配一项，而此项名称又是<code>value</code>，<code>value</code>是可以省略的。</li>
<li>所以直接配置虚拟目录值即可<ul>
<li><code>@WebServlet(&quot;/虚拟目录1&quot;, &quot;/虚拟目录2&quot;, &quot;...&quot;)</code></li>
</ul>
</li>
</ul>
<h1 id="Interface-Servlet"><a href="#Interface-Servlet" class="headerlink" title="Interface Servlet"></a>Interface Servlet</h1><ul>
<li>所有servlet都要直接或间接实现此接口</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>void init(ServletConfig config)</code>    </li>
<li><code>void service(ServletRequest req, ServletResponse res)</code></li>
<li><code>void destroy()</code></li>
<li><code>ServletConfig getServletConfig()</code></li>
<li><code>String getServletInfo()</code><ul>
<li>获取servlet信息(作者,版本,版权…)</li>
</ul>
</li>
</ul>
<h1 id="Interface-ServletConfig"><a href="#Interface-ServletConfig" class="headerlink" title="Interface ServletConfig"></a>Interface ServletConfig</h1><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>ServletContext getServletContext()</code></li>
<li><code>String getInitParameter(String name)</code><ul>
<li>由当前servlet配置信息的键获取值</li>
</ul>
</li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code><ul>
<li>获取当前servlet配置信息的名称的枚举</li>
</ul>
</li>
<li><p>当前servlet配置信息在web.xm中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;servelt&gt;</span><br><span class="line">		&lt;init-param&gt;</span><br><span class="line">			&lt;param-name&gt;&lt;/param-name&gt;</span><br><span class="line">			&lt;param-value&gt;&lt;/param-value&gt;</span><br><span class="line">		&lt;/init-param&gt;</span><br><span class="line">&lt;/servelt&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String getServletName()</code></p>
<ul>
<li>获取servlet名字</li>
</ul>
</li>
</ul>
<h1 id="abstract-class-GenericServlet"><a href="#abstract-class-GenericServlet" class="headerlink" title="abstract class GenericServlet"></a>abstract class GenericServlet</h1><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>void init(ServletConfig config)</code><ul>
<li>实现的接口Servlet的<code>void init(ServletConfig config)</code>方法</li>
<li>此有参init(ServletConfig config)内部调用了<code>GenericServlet</code>特有的无参init()</li>
</ul>
</li>
<li><code>void init()</code><ul>
<li>GenericServlet类的特有方法</li>
<li>内容为空,是为了让程序员做一些其它事情，比如做了一些自定义初始化，有参初始化init()方法会自动调用此无参方法。(安)</li>
</ul>
</li>
</ul>
<h1 id="abstract-class-HttpServlet"><a href="#abstract-class-HttpServlet" class="headerlink" title="abstract class HttpServlet"></a>abstract class HttpServlet</h1><h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>void doGet(HttpServletRequest req, HttpServletResponse res)</code></li>
<li><code>void doPost(HttpServletRequest req, HttpServletResponse res)</code></li>
<li><code>void doXxx()</code><ul>
<li>其它doxxx方法。</li>
</ul>
</li>
<li><code>void service(ServletRequest req, ServletResponse res)</code><ul>
<li>覆写父类<code>GenericServlet</code>的<code>service()</code>方法</li>
</ul>
</li>
<li><code>void service(HttpServletRequest req, HttpServletResponse res)</code><ul>
<li><code>HttpServlet</code>特有的<code>service()</code>方法。</li>
</ul>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>每次请求都会执行<code>service()</code>方法，<code>HttpServlet</code>重写了此方法，此方法内部<ul>
<li>判断是否是http请求<ul>
<li>否<ul>
<li>则抛出非http请求异常</li>
</ul>
</li>
<li>是<ul>
<li>则调用<code>HttpServlet</code>特有的<code>service()</code>方法</li>
<li>特有的<code>service()</code>方法内部<ul>
<li>通过请求对象req获取请求方法名<ul>
<li>get 则调用本类<code>doGet()</code>方法</li>
<li>post 则调用本类<code>doPost()</code>方法</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>所以我们继承<code>HtttpServlet</code>的servlet只需要覆写<code>doGet()</code>或<code>doPost()</code>即可</li>
</ul>
<h1 id="Interface-ServletContext"><a href="#Interface-ServletContext" class="headerlink" title="Interface ServletContext"></a>Interface ServletContext</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>代表整个应用，一个应用对应一个ServletContext，可以和程序的容器(服务器)来通信</li>
</ul>
<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><ol>
<li><code>ServletContext getServletContext()</code><ul>
<li><code>ServletConfig</code>接口的方法</li>
<li>由于我们的servlet是实现了<code>ServletConftig</code>接口的，所以直接调用此接方法获取即可<ul>
<li><code>this.getServletContext()</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ServletContext getServletContext()</code><ul>
<li><code>HttpServletRequest</code>接口中的方法</li>
<li>使用request对象获取<ul>
<li><code>request.getServletContext()</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="获取MIME类型"><a href="#获取MIME类型" class="headerlink" title="获取MIME类型"></a>获取MIME类型</h3><ul>
<li><code>String getMimeType(String file)</code></li>
</ul>
<h4 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h4><ul>
<li>在互联网通信过程中定义的一种文件数据类型</li>
<li>格式<ul>
<li><code>大类型/小类型</code>   <ul>
<li><code>text/html</code></li>
<li><code>image/jpeg</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="域对象"><a href="#域对象" class="headerlink" title="域对象"></a>域对象</h3><ul>
<li><code>void setAttribute(String key,Object obj)</code></li>
<li><code>Object getAttribute(String key)</code></li>
<li><code>void removeAttribute(String key)</code></li>
</ul>
<h3 id="获取文件真实-服务器-路径"><a href="#获取文件真实-服务器-路径" class="headerlink" title="获取文件真实(服务器)路径"></a>获取文件真实(服务器)路径</h3><ul>
<li><code>String getRealPath(String path)</code><ul>
<li>应用下任何路径的资源都可以获取。</li>
<li><code>path</code><ul>
<li>为资源相对路径以<code>/</code>开头</li>
<li>注意这个相对路径说的是最终标准web应用结构时的相对路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="src下的资源xxx"><a href="#src下的资源xxx" class="headerlink" title="src下的资源xxx"></a>src下的资源xxx</h4><ul>
<li><code>getServletContext().getRealPath(&quot;/WEB-INF/classes/xxx&quot;)</code><ul>
<li>src中的资源最后会在<code>WEB-INF/classes</code>中</li>
<li>对于<code>WEB-INF/classes</code>下的资源还有一种获取方式<ul>
<li><code>MyServlet.class.getClassloader().getResource(&quot;xxx&quot;).getPath()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="web下的资源xxx"><a href="#web下的资源xxx" class="headerlink" title="web下的资源xxx"></a>web下的资源xxx</h4><ul>
<li><code>getServletContext().getRealPath(&quot;/xxx&quot;)</code><ul>
<li>web下的资源最后就在应用下</li>
</ul>
</li>
</ul>
<h4 id="WEB-INF下的资源xxx"><a href="#WEB-INF下的资源xxx" class="headerlink" title="WEB-INF下的资源xxx"></a>WEB-INF下的资源xxx</h4><ul>
<li><code>getServletContext().getRealPath(&quot;/WEB-INF/xxx&quot;)</code></li>
</ul>
<h4 id="应用下与src-web同级的资源"><a href="#应用下与src-web同级的资源" class="headerlink" title="应用下与src,web同级的资源"></a>应用下与src,web同级的资源</h4><ul>
<li>获取不到，因为这个位置最后不会发布到web应用中</li>
</ul>
<h3 id="获取全局配置信息"><a href="#获取全局配置信息" class="headerlink" title="获取全局配置信息"></a>获取全局配置信息</h3><ul>
<li><code>String getInitParameter(String name)</code></li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code></li>
<li>全局配置信息在web.xml中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><ul>
<li><code>RequestDispatcher getRequestDispatcher(String path)</code></li>
</ul>
<h1 id="Request-请求"><a href="#Request-请求" class="headerlink" title="Request(请求)"></a>Request(请求)</h1><h2 id="体系-1"><a href="#体系-1" class="headerlink" title="体系"></a>体系</h2><ul>
<li><code>ServletRequest</code><ul>
<li><code>HttpServletRequest</code><ul>
<li><code>org.apache.catalina.connector.RequestFacade</code><ul>
<li>tomcat的实现类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><h3 id="1-获取请求信息"><a href="#1-获取请求信息" class="headerlink" title="1. 获取请求信息"></a>1. 获取请求信息</h3><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><ul>
<li><strong><code>String getContextPath()</code></strong><ul>
<li>获取虚拟目录</li>
</ul>
</li>
<li><code>getServletPath()</code><ul>
<li>获取servlet路径</li>
</ul>
</li>
<li><code>getMethod()</code><ul>
<li>获取请求方法名</li>
</ul>
</li>
<li><code>getRequestURL()</code></li>
<li><code>getRequestURI()</code></li>
<li><code>getQueryString()</code><ul>
<li>获取get请求参数</li>
</ul>
</li>
<li><code>String getProtocol()</code><ul>
<li>获取协议及版本<code>HTTP/1.1</code></li>
</ul>
</li>
<li><code>getRomoteAddr()</code><ul>
<li>获取访问的客户端的ip地址</li>
</ul>
</li>
</ul>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><ul>
<li><code>String getHeader(String name)</code></li>
<li><code>Enumeration&lt;String&gt; getHeaderNames()</code></li>
</ul>
<h4 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h4><ul>
<li>只有post请求才有请求体，post请求将请求体封装成了流，所以要获取请求体，<ol>
<li>先要获取流</li>
<li>然后从流中获取数据</li>
</ol>
</li>
<li><code>BufferedReader getReader()</code></li>
<li><code>ServletInputStream getInputStream()</code></li>
</ul>
<h3 id="2-其它功能"><a href="#2-其它功能" class="headerlink" title="2. 其它功能"></a>2. 其它功能</h3><h4 id="通用获取请求参数"><a href="#通用获取请求参数" class="headerlink" title="通用获取请求参数"></a>通用获取请求参数</h4><ul>
<li><strong><code>String getParameter(String name)</code></strong><ul>
<li>根据请求name获取value</li>
</ul>
</li>
<li><code>Map&lt;String,String[]&gt; getParameterMap()</code><ul>
<li>获取所有请求的键值map</li>
</ul>
</li>
<li><code>String[] getParameterValues(String name)</code><ul>
<li>根据请求name获取value数组</li>
</ul>
</li>
<li><code>Enumeration&lt;String&gt; getParameterNames()</code><ul>
<li>获取所有请求name的枚举</li>
</ul>
</li>
</ul>
<h5 id="请求乱码问题"><a href="#请求乱码问题" class="headerlink" title="请求乱码问题"></a>请求乱码问题</h5><h6 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h6><ul>
<li>tomcat8以后已经将get乱码解决了</li>
</ul>
<h6 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h6><ul>
<li><code>void setCharacterEncoding(String env)</code><ul>
<li>告诉服务器用什么编码接收请求参数</li>
<li>获取参数前设置</li>
</ul>
</li>
</ul>
<h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><ul>
<li><code>RequestDispatcher getRequestDispatcher(String path)</code><ul>
<li>获取RequestDispatcher对象</li>
</ul>
</li>
</ul>
<h5 id="RequestDispatcher"><a href="#RequestDispatcher" class="headerlink" title="RequestDispatcher"></a>RequestDispatcher</h5><ul>
<li><code>void forward(ServletRequest req, ServletResponse res)</code></li>
<li><code>void include(ServletRequest req, ServletResponse res)</code></li>
</ul>
<h4 id="域对象-1"><a href="#域对象-1" class="headerlink" title="域对象"></a>域对象</h4><ul>
<li><code>void setAttribute(String name, Object obj)</code></li>
<li><code>Object getAttribute(String name)</code></li>
<li><code>void removeAttribute(String name)</code></li>
</ul>
<h4 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h4><ul>
<li><code>ServletContext getServletContext()</code></li>
</ul>
<h1 id="Response-响应"><a href="#Response-响应" class="headerlink" title="Response(响应)"></a>Response(响应)</h1><h2 id="体系-2"><a href="#体系-2" class="headerlink" title="体系"></a>体系</h2><ul>
<li><code>ServletResponse</code><ul>
<li><code>HttpServletResponse</code></li>
</ul>
</li>
</ul>
<h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><ul>
<li><code>void setStatus(int sc)</code><ul>
<li>设置状态码</li>
</ul>
</li>
</ul>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><ul>
<li><code>void setHeader(String name, String value)</code></li>
</ul>
<h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><ul>
<li>步骤<ol>
<li>获取输出流</li>
<li>使用输出流将数据输出到客户端浏览器</li>
</ol>
</li>
<li>特点<ul>
<li>response获取的流不用关，tomcat会帮我们关</li>
<li>getWriter()和getOutputStream()不能同时用</li>
</ul>
</li>
<li><code>ServletOutputStream getOutputStream()</code></li>
<li><code>PrintWriter getWriter()</code></li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li>完成重定向需要<ol>
<li><code>response.setStatus(302)</code><ul>
<li>告诉客户端需要重定向</li>
</ul>
</li>
<li><code>response.setHeander(&quot;location&quot;, String path)</code><ul>
<li>告诉客户端重定向的地址</li>
</ul>
</li>
</ol>
</li>
<li><strong>简化</strong><ul>
<li><code>response.sendRedirect(String path)</code></li>
</ul>
</li>
</ul>
<h3 id="响应乱码问题"><a href="#响应乱码问题" class="headerlink" title="响应乱码问题"></a>响应乱码问题</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ol>
<li>响应流不是我们自己创建的，而是由tomcat获取的，默认编码是<code>iso-8859-1</code></li>
<li>浏览器解码的码表不确定，可能与响应数据码表不一致</li>
</ol>
<ul>
<li>所以要解决乱码<ol>
<li>设置响应数据的码表</li>
<li>使浏览器的码表与响应数据的码表一致</li>
</ol>
</li>
</ul>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li><code>response.setChracterEncoding(&quot;utf-8&quot;)</code><ul>
<li>设置响应数据编码方式</li>
</ul>
</li>
<li><code>response.setheader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;)</code><ul>
<li>设置响应数据类型及浏览器解码方式</li>
</ul>
</li>
<li><strong>简化</strong><ul>
<li><code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code><ul>
<li>封装了上边两个方法.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="转发-amp-重定向"><a href="#转发-amp-重定向" class="headerlink" title="转发 &amp; 重定向"></a>转发 &amp; 重定向</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="转发-1"><a href="#转发-1" class="headerlink" title="转发"></a>转发</h3><ol>
<li>一次请求</li>
<li>浏览器地址栏不变</li>
<li>转发只能访问当前服务器下的资源</li>
</ol>
<h3 id="重定向-1"><a href="#重定向-1" class="headerlink" title="重定向"></a>重定向</h3><ol>
<li>二次请求</li>
<li>浏览器地址栏改变</li>
<li>重定向可以访问其它站点(服务器)下的资源</li>
</ol>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h3 id="转发-2"><a href="#转发-2" class="headerlink" title="转发"></a>转发</h3><ul>
<li><code>request.getRequestDispatcher(String path).forward(req,res)</code><ul>
<li><code>path</code><ul>
<li>是在服务器内部进行的，是给服务器使用的，路径不需要写<code>虚拟目录名</code><ul>
<li>可以理解为<code>/</code>就代表<code>http://localhost:8080/虚拟目录名</code></li>
</ul>
</li>
<li>若地址前不写<code>/</code>,代表相对路径，相对当前文件路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="重定向-2"><a href="#重定向-2" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li><code>response.sendRedirect(String path)</code><ul>
<li>path<ul>
<li>是在客户端浏览器执行的，是给客户端使用的，需要加`虚拟目录名<ul>
<li>可以理解为”/“<code>代表的是</code><a href="http://localhost:8080/`" target="_blank" rel="noopener">http://localhost:8080/`</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>重定向或者转发后，后边的代码还会执行，但通常不会写</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-JDBC/" itemprop="url">
                  xd-JDBC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:38:09" itemprop="dateCreated datePublished" datetime="2018-12-11T00:38:09+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-24 14:50:09" itemprop="dateModified" datetime="2018-12-24T14:50:09+08:00">2018-12-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>Java DataBase Connectivity</code></li>
<li>SUN公司提供的一套操作数据库的标准规范</li>
<li>是一种用于执行SQL语句的Java API,是一种技术规范，可以方便连接各种常用数据库。</li>
<li>数据库提供的驱动<code>.jar</code>文件实现了jdbc接口。</li>
<li>JDBC主要完成三件事<ul>
<li>建立连接</li>
<li>发送SQL语句</li>
<li>处理返回的结果</li>
</ul>
</li>
</ul>
<h1 id="核心接口类"><a href="#核心接口类" class="headerlink" title="核心接口类"></a>核心接口类</h1><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><ul>
<li>驱动管理对象。用于注册驱动</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>static void registerDriver(Driver driver)</code><ul>
<li>注册驱动</li>
</ul>
</li>
<li><code>static Connection getConnection(String url)</code><ul>
<li>user和password用参数的形式写在url上</li>
</ul>
</li>
<li><code>static Connection getConnection(String url, Properties prop)</code><ul>
<li>将信息写入一个properties集合中</li>
</ul>
</li>
<li><code>static Connection getConnection(String url, String user, String password)</code></li>
</ul>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ul>
<li>数据库连接对象</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>Statement createStatement()</code></li>
<li><code>PreparedStatement prepareStatement(String sql)</code></li>
<li><code>CallableStatement prepareCall(String sql)</code><ul>
<li>用于执行对数据库存储过程的调用</li>
</ul>
</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li><code>void setAutoCommit(boolean autoCommit)</code><ul>
<li>将自动提交设置为false即视为开启事务。</li>
</ul>
</li>
<li><code>void commit()</code></li>
<li><code>void rollback()</code></li>
<li><code>void setTransactionIsolation(int level)</code><ul>
<li>设置隔离级别(必须在开启事务之前)<ul>
<li>level 常量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><ul>
<li>用于执行静态 SQL 语句并返回它所生成结果的对象</li>
</ul>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>ResultSet executeQuery(String sql)</code><ul>
<li>根据查询(select)语句，返回结果集</li>
</ul>
</li>
<li><code>int executeUpdate(String sql)</code><ul>
<li>根据执行的DML（insert update delete）语句，返回受影响的行数。</li>
</ul>
</li>
<li><code>boolean execute(String sql)</code><ul>
<li>可以执行任意sql语句。返回boolean值，表示是否返回ResultSet结果集。</li>
<li>仅当执行select语句，且有返回结果时返回true, 其它语句都返回false;</li>
</ul>
</li>
</ul>
<h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><ul>
<li>预编译对象。</li>
<li>性能高，会预编译sql语句。</li>
<li>是<code>Statement</code>子接口</li>
</ul>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>ResultSet executeQuery()</code></li>
<li><code>int executeUpdate()</code></li>
<li><code>boolean execute()</code></li>
<li><code>setXxx(int index, Xxx value)</code><ul>
<li>为占位符参数赋值，index从1开始</li>
</ul>
</li>
</ul>
<h3 id="Sql注入"><a href="#Sql注入" class="headerlink" title="Sql注入"></a>Sql注入</h3><ul>
<li><code>x&#39; or &#39;a&#39;=&#39;a</code><ul>
<li>使用字符串拼接，导致判断条件总是为true，安全隐患</li>
</ul>
</li>
</ul>
<h3 id="PreparedStatement解决sql注入"><a href="#PreparedStatement解决sql注入" class="headerlink" title="PreparedStatement解决sql注入"></a>PreparedStatement解决sql注入</h3><ul>
<li>sql语句中用<code>?</code>作为占位符</li>
<li>给<code>?</code>赋值(根据类型)<ul>
<li><code>setXxx(int index, value)</code></li>
</ul>
</li>
</ul>
<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><ul>
<li>表示数据库结果集的数据表</li>
<li>提供一个游标，默认游标指向结果集第一行之前</li>
</ul>
<h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>boolean next()</code><ul>
<li>将光标从当前位置向下移一行</li>
</ul>
</li>
<li>每个可能的数据类型都有一个get方法，每个get方法有两个版本<ul>
<li><code>rs.getInt(&quot;id&quot;)</code><ul>
<li>一个是采用列名称。</li>
</ul>
</li>
<li><code>rs.getInt(1)</code><ul>
<li>另一个采用列索引。</li>
<li>注意索引从1开始</li>
</ul>
</li>
<li>不确定类型也可以用Object<ul>
<li><code>rs.getObject(&quot;id&quot;)</code></li>
<li><code>rs.getObject(1)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="不同数据库的-driver-amp-url"><a href="#不同数据库的-driver-amp-url" class="headerlink" title="不同数据库的 driver &amp; url"></a>不同数据库的 driver &amp; url</h1><table>
<thead>
<tr>
<th>数据库</th>
<th>JDBC驱动程序名称</th>
<th>URL格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL</td>
<td><code>com.mysql.jdbc.Driver</code></td>
<td><code>jdbc:mysql://hostname/databaseName</code></td>
</tr>
<tr>
<td>ORACLE</td>
<td><code>oracle.jdbc.driver.OracleDriver</code></td>
<td><code>jdbc:oracle:thin:@hostname:portNumber:databaseName</code></td>
</tr>
<tr>
<td>PostgreSQL</td>
<td><code>org.postgresql.Driver</code></td>
<td><code>jdbc:postgresql://hostname:port/dbname</code></td>
</tr>
<tr>
<td>DB2</td>
<td><code>com.ibm.db2.jdbc.net.DB2Driver</code></td>
<td><code>jdbc:db2:hostname:port Number/databaseName</code></td>
</tr>
<tr>
<td>Sybase</td>
<td><code>com.sybase.jdbc.SybDriver</code></td>
<td><code>jdbc:sybase:Tds:hostname: portNumber/databaseName</code></td>
</tr>
</tbody>
</table>
<h1 id="JDBC使用步骤"><a href="#JDBC使用步骤" class="headerlink" title="JDBC使用步骤"></a>JDBC使用步骤</h1><ol>
<li>导入数据库驱动包</li>
<li>注册JDBC驱动<ol>
<li>(不推荐)<ul>
<li><code>void DriverManager.registerDriver(Driver driver)</code><ul>
<li>会造成DriverManager中产生两个一样的驱动<ul>
<li>装载Driver类(Driver类中有静态代码块，调用了<code>registerDriver</code>方法)时注册一次驱动，执行此代码时，又注册一次</li>
</ul>
</li>
<li>对具体的驱动类产生依赖<ul>
<li>由于实例化了<code>com.mysql.jdbc.Driver.class</code>，导致必须import该类，从而具体驱动产生了依赖。不方便扩展代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>(推荐)<ul>
<li><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code><ul>
<li>Driver类一加载，就会执行静态代码块中的注册方法。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>获取连接Connection</li>
<li>执行sql语句，获取结果集<ol>
<li><code>Statement</code>（不推荐）<ol>
<li>书写静态sql语句</li>
<li><code>Statement createStatement()</code><ul>
<li>使用连接创建Statement对象</li>
</ul>
</li>
<li>使用Statement对象执行静态sql语句，获取结果集</li>
</ol>
</li>
<li><code>PreparedStatement</code>（推荐）<ol>
<li>书写动态sql语句</li>
<li><code>PreparedStatement prepareStatement(String sql)</code><ul>
<li>使用连接创建PreparedStatement对象</li>
</ul>
</li>
<li>使用PreparedStatement对象为动态sql设置参数</li>
<li>执行，获取结果集</li>
</ol>
</li>
</ol>
</li>
<li>处理结果</li>
<li>关闭资源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if (rs != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        rs.close();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    rs=null;</span><br><span class="line">&#125;</span><br><span class="line">if (ps != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    ps=null;</span><br><span class="line">&#125;</span><br><span class="line">if (conn != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    conn=null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-SQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-SQL/" itemprop="url">
                  xd-SQL
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:37:56" itemprop="dateCreated datePublished" datetime="2018-12-11T00:37:56+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 23:10:56" itemprop="dateModified" datetime="2018-12-26T23:10:56+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>Structure Query Language</code></li>
<li><ul>
<li>第一代：机器语言</li>
<li>第二代：汇编        </li>
<li>第三代：C/C++/C#/Java/VB/…</li>
<li>第四代：SQL【结构化查询语言，面向关系的】</li>
</ul>
</li>
<li>SQL92/【99】标准的四大分类<ul>
<li>DDL(数据定义语言Data Definition Language)<ul>
<li><code>create alter drop truncate</code></li>
<li>用来操作库,表…</li>
</ul>
</li>
<li>DML(数据操纵语言Data Manipulation Language)<ul>
<li><code>insert update delete</code></li>
<li>用来操作数据</li>
</ul>
</li>
<li>DQL (数据查询语言Data Query Language) <ul>
<li>select</li>
</ul>
</li>
<li>DCL(数据控制语言 Data Control Language)<ul>
<li><code>grant revoke</code></li>
</ul>
</li>
<li>TCL(事务控制语言)(自定义的。。。)<ul>
<li><code>commit，rollback，rollback to savepoint 。。。</code></li>
</ul>
</li>
</ul>
</li>
<li>sql的注释<ul>
<li><code>--</code><ul>
<li>单行</li>
</ul>
</li>
<li><code>/* */</code><ul>
<li>多行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>存储数据的仓库</li>
<li>高效的存储和处理数据的介质（介质：磁盘和内存）</li>
</ul>
<h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><ul>
<li>DBS<ul>
<li><code>Database System</code></li>
<li><code>DBS = DBMS + DB</code></li>
</ul>
</li>
<li>DBMS<ul>
<li><code>Database Management System</code></li>
<li>数据库管理系统</li>
</ul>
</li>
<li>DBA<ul>
<li><code>Database Administrator</code></li>
<li>数据库管理员</li>
</ul>
</li>
<li><code>行/记录</code><ul>
<li><code>row/record</code></li>
<li>本质是一个东西: 都是指表中的一行(一条记录)</li>
<li>行是从结构角度出发</li>
<li>记录是从数据角度出发</li>
</ul>
</li>
<li><code>列/字段</code><ul>
<li><code>column/field</code></li>
<li>本质是一个东西</li>
</ul>
</li>
</ul>
<h2 id="分类（按介质）"><a href="#分类（按介质）" class="headerlink" title="分类（按介质）"></a>分类（按介质）</h2><h3 id="关系型数据库（SQL）"><a href="#关系型数据库（SQL）" class="headerlink" title="关系型数据库（SQL）"></a>关系型数据库（SQL）</h3><ul>
<li>安全（保存磁盘不易丢失）容易理解，浪费空间（二维表）</li>
<li><code>Oracle DB2</code></li>
<li><code>Sql-Server Mysql</code></li>
<li><code>access</code></li>
</ul>
<h3 id="非关系型数据库（NoSQL：not-only-sql）"><a href="#非关系型数据库（NoSQL：not-only-sql）" class="headerlink" title="非关系型数据库（NoSQL：not only sql）"></a>非关系型数据库（NoSQL：not only sql）</h3><ul>
<li>效率高，不安全（断电丢失）</li>
<li><code>memcached mongodb redis</code></li>
</ul>
<h1 id="Mysql概述"><a href="#Mysql概述" class="headerlink" title="Mysql概述"></a>Mysql概述</h1><ul>
<li>是一种c/s结构的软件：若想访问服务器，必须通过客户端（服务器一直运行，客户端在需要时运行）</li>
<li><code>mysql.exe</code><ul>
<li>mysql自带客户端</li>
</ul>
</li>
<li><code>mysqld.exe</code><ul>
<li>服务端</li>
</ul>
</li>
</ul>
<h2 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h2><ol>
<li>客户端连接认证<ul>
<li>连接服务器</li>
<li>认证身份<ul>
<li><code>mysql.exe -hPup</code><ul>
<li><code>mysql.exe -hlocalhost -p3306 -uroot -proot</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>发送sql指令</li>
<li>服务器接收sql指令<ul>
<li>处理sql指令，返回操作结果</li>
</ul>
</li>
<li>客户端接收结果，显示结果</li>
<li>断开连接（释放资源：服务器并发限制）<ul>
<li><code>exit/quit/\q</code></li>
</ul>
</li>
</ol>
<h2 id="mysql服务器对象"><a href="#mysql服务器对象" class="headerlink" title="mysql服务器对象"></a>mysql服务器对象</h2><ul>
<li>没有办法完全了解服务器内部的内容：只能粗略去分析数据库服务器的内部结构</li>
<li>分为四层<ul>
<li>系统（DBMS）</li>
<li>数据库（DB）</li>
<li>数据表（Table）</li>
<li>字段（Field）</li>
</ul>
</li>
</ul>
<h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><ol>
<li>配置环境变量</li>
<li><p>配置mysql目录下的<code>.ini</code>配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//安装目录</span><br><span class="line">basedir =C:/soft/mysql-5.7.18-winx64</span><br><span class="line">//data目录</span><br><span class="line">datadir =C:/soft/mysql-5.7.18-winx64/data</span><br><span class="line">port = 3306</span><br><span class="line">character-set-server=utf8</span><br><span class="line">character_set_filesystem=utf8</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
<ul>
<li>注<ul>
<li>mysql解压版没有data目录</li>
<li>初始化后会出现data目录</li>
</ul>
</li>
</ul>
</li>
<li>初始化<ul>
<li><strong>windows</strong><ul>
<li><code>mysqld --initialize</code><ul>
<li>随机密码</li>
</ul>
</li>
<li><code>mysqld --initialize-insecure</code><ul>
<li>无密码</li>
</ul>
</li>
</ul>
</li>
<li><strong>unix</strong><ul>
<li><code>mysqld --initialize-insecure --user=mysql</code><ul>
<li>无密码</li>
</ul>
</li>
<li><code>mysqld --initialize --user=mysql --console</code><ul>
<li>有密码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>服务<ul>
<li><code>mysqld --install</code><ul>
<li>将MySQL添加到系统服务</li>
<li><code>Service successfully installed</code>服务安装成功。</li>
</ul>
</li>
<li><code>net start mysql</code><ul>
<li>启动服务</li>
</ul>
</li>
<li><code>net stop mysql</code><ul>
<li>停止服务</li>
</ul>
</li>
<li><code>mysqld remove</code> &amp; <code>sc delete mysql</code>？<ul>
<li>移除服务</li>
</ul>
</li>
</ul>
</li>
<li>登陆<ul>
<li><code>mysql -uroot -p</code><ul>
<li><code>msql&gt;</code>登录成功</li>
</ul>
</li>
</ul>
</li>
<li>修改密码<ul>
<li><code>alter user &#39;root&#39; @&#39;localhost&#39; identified by &#39;root&#39;;;</code><ul>
<li>将登陆账户密码修改为root</li>
</ul>
</li>
</ul>
</li>
<li>退出<ul>
<li><code>exit</code></li>
</ul>
</li>
<li>其它操作<ul>
<li><code>\c</code><ul>
<li>输错了想结束</li>
</ul>
</li>
<li><code>tee D;/xx.sql;</code><ul>
<li>存储输入的sql到xx.sql文件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="SQL基本操作"><a href="#SQL基本操作" class="headerlink" title="SQL基本操作"></a>SQL基本操作</h1><ul>
<li><code>CRUD</code></li>
<li>按操作对象分为<ul>
<li>库操作</li>
<li>表操作（字段）</li>
<li>数据操作</li>
</ul>
</li>
</ul>
<h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li><code>create database 库名 [库选项]</code><ul>
<li>数据库名<ul>
<li>不要用关键字和保留字</li>
<li>非要用的话使用单引号包括关键字</li>
</ul>
</li>
<li>库选项：用来约束数据库<ul>
<li>字符集设定<ul>
<li><code>charset/character set 字符集(数据存储的编码格式)</code></li>
</ul>
</li>
<li>校对设定<ul>
<li><code>collate 校对集(数据比较的规则)</code></li>
<li>校对集依赖字符集</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>创建数据库sql语句执行后<ol>
<li>在数据库系统中,增加了对应的数据库信息</li>
<li>在保存数据的文件夹（Data目录）下，创建一个对应数据库名字的文件夹</li>
<li>每个数据库下都有一个opt文件: 保存了库选项</li>
</ol>
</li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li><code>drop database 库名</code></li>
<li>删除数据库sql语句执行之后<ol>
<li>在数据库内部看不到对应的数据库</li>
<li>Data目录下，数据库名字对应的文件夹也被删除（级联删除：里面的数据表全部删除）<ul>
<li>删除不可逆</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul>
<li>数据库的修改<ul>
<li>名字不可修改</li>
<li>仅限库选项：字符集和校对集</li>
</ul>
</li>
<li><code>alter database 库名 [库选项];</code><ul>
<li><code>charset/character set [=] 字符集</code></li>
<li><code>collate 校对集</code></li>
</ul>
</li>
</ul>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li><code>show databases</code><ul>
<li>查看所有数据库</li>
</ul>
</li>
<li><code>show databases like &#39;pattern&#39;</code><ul>
<li>查看部分数据库</li>
<li><code>pattern</code>：匹配模式<ul>
<li><code>%</code><ul>
<li>匹配多个</li>
</ul>
</li>
<li><code>_</code><ul>
<li>匹配一个</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>show create database 库名</code><ul>
<li>查看数据库的创建语句</li>
</ul>
</li>
</ul>
<h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><ul>
<li>任何一个表的设计都必须指定数据库。<ol>
<li>显示的指定表所属数据库<ul>
<li><code>create table 库名.表明();</code></li>
</ul>
</li>
<li>隐式的指定所属数据库：先进入数据库<ul>
<li><code>use 库名;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table [if not exists] 表名(</span><br><span class="line">	字段名 数据类型,</span><br><span class="line">	字段名 数据类型	-- 最后一行不需要逗号</span><br><span class="line">)[表选项]</span><br></pre></td></tr></table></figure>
<ul>
<li>表选项：控制表的表现<ul>
<li>字符集<ul>
<li><code>charset/character set 字符集</code></li>
</ul>
</li>
<li>校对集<ul>
<li><code>collate 校对集</code></li>
</ul>
</li>
<li>存储引擎<ul>
<li><code>engine 存储引擎(innodb 和 myisam)</code></li>
</ul>
</li>
</ul>
</li>
<li>创建数据表的SQL指令执行之后<ol>
<li>指定数据库下已经存在对应的表</li>
<li>在数据库对应的文件夹下,会产生对应表的结构文件(跟存储引擎有关系)<ul>
<li><code>xxx.frm ...</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h3><ul>
<li><code>drop table 表名1,表名2...</code></li>
<li>删除数据表的SQL指令执行之后<ol>
<li>在表空间中,没有了指定的表(数据也没有了)</li>
<li>在数据库对应的文件夹下, 表对应的文件(与存储引擎有关)也会被删除</li>
</ol>
</li>
</ul>
<h3 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h3><ul>
<li>表的修改<ol>
<li>表本身<ul>
<li>表名</li>
<li>表选项<ul>
<li>字符集</li>
<li>校对集</li>
<li>存储引擎</li>
</ul>
</li>
</ul>
</li>
<li>字段<ul>
<li>增</li>
<li>删</li>
<li>改</li>
<li>重命名</li>
</ul>
</li>
</ol>
</li>
<li><code>rename table 表名 to 新表名</code></li>
<li><code>alter table 表名 表选项 [=] 值</code><ul>
<li>修改表选项</li>
</ul>
</li>
<li><code>alter table 表名 add [column] 字段名 数据类型 [列属性] [位置]</code><ul>
<li>新增字段</li>
<li>位置<ul>
<li>字段可以存放表中的任意位置</li>
<li><code>first</code></li>
<li><code>after</code><ul>
<li>默认再最后一个字段之后</li>
<li><code>after 字段名</code>新增到哪个字段之后</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>alter table 表名 drop 字段名</code><ul>
<li>删除字段</li>
</ul>
</li>
<li><code>alter table 表名 modify 字段名 数据类型 [列属性] [位置]</code><ul>
<li>修改字段</li>
</ul>
</li>
<li><code>alter table 表名 change 字段名 新字段名 数据类型 [列属性] [位置]</code><ul>
<li>重命名字段</li>
</ul>
</li>
</ul>
<h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><ul>
<li><code>show tables</code></li>
<li><code>show tables like &#39;pattern&#39;</code></li>
<li><code>show create table 表名</code><ul>
<li><code>\g</code><ul>
<li>横向显示</li>
</ul>
</li>
<li><code>\G</code><ul>
<li>纵向显示</li>
</ul>
</li>
</ul>
</li>
<li><code>desc/describe/show columns from 表名</code><ul>
<li>查看表中字段</li>
</ul>
</li>
</ul>
<h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h3><ul>
<li><code>insert into 表名 values(值列表)[,(值列表)]</code><ul>
<li>给全表字段插入数据，不需要指定字段列表<ul>
<li>值数据顺序与表字段顺序一致</li>
<li>非数值数据，都要使用引号(建议单引号)</li>
</ul>
</li>
<li>可以一次性插入多条记录</li>
</ul>
</li>
<li><code>insert into 表名(字段列表) values(值列表)[,(值列表)]</code><ul>
<li>插入指定字段</li>
</ul>
</li>
</ul>
<h3 id="删-2"><a href="#删-2" class="headerlink" title="删"></a>删</h3><ul>
<li><code>delete from 表名 [where条件]</code></li>
<li><code>truncate 表名;</code><ul>
<li>清空表</li>
</ul>
</li>
<li>truncate和delete区别<ul>
<li>DELETE 删除表中的数据，表结构还在，删除后的数据可以找回<ul>
<li>如果表中存在主键自增长,那么当删除之后, 自增长不会还原</li>
</ul>
</li>
<li>TRUNCATE 是把表直接DROP掉，然后再创建一个同样数据结构的新表</li>
</ul>
</li>
</ul>
<h3 id="改-2"><a href="#改-2" class="headerlink" title="改"></a>改</h3><ul>
<li><code>update 表名 set 字段 = 值 [where条件]</code><ul>
<li>更新不一定会成功: 如没有真正要更新的数据</li>
</ul>
</li>
</ul>
<h3 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h3><ul>
<li><code>select */字段列表 from 表名 [where条件]</code></li>
</ul>
<h1 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h3><ul>
<li><strong><code>tinyint</code></strong><ul>
<li>1个字节 </li>
</ul>
</li>
<li><code>smallint</code><ul>
<li>2个字节</li>
</ul>
</li>
<li><code>mediumint</code><ul>
<li>3个字节</li>
</ul>
</li>
<li><strong><code>int</code></strong><ul>
<li>4个字节</li>
</ul>
</li>
<li><code>bigint</code><ul>
<li>8个字节</li>
</ul>
</li>
</ul>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h5><ul>
<li><code>字段名 数值型 unsigned</code><ul>
<li>无符号 从0开始</li>
<li>sql中的数值型默认都是有符号的。<ul>
<li>一个字节有符号<code>-128 ~ 127</code></li>
<li>一个字节无符号<code>0 ~ 255</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="M-amp-zerofill"><a href="#M-amp-zerofill" class="headerlink" title="(M) &amp; zerofill"></a>(M) &amp; zerofill</h5><ul>
<li><code>字段名 整型(M) zerofill</code><ul>
<li><code>(M)</code><ul>
<li>总共M位数（包含符号）</li>
<li>与<code>zerofill</code>配合使用才有意义（不足M位的用0补）</li>
</ul>
</li>
<li><code>zerofill</code><ul>
<li>用零填充</li>
<li>如果声明零填充，则会自动声明为<code>unsigned</code>无符号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="小数型"><a href="#小数型" class="headerlink" title="小数型"></a>小数型</h3><ul>
<li>浮点型<ul>
<li>小数点浮动, 精度有限,而且会丢失精度</li>
<li>整数部分不能超出长度（整数部分可能会被四舍五入进位），小数部分可以（系统自动四舍五入）<ul>
<li>如果因为系统四舍五入使整数部分超出长度也可以</li>
</ul>
</li>
</ul>
</li>
<li>定点型<ul>
<li>小数点固定, 精度固定, 不会丢失精度</li>
<li>整数部分不能超出长度（整数部分不会被四舍五入进位），小数部分可以（系统自动四舍五入）<ul>
<li>如果因为系统四舍五入使整数部分超出长度不可以</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><ul>
<li><code>float</code><ul>
<li>单精度 4个字节</li>
</ul>
</li>
<li><code>double</code><ul>
<li>双精度 8个字节</li>
</ul>
</li>
</ul>
<h4 id="定点型"><a href="#定点型" class="headerlink" title="定点型"></a>定点型</h4><ul>
<li><code>decimal</code><ul>
<li>变长，大致每9个数字采用4个字节存储，整数小数分开计算。</li>
</ul>
</li>
</ul>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><h5 id="unsigned-1"><a href="#unsigned-1" class="headerlink" title="unsigned"></a>unsigned</h5><h5 id="M-D-amp-zerofill"><a href="#M-D-amp-zerofill" class="headerlink" title="(M,D) &amp; zerofill"></a>(M,D) &amp; zerofill</h5><ul>
<li><code>字段名 小数型(M,D)</code><ul>
<li>M<ul>
<li>精度 表示总位数</li>
</ul>
</li>
<li>D<ul>
<li>标度 表示小数部分位数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ul>
<li><code>char</code><ul>
<li>定长字符串，磁盘（二维表）再定义结构时，就已经确定了最终数据的存储长度。</li>
<li><code>char(L)</code><ul>
<li>L表示存储长度(字符数)，单位为字符</li>
<li>最大长度255</li>
<li>char存储时如果不够L个字符，则内部用空格补齐，取出时去掉右侧空格。速度比varchar快。<ul>
<li>如果存的数据右侧本身带空格，会丢失。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>varchar</code><ul>
<li>变长字符串，在分配空间时按照最大的空间分配，但实际使用空间根据具体数据来确定。</li>
<li><code>varchar(L)</code><ul>
<li>最大长度65536</li>
<li>varcar存储时在列内容前，用1-2个字节来标志该列的内容长度。<ul>
<li>这样知道长度，才知道取值时到哪里结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
<th>可存字符</th>
<th>实存字符(i&lt;=M)</th>
<th>实占空间</th>
<th>利用率</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>M</td>
<td>M</td>
<td>i</td>
<td>M*3字节</td>
<td>i/M&lt;=100%</td>
</tr>
<tr>
<td>varchar</td>
<td>M</td>
<td>M</td>
<td>i</td>
<td>i*3+(1~2)字节</td>
<td>i/i+(1~2)&lt;=100%</td>
</tr>
</tbody>
</table>
<ul>
<li>定长与变长的选择<ul>
<li>定长磁盘空间比较浪费，但效率高，如果数据确定长度一致<ul>
<li>身份证，电话，手机号</li>
</ul>
</li>
<li>变长磁盘空间比较节省，但效率低，如果数据不能确定长度</li>
</ul>
</li>
<li><strong>nchar &amp; nvarchar</strong><ul>
<li>前缀n表示Unicode字符</li>
<li>使用Unicode字符，即所有字符都占两个字节</li>
<li>char &amp; varchar<ul>
<li>最多8000个英文，4000个汉字</li>
</ul>
</li>
<li>nchar &amp; nvarchar<ul>
<li>可存储4000个字符，无论英文还是汉字</li>
</ul>
</li>
<li>(网)<ul>
<li>如果纯英文数字<ul>
<li>char varchar</li>
</ul>
</li>
<li>如果有中文<ul>
<li>nchar nvarchar</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>text</code><ul>
<li>长文本数据</li>
<li>如果数据超过255个字符</li>
<li>存储二进制数据<ul>
<li>实际上都是存储路径</li>
</ul>
</li>
</ul>
</li>
<li><code>blob</code><ul>
<li>二进制形式的长文本数据（图像,音频等二进制信息）(通常不用)</li>
<li>防止因为字符集的问题导致信息丢失。</li>
</ul>
</li>
<li><code>enum</code><ul>
<li>枚举</li>
<li>事先将所有可能的结果设计好，实际存储数据必须是规定好的数据之一。</li>
<li>枚举存储的数据是数值，节省空间</li>
<li>定义<ul>
<li><code>enum(可能出现的元素列表)</code><ul>
<li><code>enum(&#39;value1&#39;,&#39;value2&#39;,...)</code></li>
</ul>
</li>
</ul>
</li>
<li>使用<ul>
<li>只能添加给出的枚举值中的一个</li>
<li>可以直接插入数值</li>
</ul>
</li>
<li>原理<ul>
<li>枚举在进行数据规范的时候(定义的时候),系统会自动建立一个数字与枚举元素的对应关系(关系放到日志中): 然后在进行数据插入的时候,系统自动将字符转换成对应的数字存储, 然后在进行数据提取的时候, 系统自动将数值转换成对应的字符串显示</li>
<li>从1开始编号，最大65535</li>
</ul>
</li>
</ul>
</li>
<li><code>set</code><ul>
<li>集合类似枚举，实际存储的是整型数值而不是字符串。集合是多选。</li>
<li>定义<ul>
<li><code>set(元素列表)</code></li>
</ul>
</li>
<li>使用<ul>
<li>一次插入可以选其中一个值，也可以选多个值(<code>,</code>隔开)</li>
<li>可以直接插入数值</li>
</ul>
</li>
<li>原理<ul>
<li>类似枚举，集合中每一个元素都是对应一个二进制位<ul>
<li>被选中为1，未选中0，最后反过来就是最终的数值</li>
</ul>
</li>
<li>插入元素的顺序没有关系: 最终系统都会去匹配集合，匹配到的置为1.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="时间日期类型"><a href="#时间日期类型" class="headerlink" title="时间日期类型"></a>时间日期类型</h2><ul>
<li><code>date</code><ul>
<li>日期 <code>yyyy-mm-dd</code></li>
</ul>
</li>
<li><code>time</code><ul>
<li>时间（段） <code>hh:mm:ss</code></li>
<li>可以使用负数</li>
</ul>
</li>
<li><code>datetime</code><ul>
<li>日期时间 <code>yyyy-mm-dd hh:mm:ss</code></li>
<li>表示范围从1000到9999年</li>
<li>有0值<code>0000-00-00 00:00:00</code></li>
</ul>
</li>
<li><code>timestamp</code><ul>
<li>时间戳 ，并不是时间戳，只是从1970年开始的<code>yyyy-mm-dd hh:mm:ss</code></li>
<li>只要当前所在记录被更新，时间戳就会被修改为当前时间。</li>
</ul>
</li>
<li><code>year</code><ul>
<li>年份 <code>YYYY</code></li>
<li><code>year(2)</code><ul>
<li><code>1970~2069</code></li>
</ul>
</li>
<li><code>year(4)</code><ul>
<li><code>1901~2155</code></li>
<li>(0000表示错误)共255</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Mysql记录长度"><a href="#Mysql记录长度" class="headerlink" title="Mysql记录长度"></a>Mysql记录长度</h1><ul>
<li>任何一条记录最长不能超过65535个字节(varchar永远达不到理论值)<ul>
<li>varchar的实际存储长度要看字符编码<ul>
<li>utf-8：21844个字符<ul>
<li>21844*3 + 2 = 65532 + 2 = 65534</li>
</ul>
</li>
<li>gbk：32766个字符<ul>
<li>32766*2 +2 = 65532 + 2 = 65534</li>
</ul>
</li>
</ul>
</li>
<li>但是一个记录中一个varchar字段一个tiny字段会超出长度，因为null会占用一个字节。</li>
</ul>
</li>
<li>mysql记录中，如果有任何一个字段允许为空，那么系统会自动从整个记录中保留一个字节来存储NULL<ul>
<li>若想释放NULL所占用的字节: 必须保证所有的字段都不允许为空</li>
</ul>
</li>
<li>Mysql中text文本字符串,不占用记录长度: 额外存储. 但是text文本字符串也是属于记录的一部分: 一定需要占据记录中的部分长度: 10个字节(保存数据的地址以及长度).</li>
</ul>
<h1 id="列属性"><a href="#列属性" class="headerlink" title="列属性"></a>列属性</h1><h2 id="空属性"><a href="#空属性" class="headerlink" title="空属性"></a>空属性</h2><ul>
<li><code>null</code><ul>
<li>默认</li>
<li>null没有意义，且运算一律返回null，效率不高，影响索引结果，所以建表时通常<code>not null default&#39;&#39;/0/0.00</code><ul>
<li><code>null==null</code><ul>
<li><code>null</code></li>
</ul>
</li>
<li><code>null!=null</code><ul>
<li><code>null</code><ul>
<li>结果还是null，即为false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>not null</code></li>
</ul>
<h2 id="列描述"><a href="#列描述" class="headerlink" title="列描述"></a>列描述</h2><ul>
<li><code>字段名 数据类型 comment &#39;描述信息&#39;</code><ul>
<li><code>comment</code><ul>
<li>注释，没有实际含义，是专门用来描述字段，会根据表创建语句保存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><ul>
<li><code>字段名 数据类型 default 值</code></li>
<li>默认值的生效<ul>
<li>插入数据时，不给有默认值的字段插入数据</li>
</ul>
</li>
<li>使用默认值时插入数据可以使用<code>default</code>关键字</li>
</ul>
<h2 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><ul>
<li><code>primary key</code></li>
</ul>
<h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ul>
<li>非null 唯一</li>
</ul>
<h4 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h4><ol>
<li>建表时在字段后跟primary key<ul>
<li><code>字段名 数据类型 primary key</code><ul>
<li><code>id int primary key</code></li>
</ul>
</li>
<li>优点<ul>
<li>非常直接</li>
</ul>
</li>
<li>缺点<ul>
<li>只能使用一个字段作为主键</li>
</ul>
</li>
</ul>
</li>
<li><p>建表时，在所有字段后使用primary key，可以是复合主键</p>
<ul>
<li><code>primary key(主键字段列表)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id int ,</span><br><span class="line">name varchar(10),</span><br><span class="line">primary key(id,name)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>表已经创建好之后，追加主键</p>
<ul>
<li>前提<ul>
<li>表中字段对应的数据本身是独立的(不重复)</li>
</ul>
</li>
</ul>
<ol>
<li><code>alter table 表名 modify 字段名 数据类型 primary key</code><ul>
<li>通过修改表字段</li>
</ul>
</li>
<li><code>alter table 表名 add primary key(主键字段列表)</code><ul>
<li>通过给字段添加主键</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="更新主键-amp-删除主键"><a href="#更新主键-amp-删除主键" class="headerlink" title="更新主键 &amp; 删除主键"></a>更新主键 &amp; 删除主键</h4><ul>
<li>主键无法更新，必须先删除才能添加。</li>
<li>删除<ul>
<li><code>alter table 表名 drop primary key</code></li>
</ul>
</li>
</ul>
<h4 id="主键分类"><a href="#主键分类" class="headerlink" title="主键分类"></a>主键分类</h4><ul>
<li>业务主键<ul>
<li>数据的属性字段。</li>
</ul>
</li>
<li>逻辑主键<ul>
<li>实际很少使用数据属性，而是使用没有实际含义的逻辑字段</li>
</ul>
</li>
</ul>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><ul>
<li>外面的键(键不在自己表中): 如果一张表中有一个字段(非主键)指向另外一张表的主键,那么将该字段称之为外键. </li>
</ul>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><ul>
<li>外键约束有三种约束模式: 都是针对父表的约束<ul>
<li><code>District</code><ul>
<li>严格模式(默认的), 父表不能删除或者更新一个已经被子表数据引用的记录</li>
</ul>
</li>
<li><code>Cascade</code><ul>
<li>级联模式: 父表的操作, 对应子表关联的数据也跟着被删除</li>
</ul>
</li>
<li><code>Set null</code><ul>
<li>置空模式: 父表的操作之后,子表对应的数据(外键字段)被置空</li>
</ul>
</li>
</ul>
</li>
<li><code>Foreign key(外键字段) references 父表(主键字段) on delete set null on update cascade</code><ul>
<li>通常合理的做法（约束模式）<ul>
<li>删除的时候子表置空<ul>
<li>前提条件: 外键字段允许为空(如果不满足条件,外键无法创建)</li>
</ul>
</li>
<li>更新的时候子表级联操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="新增外键"><a href="#新增外键" class="headerlink" title="新增外键"></a>新增外键</h4><ol>
<li>建表时，在所有字段之后<ul>
<li><code>foreign key(外键字段) references 外部表(主键字段)</code></li>
</ul>
</li>
<li>建表后，追加外键<ul>
<li><code>Alter table 表名 add [constraint 外键名字] foreign key(外键字段) references 父表(主键字段)</code></li>
</ul>
</li>
</ol>
<h4 id="修改-amp-删除外键"><a href="#修改-amp-删除外键" class="headerlink" title="修改 &amp; 删除外键"></a>修改 &amp; 删除外键</h4><ul>
<li>外键不可修改: 只能先删除后新增.</li>
<li>删除<ul>
<li><code>Alter table 表名 drop foreign key 外键名</code> </li>
</ul>
</li>
</ul>
<h4 id="外键作用"><a href="#外键作用" class="headerlink" title="外键作用"></a>外键作用</h4><ul>
<li>对子表约束<ul>
<li>子表数据进行写操作(增和改)的时候, 如果对应的外键字段在父表找不到对应的匹配: 那么操作会失败.(约束子表数据操作)</li>
</ul>
</li>
<li>对父表约束<ul>
<li>父表数据进行写操作(删和改: 都必须涉及到主键本身), 如果对应的主键在子表中已经被数据所引用, 那么就不允许操作</li>
<li>即先删除外键所在数据，才能删除主键数据</li>
</ul>
</li>
</ul>
<h4 id="外键条件"><a href="#外键条件" class="headerlink" title="外键条件"></a>外键条件</h4><ol>
<li>外键要存在，首先必须保证表的存储引擎是innodb(默认的存储引擎)<ul>
<li>如果不是innodb存储引擎,那么外键可以创建成功,但是没有约束效果</li>
</ul>
</li>
<li>外键字段的字段类型(列类型)必须与父表的主键类型完全一致</li>
<li>一张表中的外键名字不能重复.</li>
<li>增加外键的字段(数据已经存在),必须保证数据与父表主键要求对应</li>
</ol>
<h3 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h3><ul>
<li><code>auto_increment</code></li>
<li>当对应的字段,不给值,或者说给默认值,或者给NULL的时候, 会自动的被系统触发, 系统会从当前字段中已有的最大值再进行+1操作</li>
<li>自增长通常搭配主键</li>
</ul>
<h4 id="新增自增长"><a href="#新增自增长" class="headerlink" title="新增自增长"></a>新增自增长</h4><ol>
<li>任何一个字段要做自增长必须前提是本身是一个索引(key一栏有值)</li>
<li>自增长字段必须是数字(整型)</li>
<li>3.一张表最多只能有一个自增长</li>
</ol>
<h4 id="自增长使用"><a href="#自增长使用" class="headerlink" title="自增长使用"></a>自增长使用</h4><ul>
<li>当自增长被给定的值为NULL或者默认值的时候会触发自动增长</li>
<li>自增长如果对应的字段输入了值,那么自增长失效: 但是下一次还是能够正确的自增长(从最大值+1)</li>
<li>可以通过查看表创建语句查看下一次自增长的值</li>
</ul>
<h4 id="修改自增长"><a href="#修改自增长" class="headerlink" title="修改自增长"></a>修改自增长</h4><ul>
<li>如果涉及到字段改变<ul>
<li>必须先删除自增长,后增加</li>
</ul>
</li>
<li>修改当前自增长已经存在的值<ul>
<li><code>alter table 表名 auto_increment = 值</code></li>
<li>只能比当前已有的自增长的最大值大,不能小(小不生效)</li>
</ul>
</li>
</ul>
<h4 id="删除自增长"><a href="#删除自增长" class="headerlink" title="删除自增长"></a>删除自增长</h4><ul>
<li><code>alter table 表名 modify 字段名 数据类型</code><ul>
<li>自增长是字段的一个属性: 可以通过modify来进行修改，只要保证字段没有auto_increment即可</li>
</ul>
</li>
</ul>
<h4 id="自增长初始值-amp-种子"><a href="#自增长初始值-amp-种子" class="headerlink" title="自增长初始值 &amp; 种子"></a>自增长初始值 &amp; 种子</h4><ul>
<li><code>show variables like ‘auto_increment%’</code><ul>
<li>查看自增长对应变量</li>
<li>初始值<ul>
<li><code>auto_increment_increment</code></li>
</ul>
</li>
<li>种子<ul>
<li><code>auto_increment_offset</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h3><ul>
<li><code>unique key</code></li>
</ul>
<h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><ul>
<li>唯一，可以为null，且可以有多个null(null不参与唯一性比较)</li>
</ul>
<h4 id="新增唯一键"><a href="#新增唯一键" class="headerlink" title="新增唯一键"></a>新增唯一键</h4><ol>
<li>建表时，字段后跟unique key<ul>
<li><code>字段名 数据类型 unique/unique key</code></li>
</ul>
</li>
<li>建表时，在所有字段后增加<code>unique key(字段列表)</code></li>
<li>建表之后，追加唯一键<ul>
<li><code>alter table 表名 add unique key(字段列表)</code></li>
</ul>
</li>
</ol>
<h4 id="删除唯一键"><a href="#删除唯一键" class="headerlink" title="删除唯一键"></a>删除唯一键</h4><ul>
<li><code>alter table 表名 drop index 索引名字</code><ul>
<li>唯一键默认的使用字段名作为索引名字</li>
</ul>
</li>
</ul>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul>
<li><code>alter table 表名 add constraint 约束名 约束类型 约束说明</code><ul>
<li>约束名命名规则<ul>
<li>约束类型_约束列</li>
<li>主键(primary key) <ul>
<li>pk_uId</li>
</ul>
</li>
<li>唯一(unique) <ul>
<li>uq_uId</li>
</ul>
</li>
<li>默认(default key)<ul>
<li>dk_uId</li>
</ul>
</li>
<li>检查(check key)<ul>
<li>ck_uId</li>
</ul>
</li>
<li>外键(foreign key)<ul>
<li>fk_uid </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>alter table 表名 drop constraint 约束名</code></li>
</ul>
<h2 id="主键约束-1"><a href="#主键约束-1" class="headerlink" title="主键约束"></a>主键约束</h2><ul>
<li><code>alter table 表名 add constraint 主键约束名 primary key(字段列表);</code></li>
</ul>
<h2 id="外键约束-1"><a href="#外键约束-1" class="headerlink" title="外键约束"></a>外键约束</h2><ul>
<li><code>ALTER TABLE 表名 ADD FOREIGN KEY (字段名) REFERENCES 表名(字段名)</code></li>
</ul>
<h1 id="高级数据操作"><a href="#高级数据操作" class="headerlink" title="高级数据操作"></a>高级数据操作</h1><h2 id="增-3"><a href="#增-3" class="headerlink" title="增"></a>增</h2><h3 id="主键冲突"><a href="#主键冲突" class="headerlink" title="主键冲突"></a>主键冲突</h3><ul>
<li>在数据插入的时候, 假设主键对应的值已经存在: 插入一定会失败</li>
<li>当主键存在冲突的时候(Duplicate key)<ol>
<li>更新<ul>
<li><code>Insert into 表名[字段列表(包含主键)] values(值列表) on duplicate key update 字段 = 新值</code></li>
</ul>
</li>
<li>替换<ul>
<li><code>Replace into 表名 [字段列表(包含主键)] values(值列表)</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="蠕虫复制"><a href="#蠕虫复制" class="headerlink" title="蠕虫复制"></a>蠕虫复制</h3><ul>
<li>从已有的数据中去获取数据,然后将数据又进行新增操作: 数据成倍的增加</li>
<li>从已有表创建新表(复制表结构)<ul>
<li><code>create table 表名 like 数据库.表名</code></li>
</ul>
</li>
<li>蠕虫复制<ul>
<li>先查出数据, 然后将查出的数据新增一遍</li>
<li><code>insert into 表名[字段列表] select 字段类别/* from 数据表名</code></li>
</ul>
</li>
<li>蠕虫复制的意义<ol>
<li>从已有表拷贝数据到新表中</li>
<li>可以迅速的让表中的数据膨胀到一定的数量级: 测试表的压力以及效率</li>
</ol>
</li>
</ul>
<h2 id="删-3"><a href="#删-3" class="headerlink" title="删"></a>删</h2><ul>
<li><code>Delete from 表名 [where条件] [limit 数量]</code></li>
</ul>
<h2 id="改-3"><a href="#改-3" class="headerlink" title="改"></a>改</h2><ul>
<li><code>Update 表名 set 字段 = 值 [where条件] [limit 更新数量]</code></li>
</ul>
<h2 id="查-3"><a href="#查-3" class="headerlink" title="查"></a>查</h2><h3 id="查询完整语法"><a href="#查询完整语法" class="headerlink" title="查询完整语法"></a>查询完整语法</h3><ul>
<li><code>Select [select选项] 字段列表[字段别名]/* from 数据源 [where条件子句] [group by子句] [having子句] [order by子句] [limit 子句]</code><ol>
<li>where从表中查询出符合条件的数据形成一个概念中的临时结果集，存入内存</li>
<li>列之间的运算(select子句中)及分组(group by)统计进行完毕，临时结果形成结果集。</li>
<li>having对结果集进行筛选。</li>
<li>order by对筛选后的结果集进行排序。</li>
<li>limit对排序后的结果集进行条目限制，形成最终结果集。</li>
</ol>
<ul>
<li>问题<ul>
<li>1<code>select id (salary*12) as 年薪 from persons where (salary*12)&gt;100</code></li>
<li>2<code>select id (salary*12) as 年薪 from persons where 年薪&gt;100</code></li>
<li>2是错误的。因为where是对表中的数据发挥作用，查询出数据来。发挥完作用形成的结果中才有列’年薪’,在where中直接使用列’年薪’时，显然表中并没有这个列。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="select选项"><a href="#select选项" class="headerlink" title="select选项"></a>select选项</h3><ul>
<li>select对查出来的结果的处理方式<ul>
<li><code>all</code><ul>
<li>默认，保留所有结果</li>
</ul>
</li>
<li><code>distinct</code><ul>
<li>去重, 查出来的结果,将重复给去除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字段别名"><a href="#字段别名" class="headerlink" title="字段别名"></a>字段别名</h3><ul>
<li><code>字段名 [as] 别名</code></li>
</ul>
<h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><ul>
<li>本质上只要保证数据类似二维表,最终都可以作为数据源</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>单表数据源<ul>
<li><code>select * from 表名</code></li>
</ul>
</li>
<li>多表数据源<ul>
<li><code>select * from 表1,表2...</code><ul>
<li>笛卡儿积</li>
</ul>
</li>
</ul>
</li>
<li>查询语句<ul>
<li><code>select * from (select语句) as 表名</code><ul>
<li>子查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h3><ul>
<li><code>&gt;</code> <code>&lt;</code> <code>=</code>  <code>!=</code>  <code>&lt;&gt;</code>  <code>&lt;=</code>  <code>&gt;=</code></li>
<li><code>and(&amp;&amp;)</code> <code>or(||)</code> <code>not(!)</code></li>
<li><code>between and</code></li>
<li><code>in()</code></li>
<li><code>any()</code><ul>
<li>代表括号中任意一个即可，同<code>in()</code></li>
</ul>
</li>
<li><code>all()</code><ul>
<li>代表括号中的所有</li>
</ul>
</li>
<li><code>is null</code> <code>is not null</code></li>
<li><code>like</code><ul>
<li><code>%</code><ul>
<li>代表任意字符。</li>
</ul>
</li>
<li><code>_</code><ul>
<li>代表一个任意字符。</li>
</ul>
</li>
</ul>
</li>
<li>where原理<ul>
<li>where是唯一一个直接从磁盘获取数据的时候就开始判断的条件: 从磁盘取出一条记录, 开始进行where判断: 判断的结果如果成立保存到内存;如果失败直接放弃</li>
<li>where保证进入内存的数据都是有效的</li>
<li>where子句中只能用表中有的列，且不能使用别名</li>
</ul>
</li>
</ul>
<h3 id="group-by子句"><a href="#group-by子句" class="headerlink" title="group by子句"></a>group by子句</h3><ul>
<li>通常结合聚合函数使用</li>
<li>分组会自动排序: 根据分组字段:默认升序<ul>
<li><code>Group by 字段 [asc|desc]</code><ul>
<li>对分组后的整个结果进行排序</li>
</ul>
</li>
</ul>
</li>
<li>多字段分组<ul>
<li>先根据一个字段进行分组,然后对分组后的结果再次按照其他字段进行分组</li>
</ul>
</li>
<li>注意:<ul>
<li>select子句中出现的非聚合函数的列,必须出现在group by子句中。<ul>
<li>充分不必要</li>
<li>即select的列如果不是函数，那么必须是用来group by的列</li>
<li>而用来group by的列，不必非要select。</li>
<li>这是sql标准，mysql中违反也不报错，但强烈不推荐。</li>
</ul>
</li>
</ul>
</li>
<li><code>group_concat(字段)</code><ul>
<li>可以对分组的结果中的某个字段进行字符串连接(保留该组所有的此字段)</li>
<li>用在select中，比如按班级分组，<code>select class,group_concat(name)</code><ul>
<li>可以按照班级分组后，并查出每个班级的人的名字</li>
</ul>
</li>
</ul>
</li>
<li><code>with rollup</code><ul>
<li>回溯统计<ul>
<li>任何一个分组后都会有一个小组, 最后都需要向上级分组进行汇报统计</li>
</ul>
</li>
<li>我的认为就是在原有分组结果上对每一层的每一个分组都做一下统计<ul>
<li>按班级分组<ul>
<li>原结果是3班 3条记录</li>
<li>回溯结果<ul>
<li>班级向上层回溯，1条记录</li>
<li>原3+1=4条记录</li>
</ul>
</li>
</ul>
</li>
<li>按班级，性别分组<ul>
<li>原结果1班没男的，2班没女的，3班都有，4条记录</li>
<li>回溯结果<ul>
<li>性别那一层向上一层(班级)回溯，就会有3条记录，因为有3个班级</li>
<li>班级那一层向上层回溯，1条记录</li>
<li>原4+3+1=8条记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul>
<li><code>max()</code></li>
<li><code>min()</code></li>
<li><code>sum()</code></li>
<li><code>avg()</code></li>
<li><code>count()</code><ul>
<li>可以使用两种参数<ol>
<li><code>*</code><ul>
<li>代表统计记录，即使某行所有字段皆为null也统计</li>
<li>安（用数字，字母等代替也可以。。）<ul>
<li><code>count(1) count(0) count(x)</code><ul>
<li><code>count(1)</code>相当于数了总行数次1</li>
<li><code>count(0)</code>相当于数了总行数次0</li>
<li><code>count(x)</code>相当于数了总行数次x</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>字段名</code><ul>
<li>统计对应的字段，如果某行该字段为空，不会统计</li>
</ul>
</li>
</ol>
<ul>
<li><code>count(表达式)</code><ul>
<li>表达式没用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h3><ul>
<li>Where是针对磁盘数据进行判断: 进入到内存之后,会进行分组统计，列运算…就需要having来处理.</li>
<li>where只能用表中存在的字段名</li>
<li>having可以使用别名</li>
</ul>
<h3 id="order-by子句"><a href="#order-by子句" class="headerlink" title="order by子句"></a>order by子句</h3><ul>
<li>依赖校对集</li>
<li><code>asc</code><ul>
<li>升序，默认。</li>
</ul>
</li>
<li><code>desc</code><ul>
<li>降序</li>
</ul>
</li>
<li><code>order by 列1 asc,列2 desc...</code><ul>
<li>前一个条件排序结果相同才会按照下一个条件排序。</li>
</ul>
</li>
</ul>
<h3 id="limit子句"><a href="#limit子句" class="headerlink" title="limit子句"></a>limit子句</h3><ul>
<li><code>limit index length</code><ul>
<li>从index开始，取length条数据。</li>
<li>index<ul>
<li>起始索引，若省略相当于0。</li>
</ul>
</li>
<li>length<ul>
<li>条目数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ul>
<li>length<ul>
<li>每页数据量，基本不变</li>
</ul>
</li>
<li>index<ul>
<li>index=(页码-1)*length</li>
</ul>
</li>
</ul>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><ul>
<li><code>from 左表 cross join 右表</code> == <code>from 左表,右表</code></li>
</ul>
<h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li>从一张表中循环取出每一条记录, 每条记录都去另外一张表进行匹配: 匹配一定保留(没有条件匹配), 而连接本身字段就会增加(保留),最终形成的结果: 笛卡尔积.</li>
</ul>
<h4 id="笛卡儿积"><a href="#笛卡儿积" class="headerlink" title="笛卡儿积"></a>笛卡儿积</h4><ul>
<li>指数学中两个集合的笛卡儿积<ul>
<li>`集合A={a, b}，集合B={0, 1, 2}<ul>
<li>则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}`</li>
</ul>
</li>
<li>注意笛卡儿积是元素相组合，不是数学相乘。</li>
<li>集合A有m个元素，集合B有n个元素<ul>
<li>笛卡儿积总共<code>m*n</code>个元素。</li>
</ul>
</li>
</ul>
</li>
<li>数据库中的笛卡儿积<ul>
<li>表A中有m条数据，表B中有n条数据<ul>
<li><code>select * from 表A,表B;</code><ul>
<li><code>行=m*n</code></li>
<li><code>列=表A的列数+表B的列数</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><ul>
<li><code>from 左表 [inner] join 右表 on</code>  ==  <code>from 左表,右表 where</code></li>
</ul>
<h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ul>
<li>从左表中取出每一条记录,去右表中与所有的记录进行匹配: 匹配必须是某个条件在左表中与右表中相同最终才会保留结果,否则不保留</li>
<li>查出两表符合条件的数据。</li>
<li>内连接相当于左外连接与右外连接的交集。</li>
<li>内连接可以没有on条件，就相当于交叉连接会形成笛卡儿积，可以参考where形式没有where条件。</li>
</ul>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><ul>
<li>以某张表为主,取出里面的所有记录, 然后每条与另外一张表进行连接: 不管能不能匹配上条件,最终都会保留: 能匹配,正确保留; 不能匹配,其他表的字段都置空NULL.</li>
</ul>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><ul>
<li><code>左表 left join 右表 on</code><ul>
<li>以左表为主，无论条件是否成立，都会查出左表的数据。</li>
<li>条件成立，保留右表数据</li>
<li>条件不成立，右表字段置为null</li>
</ul>
</li>
</ul>
<h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><ul>
<li><code>左表 right join 右表 on</code></li>
</ul>
<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><ul>
<li>自然连接, 就是自动匹配连接条件: 系统以字段名字作为匹配模式(同名字段就作为条件, 多个同名字段都作为条件).</li>
</ul>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><ul>
<li>把自己看作两张表，自己连接自己</li>
</ul>
<h3 id="连接-例"><a href="#连接-例" class="headerlink" title="连接 例"></a>连接 例</h3><ul>
<li>表<strong>t1</strong></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
</tr>
</tbody>
</table>
<ul>
<li>表<strong>t2</strong></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>4</td>
<td>F</td>
</tr>
</tbody>
</table>
<h3 id="inner-join-on"><a href="#inner-join-on" class="headerlink" title="inner join on"></a>inner join on</h3><ul>
<li><code>select * from t1 inner join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>a</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
</tbody>
</table>
<h3 id="left-join-on"><a href="#left-join-on" class="headerlink" title="left join on"></a>left join on</h3><ul>
<li><code>select * from t1 left join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
</tbody>
</table>
<h3 id="right-join-on"><a href="#right-join-on" class="headerlink" title="right join on"></a>right join on</h3><ul>
<li><code>select * from t1 right join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody>
</table>
<h3 id="full-join-on-mysql不支持"><a href="#full-join-on-mysql不支持" class="headerlink" title="full join on(mysql不支持)"></a>full join on(mysql不支持)</h3><ul>
<li><code>select * from t1 full join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody>
</table>
<h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><ul>
<li>将多次查询(多条select语句), 在记录上进行拼接(字段不会增加)<ul>
<li>联合查询只要求字段一样, 跟数据类型无关</li>
</ul>
</li>
<li><code>select 语句1 union [union选项] select 语句2</code><ul>
<li>union选项<ul>
<li><code>distinct</code><ul>
<li>去除重复，默认</li>
</ul>
</li>
<li><code>all</code><ul>
<li>保留所有</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ol>
<li>查询同一张表,但是需求不同:<ul>
<li>如查询学生信息, 男生身高升序, 女生身高降序</li>
</ul>
</li>
<li>多表查询: 多张表的结构是完全一样的,保存的数据(结构)也是一样的</li>
</ol>
<h3 id="order-by-使用"><a href="#order-by-使用" class="headerlink" title="order by 使用"></a>order by 使用</h3><ul>
<li>在联合查询中: order by不能直接使用,需要对查询语句使用括号才行</li>
<li>若要orderby生效<ul>
<li>必须搭配limit: limit使用限定的最大数即可</li>
</ul>
</li>
<li>外层语句可能还要对最终结果集排序，所以内层的两个语句的排序没有意义，所以内层(sql1,sql2)的order by在执行期间会被MySQL的代码分析器给优化掉。<ul>
<li>如果内层语句排序（order by）之后还限制条目（limit）了，那么排序会影响结果集，此时的order by就会发挥作用。</li>
<li>总结：<ul>
<li>如果两个合并的sql语句中有排序（order by），如果排序会对两个sql的结果集产生影响(如limit)那么排序就会生效，否则，排序语句不会生效。</li>
<li>外层的order by针对的是最终结果集。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul>
<li>查询是在某个查询结果之上进行的.(一条select语句内部包含了另外一条select语句).</li>
</ul>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><h4 id="按位置"><a href="#按位置" class="headerlink" title="按位置"></a>按位置</h4><h5 id="From子查询"><a href="#From子查询" class="headerlink" title="From子查询"></a>From子查询</h5><ul>
<li><code>from (sql)</code><ul>
<li>将子查询结果集看作是一张表。</li>
</ul>
</li>
</ul>
<h5 id="Where子查询"><a href="#Where子查询" class="headerlink" title="Where子查询"></a>Where子查询</h5><ul>
<li><code>where 字段 = (sql)</code></li>
<li><code>where 字段 in (sql)</code></li>
<li><code>where (字段1,字段2) = (sql)</code></li>
</ul>
<h5 id="Exists子查询"><a href="#Exists子查询" class="headerlink" title="Exists子查询"></a>Exists子查询</h5><ul>
<li><code>where exists(sql)</code><ul>
<li>exists子查询就是用来判断某些条件是否满足(跨表), exists是接在where之后: exists返回的结果只有0和1</li>
<li>exists里的条件语句能够返回记录行时,条件就为真,select的查询就返回结果，否则，select的查询结果就舍弃。<ul>
<li>即如果sql有查询结果，则select查询有结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="按结果"><a href="#按结果" class="headerlink" title="按结果"></a>按结果</h4><h5 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h5><ul>
<li>子查询得到的结果是一行一列</li>
<li>出现的位置在where之后 where子查询</li>
<li>例<ul>
<li>学生表，班级表</li>
<li>根据班级名查询班级id，根据班级id查询学生信息</li>
<li><code>select * from student where cid = (select id from class where name = &#39;1ban&#39;)</code></li>
</ul>
</li>
</ul>
<h5 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h5><ul>
<li>子查询得到的结果是一列多行</li>
<li>出现的位置在where之后 where子查询</li>
<li>例<ul>
<li>查询所有在读的学生即所有班级的学生</li>
<li><code>select * from student where cid in (select id from class)</code></li>
</ul>
</li>
</ul>
<h5 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h5><ul>
<li>子查询得到的结果是多列一行(多行多列)</li>
<li>出现的位置在where之后 where子查询</li>
<li>例<ul>
<li>查询身高最高，年龄最大的学生信息</li>
<li><code>select * from student where age=(select max(age) from student) and height=(select max(height) from student)</code></li>
<li><code>select * from student where (age,height) = (select max(age),max(height) from student)</code></li>
</ul>
</li>
</ul>
<h5 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h5><ul>
<li>子查询得到的结果是多行多列</li>
<li>出现的位置是在from之后 from子查询</li>
</ul>
<h1 id="Mysql-字符集"><a href="#Mysql-字符集" class="headerlink" title="Mysql 字符集"></a>Mysql 字符集</h1><ul>
<li><code>show character set</code><ul>
<li>查看服务器支持的字符集</li>
</ul>
</li>
<li><code>show variables like &#39;character_set%&#39;</code><ul>
<li>查看服务器默认的对外处理的字符集</li>
<li><code>character_set_client</code></li>
<li><code>character_set_connection</code></li>
<li><code>character_set_database</code><ul>
<li>创建数据库的编码格式，没有指定就默认</li>
</ul>
</li>
<li><code>character_set_filesystem</code><ul>
<li>文件系统的编码格式，把操作系统上的文件名转化成此字符集，即把 <code>character_set_client</code>转换<code>character_set_filesystem</code>， 默认binary是不做任何转换的</li>
</ul>
</li>
<li><code>character_set_results</code></li>
<li><code>character_set_server</code></li>
<li><code>character_set_system</code><ul>
<li>数据库系统使用的编码格式，这个值一直是utf8，不需要设置，它是为存储系统元数据的编码格式</li>
</ul>
</li>
<li><code>character_sets_dir</code><ul>
<li>字符集安装的目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h2><ul>
<li><code>character_set_client</code><ul>
<li>客户端字符集（服务器认为的要存储的数据的字符集）</li>
</ul>
</li>
<li><code>character_set_connection</code><ul>
<li>连接器字符集</li>
</ul>
</li>
<li><code>character_set_server</code><ul>
<li>服务端字符集(存储到服务器的字符集)</li>
</ul>
</li>
<li><code>character_set_results</code><ul>
<li>服务器返回数据(查询结果)字符集</li>
</ul>
</li>
</ul>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><ul>
<li><code>set 变量 = 值</code><ul>
<li>修改只是会话级别(当前客户端,当次连接有效: 关闭失效)</li>
</ul>
</li>
<li><code>set names 值</code><ul>
<li>相当于同时设置</li>
<li><code>character_set_client</code></li>
<li><code>character_set_connection</code></li>
<li><code>character_set_results</code></li>
</ul>
</li>
</ul>
<h2 id="存"><a href="#存" class="headerlink" title="存"></a>存</h2><ul>
<li><code>数据字符集 ↔ character_set_client → character_set_connection → character_set_server</code><ul>
<li><code>数据</code>↔<code>客户端</code>→<code>连接器</code>→<code>服务端</code></li>
<li>存数据最终是按照服务端设置的编码存的</li>
<li>连接器的字符集不应太小，否则转换过程会损失数据。</li>
</ul>
</li>
<li>过程<ol>
<li>数据本身的字符集要与<code>character_set_client</code>一致<ul>
<li>因为服务器认为提交的数据是<code>character_set_client</code>的，如果不是就会出问题。</li>
</ul>
</li>
<li>把数据从<code>character_set_client</code>转为<code>character_set_connection</code><ul>
<li>若一致则不转换</li>
</ul>
</li>
<li>把数据从<code>character_set_connection</code>转为<code>character_set_server</code><ul>
<li>若一致则不转换</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="取"><a href="#取" class="headerlink" title="取"></a>取</h2><ul>
<li><code>character_set_server → character_set_connection → character_set_results ↔ character_set_client</code><ul>
<li><code>服务端</code>→<code>连接器</code>→<code>查询结果</code>↔<code>客户端</code></li>
<li>取数据最终是按照结果集的字符集返回给客户端。</li>
<li>保证结果集和客户端字符集一致即可。</li>
</ul>
</li>
<li>过程<ol>
<li>把数据从<code>character_set_server</code>转为<code>character_set_connection</code><ul>
<li>若一致则不转换</li>
</ul>
</li>
<li>把数据从<code>character_set_connection</code>转为<code>character_set_results</code><ul>
<li>若一致则不转换</li>
</ul>
</li>
<li>比较<code>character_set_results</code>和<code>character_set_client</code>的字符集<ul>
<li>不一致则乱码</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="Mysql校对集"><a href="#Mysql校对集" class="headerlink" title="Mysql校对集"></a>Mysql校对集</h1><ul>
<li>校对集<ul>
<li>数据比较的方式</li>
</ul>
</li>
<li>校对集依赖字符集<ul>
<li>例如<ul>
<li><code>default-character-set=utf8</code></li>
<li><code>default-collation=utf8_general_ci</code></li>
</ul>
</li>
</ul>
</li>
<li><code>show collation</code><ul>
<li>查看数据库支持的校对集</li>
</ul>
</li>
<li>只有当数据产生比较的时候,校对集才会生效<ul>
<li>如<code>order by</code></li>
</ul>
</li>
<li>必须在没有数据之前声明好校对集，如果有了数据再进行校对集修改，修改无效</li>
</ul>
<h2 id="校对集格式"><a href="#校对集格式" class="headerlink" title="校对集格式"></a>校对集格式</h2><ul>
<li><code>_bin</code><ul>
<li><code>binary</code></li>
<li>二进制比较, 取出二进制位,一位一位的比较, 区分大小写</li>
</ul>
</li>
<li><code>_cs</code><ul>
<li><code>case sensitive</code></li>
<li>大小写敏感, 即区分大小写</li>
</ul>
</li>
<li><code>_ci</code><ul>
<li><code>case insensitice</code></li>
<li>大小写不敏感,即不区分大小写</li>
</ul>
</li>
</ul>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li><code>Normal Format</code><ul>
<li>是一种离散数学中的知识, 是为了解决一种数据的存储与优化的问题: 保存数据的存储之后, 凡是能够通过关系寻找出来的数据,坚决不再重复存储: 终极目标是为了减少数据的冗余.</li>
</ul>
</li>
<li>范式是一种分层结构的规范, 分为六层: 每一次层都比上一层更加严格: 若要满足下一层范式,前提是满足上一层范式.<ul>
<li>1NF,2NF,3NF…6NF</li>
<li>1NF是最底层,要求最低;6NF最高层,最严格</li>
</ul>
</li>
</ul>
<h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h2><ul>
<li>第一范式: 在设计表存储数据的时候, 如果表中设计的字段存储的数据,在取出来使用之前还需要额外的处理(拆分),那么说表的设计不满足第一范式</li>
<li>第一范式要求字段的数据具有原子性: 不可再分</li>
<li>解决<ul>
<li>拆分字段</li>
</ul>
</li>
</ul>
<h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><ul>
<li>第二范式: 在数据表设计的过程中,如果有复合主键(多字段主键), 且表中有字段并不是由整个主键来确定, 而是依赖主键中的某个字段(主键的部分): 存在字段依赖主键的部分的问题, 称之为部分依赖:</li>
<li>第二范式就是要解决表设计不允许出现部分依赖</li>
<li>解决<ol>
<li>可以将复合主键字段单独成表</li>
<li>取消复合主键，使用逻辑主键 </li>
</ol>
</li>
</ul>
<h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><ul>
<li>第三范式: 理论上讲,应该一张表中的所有字段都应该直接依赖主键(逻辑主键: 代表的是业务主键), 如果表设计中存在一个字段, 并不直接依赖主键,而是通过某个非主键字段依赖,最终实现依赖主键: 把这种不是直接依赖主键,而是依赖非主键字段的依赖关系称之为传递依赖</li>
<li>第三范式就是要解决传递依赖的问题.</li>
<li>解决<ul>
<li>将存在传递依赖的字段,以及依赖的字段本身单独取出,形成一个单独的表, 然后在需要对应的信息的时候, 使用对应的实体表的主键加进来.</li>
</ul>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul>
<li>系统根据某种算法, 将已有的数据(未来可能新增的数据),单独建立一个文件: 文件能够实现快速的匹配数据, 并且能够快速的找到对应表中的记录</li>
<li>几乎所有的索引都是建立在字段之上</li>
<li>索引本身会产生索引文件(有时候有可能比数据文件还大) ,会非常耗费磁盘空间.<ul>
<li>就像字典前边的目录，会提高速度，但也会增加书的厚度</li>
<li>索引提高了查询速度，但降低了增删改的速度，并非越多越好</li>
</ul>
</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>提升查询数据的效率<ul>
<li>如果某个字段需要作为查询的条件经常使用，那么可以使用索引</li>
</ul>
</li>
<li>约束数据的有效性(唯一性等)<ul>
<li>如果某个字段需要进行数据的有效性约束, 也可能使用索引(主键,唯一键)</li>
</ul>
</li>
</ol>
<h2 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h2><ul>
<li><strong>key</strong><ul>
<li>普通索引</li>
<li><code>key 索引名(列名)</code></li>
</ul>
</li>
<li><strong>unique key</strong><ul>
<li>唯一索引</li>
<li><code>unique key 索引名(列名)</code></li>
</ul>
</li>
<li><strong>primary key</strong><ul>
<li>主键索引</li>
<li><code>primary key 索引名(列名)</code></li>
</ul>
</li>
<li><strong>funlltext</strong><ul>
<li>全文索引</li>
<li>中文环境下无效，要分词+索引，一般用第三方解决方案<ul>
<li>如<code>sphinx</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>索引长度</strong><ul>
<li>建索引时，可以只索引列的一部分内容，如前10个字符<ul>
<li><code>key 索引名(列名(10))</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>多列索引</strong><ul>
<li>就是把多个列的值，看成一个整体，然后建立索引<ul>
<li>如有两个列<code>xing</code>,<code>ming</code></li>
<li><code>key xm(xing,ming)</code><ul>
<li>查询时按照姓名查就会使用索引</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>冗佘索引</strong><ul>
<li>某个列上存在多个索引<ul>
<li>比如一个列有个索引，还有个多列索引。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><ul>
<li>查看表的索引<ul>
<li><code>show index from 表名</code></li>
</ul>
</li>
<li>添加普通和唯一索引<ul>
<li><code>alter table 表名 add index/unique 索引名(列名)</code></li>
</ul>
</li>
<li>添加主键索引<ul>
<li><code>alter table 表名 add primary key(列名)</code></li>
</ul>
</li>
<li>删除索引<ul>
<li><code>alter table 表名 drop index 索引名</code></li>
<li><code>drop index 索引名 on 表名</code></li>
</ul>
</li>
</ul>
<h1 id="视图view"><a href="#视图view" class="headerlink" title="视图view"></a>视图view</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul>
<li>view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。</li>
<li>视图中并没有真正存储数据。</li>
<li>表的改变会影响视图(视图就好像表的影子一样)</li>
<li>视图的改变也能影响表。(如果可以改变的话)</li>
<li>可以跟基本表一样，进行增删改查操作</li>
</ul>
<h2 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h2><ul>
<li>主要是用来查询</li>
<li>增删改操作有条件限制<ul>
<li>如果视图的数据与表的数据是一一对应出来的，改变不会影响其它数据，就可以增删改。</li>
<li>如果视图的数据是通过计算得来的，改变则会影响表中的其它数据，不可以增删改。</li>
</ul>
</li>
</ul>
<h2 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h2><ol>
<li>方便操作，特别是查询操作，减少复杂的SQL语句<ul>
<li>将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作</li>
</ul>
</li>
<li>数据安全<ul>
<li>视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全).</li>
<li>可以对外提供有用的数据, 但是隐藏关键(无用)的数据</li>
<li>数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别</li>
</ul>
</li>
<li>权限控制<ul>
<li>不希望用户访问表中某些含敏感信息的列,可以通过view开放某几个列</li>
</ul>
</li>
<li>数据过多时，分表用</li>
</ol>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><ul>
<li><code>create view 视图名 as select语句</code></li>
</ul>
<h2 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h2><ul>
<li><code>show create table/view 视图名</code></li>
<li><code>show tables [like]/desc 视图名</code><ul>
<li>视图是一张虚拟表，表的所有查看方式，视图都能用，且视图比表多一个关键字view</li>
</ul>
</li>
</ul>
<h2 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h2><ul>
<li>视图本身不可修改，但视图来源可以修改</li>
<li><code>alter view 视图名 as 新的select语句</code></li>
</ul>
<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><ul>
<li><code>drop view 视图名</code></li>
</ul>
<h2 id="视图算法-algorithm"><a href="#视图算法-algorithm" class="headerlink" title="视图算法(algorithm)"></a>视图算法(algorithm)</h2><ul>
<li>系统对视图以及外部查询视图的Select语句的一种解析方式</li>
<li><code>create algorithm=xxx view 视图名 as select 语句</code><ul>
<li>是对标准sql的mysql的扩展</li>
</ul>
</li>
</ul>
<h3 id="分类-3"><a href="#分类-3" class="headerlink" title="分类"></a>分类</h3><ul>
<li><code>undefined</code><ul>
<li>未定义(默认的), 这不是一种实际使用算法, 是一种推卸责任的算法: 告诉系统,视图没有定义算法, 系统自己看着办<ul>
<li>未定义由系统定义，它倾向于MERGE而不是TEMPTABLE</li>
<li>因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。</li>
</ul>
</li>
</ul>
</li>
<li><code>temptable</code><ul>
<li>临时表算法: 系统应该先执行视图的select语句,后执行外部查询语句<ul>
<li>视图的结果将被置于临时表中，然后使用它执行语句</li>
<li>适合复杂查询形成的view</li>
</ul>
</li>
</ul>
</li>
<li><code>merge</code><ul>
<li>合并算法: 系统应该先将视图对应的select语句与外部查询视图的select语句进行合并,然后执行(效率高: 常态)<ul>
<li>将查询视图的语句与视图定义语句合并起来<ul>
<li>查询视图的语句+视图定义语句=查询物理表的语句</li>
</ul>
</li>
<li>合并查询语句，不会创建临时表</li>
<li>适合简单查询形成的view</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算法选择"><a href="#算法选择" class="headerlink" title="算法选择"></a>算法选择</h3><ul>
<li>如果视图的select语句中会包含一个查询子句(五子句), 而且很有可能顺序比外部的查询语句要靠后, 一定要使用算法temptable,其他情况可以不用指定(默认即可)</li>
</ul>
<h1 id="存储引擎engine"><a href="#存储引擎engine" class="headerlink" title="存储引擎engine"></a>存储引擎engine</h1><ul>
<li>MySQL进行存储数据的方式。</li>
</ul>
<h2 id="分类-4"><a href="#分类-4" class="headerlink" title="分类"></a>分类</h2><h3 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h3><ul>
<li>只有表结构,数据全部存储到ibdata1文件中</li>
<li>支持事务(新版MySQL默认)</li>
</ul>
<h3 id="myisam"><a href="#myisam" class="headerlink" title="myisam"></a>myisam</h3><ul>
<li>速度快，不支持事务，安全性不够</li>
<li>表,数据和索引全部单独分开存储<ul>
<li><code>.frm</code>是结构</li>
<li><code>.myd</code>是数据</li>
<li><code>.myi</code>是索引</li>
</ul>
</li>
</ul>
<h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><ul>
<li>数据存在内存中，不存在磁盘，一关闭服务器就消失。适合临时数据。</li>
</ul>
<h1 id="数据备份-amp-还原"><a href="#数据备份-amp-还原" class="headerlink" title="数据备份&amp;还原"></a>数据备份&amp;还原</h1><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><h3 id="数据表备份"><a href="#数据表备份" class="headerlink" title="数据表备份"></a>数据表备份</h3><ul>
<li>不需要通过SQL来备份: 直接进入到数据库文件夹复制对应的表结构以及数据文件, 以后还原的时候,直接将备份的内容放进去即可</li>
<li>根据不同的存储引擎有不同的区别.<ul>
<li><code>myisam</code><ul>
<li>直接拷贝三个文件即可使用</li>
</ul>
</li>
<li><code>innodb</code><ul>
<li>也能拷贝，但不能使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="单表数据备份"><a href="#单表数据备份" class="headerlink" title="单表数据备份"></a>单表数据备份</h3><ul>
<li>每次只能备份一张表; 只能备份数据(表结构不能备份)</li>
<li>通常的使用<ul>
<li>将表中的数据进行导出到文件</li>
</ul>
</li>
</ul>
<h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><ul>
<li>前提：文件不存在</li>
<li><code>Select */字段列表 into outfile 文件所在路径 from 数据源</code></li>
<li><code>Select */字段列表 into outfile 文件所在路径 fields 字段处理 lines 行处理 from 数据源</code><ul>
<li>自己制定字段和行的处理方式</li>
<li><code>fields 字段处理</code><ul>
<li><code>Enclosed by</code><ul>
<li>字段使用什么内容包裹, 默认是<code>&quot;&quot;</code>空字符串</li>
</ul>
</li>
<li><code>Terminated by</code><ul>
<li>字段以什么结束, 默认是<code>\t</code>, tab键</li>
</ul>
</li>
<li><code>Escaped by</code><ul>
<li>特殊符号用什么方式处理,默认是<code>\</code> 使用反斜杠转义</li>
</ul>
</li>
</ul>
</li>
<li><code>lines 行处理</code><ul>
<li><code>Starting by</code><ul>
<li>每行以什么开始, 默认是<code>&quot;&quot;</code>空字符串</li>
</ul>
</li>
<li><code>erminated by</code><ul>
<li>每行以什么结束,默认是<code>\r\n</code>,换行符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h4><ul>
<li>将一个在外部保存的数据重新恢复到表中(表结构不存在，失败)</li>
<li><code>Load data infile 文件所在路径 into table 表名[(字段列表)] fields字段处理 lines 行处理</code></li>
</ul>
<h3 id="SQL备份"><a href="#SQL备份" class="headerlink" title="SQL备份"></a>SQL备份</h3><ul>
<li>备份的是SQL语句: 系统会对表结构以及数据进行处理,变成对应的SQL语句, 然后进行备份: 还原的时候只要执行SQL指令即可.(主要就是针对表结构)</li>
</ul>
<h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><ul>
<li>不是针对数据或者SQL指令进行备份: 是针对mysql服务器的日志文件进行备份</li>
<li>指定时间段开始进行备份., 备份数据不会重复, 而且所有的操作都会备份(大项目都用增量备份)</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><ul>
<li>系统定义好的变量: 大部分的时候用户根本不需要使用系统变量: 系统变量是用来控制服务器的表现的<ul>
<li>如<code>autocommit auto_increment_increment...</code></li>
</ul>
</li>
</ul>
<h3 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h3><ul>
<li><code>Show variables</code><ul>
<li>查看所有变量</li>
</ul>
</li>
<li><code>Select @@变量名</code><ul>
<li>查看具体变量</li>
</ul>
</li>
</ul>
<h3 id="修改系统变量"><a href="#修改系统变量" class="headerlink" title="修改系统变量"></a>修改系统变量</h3><ul>
<li><code>et 变量名 = 值</code>  / <code>Set @@变量名 = 值</code><ul>
<li>会话级别</li>
</ul>
</li>
<li><code>Set global 变量名 = 值</code><ul>
<li>永久生效</li>
</ul>
</li>
</ul>
<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><ul>
<li>为了区分系统变量, 规定用户自定义变量必须使用一个<code>@</code>符号</li>
<li>所有自定义的变量都是会话级别</li>
<li>所有自定义变量不区分数据库(用户级别)</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>Mysql中的作用域与js中的作用域完全一样<ul>
<li>全局变量可以在任何地方使用</li>
<li>局部变量只能在函数内部使用</li>
</ul>
</li>
<li>全局变量<ul>
<li>使用set关键字定义, 使用@符号标志</li>
</ul>
</li>
<li>局部变量<ul>
<li>使用declare关键字声明, 没有@符号: 所有的局部变量的声明,必须在函数体开始之前</li>
</ul>
</li>
</ul>
<h3 id="定义自定义变量"><a href="#定义自定义变量" class="headerlink" title="定义自定义变量"></a>定义自定义变量</h3><ul>
<li><code>Set @变量名 = 值</code></li>
</ul>
<h3 id="查看自定义变量"><a href="#查看自定义变量" class="headerlink" title="查看自定义变量"></a>查看自定义变量</h3><ul>
<li><code>select @变量名</code></li>
</ul>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><ul>
<li><code>:=</code><ul>
<li>在mysql中, <code>=</code>会默认的当做比较符号处理(很多地方), mysql为了区分比较和赋值的概念: 重新定义了一个新的的赋值符号</li>
</ul>
</li>
</ul>
<ol>
<li><code>Select @变量名 := 字段名 from 数据源</code><ul>
<li>一边查看结果一边赋值，如果用<code>=</code>会变成比较</li>
</ul>
</li>
<li><code>Select 字段列表 from 表名 into 变量列表</code><ul>
<li>要求: 数据记录最多只允许获取一条: mysql不支持数组<ul>
<li><code>select name,age from user into @name,@age</code><ul>
<li>错误</li>
</ul>
</li>
<li><code>select name,age from user where id=1 into @name,@age</code><ul>
<li>正确，只获取一条数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="触发器Trigger"><a href="#触发器Trigger" class="headerlink" title="触发器Trigger"></a>触发器Trigger</h1><ul>
<li>事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候(增删改)系统会自动触发代码,执行</li>
</ul>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><ul>
<li>一张表中只能拥有一种触发时间的一种类型的触发器<ul>
<li>一张表最多能有6个触发器<ul>
<li>增删改/前后 6种组合</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><ul>
<li>增(insert)</li>
<li>删(delete)</li>
<li>改(update)</li>
</ul>
<h3 id="触发时间"><a href="#触发时间" class="headerlink" title="触发时间"></a>触发时间</h3><ul>
<li>前(before)</li>
<li>后(after)</li>
</ul>
<h3 id="触发对象"><a href="#触发对象" class="headerlink" title="触发对象"></a>触发对象</h3><ul>
<li>表中的每一条记录(行)</li>
</ul>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><ul>
<li>在mysql高级结构中: 没有大括号,  都是用对应的字符符号代替</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 临时修改语句结束符</span><br><span class="line">Delimiter 自定义符号: 后续代码中只有碰到自定义符号才算结束</span><br><span class="line"></span><br><span class="line">Create trigger 触发器名字 触发时间 事件类型 on 表名 for each row</span><br><span class="line"></span><br><span class="line">Begin		-- 代表左大括号: 开始</span><br><span class="line">-- 里面就是触发器的内容: 每行内容都必须使用语句结束符: 分号</span><br><span class="line">End			-- 代表右带括号: 结束</span><br><span class="line"></span><br><span class="line">-- 语句结束符</span><br><span class="line">自定义符号</span><br><span class="line"></span><br><span class="line">-- 将临时修改修正过来</span><br><span class="line">Delimiter  ;</span><br></pre></td></tr></table></figure>
<h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><ul>
<li><code>Information_schema.triggers</code><ul>
<li>所有的触发器都会保存这一张表中</li>
</ul>
</li>
<li><code>Show triggers [like ‘pattern’]</code><ul>
<li>查看所有或者模糊匹配</li>
</ul>
</li>
<li><code>Show create trigger 触发器名</code><ul>
<li>查看触发器创建语句</li>
</ul>
</li>
</ul>
<h2 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h2><ul>
<li>不需要手动调用, 而是当某种情况发生时会自动触发.</li>
</ul>
<h2 id="修改-amp-删除触发器"><a href="#修改-amp-删除触发器" class="headerlink" title="修改&amp;删除触发器"></a>修改&amp;删除触发器</h2><ul>
<li>触发器不能修改</li>
<li><code>Drop trigger 触发器名</code><ul>
<li>删除</li>
</ul>
</li>
</ul>
<h2 id="代码执行结构"><a href="#代码执行结构" class="headerlink" title="代码执行结构"></a>代码执行结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">If  条件判断  then</span><br><span class="line">	-- 满足条件要执行的代码;</span><br><span class="line">Else</span><br><span class="line">	-- 不满足条件要执行的代码;</span><br><span class="line">End if;</span><br></pre></td></tr></table></figure>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">While 条件判断 do</span><br><span class="line">	-- 满足条件要执行的代码</span><br><span class="line">	-- 变更循环条件</span><br><span class="line">End while;</span><br></pre></td></tr></table></figure>
<ul>
<li>Mysql中没有对应continue和break. 但是有替代品.<ul>
<li>Iterate: 迭代 , 类似continue, 后面的代码不执行, 循环重新来过</li>
<li>Leave: 离开, 类似break,整个循环接收</li>
<li>使用<ul>
<li><code>itrate/leave 循环名字</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环名字:While 条件判断 do</span><br><span class="line">	-- 满足条件要执行的代码</span><br><span class="line">	-- 变更循环条件</span><br><span class="line">	itrate/leave 循环名字;</span><br><span class="line">End while;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul>
<li>系统定义好的函数, 直接调用即可</li>
<li>任何函数都有返回值, 因此函数的调用是通过select调用</li>
</ul>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul>
<li><code>abs(x)</code><ul>
<li>绝对值</li>
</ul>
</li>
<li><code>bin(x)</code> <ul>
<li>二进制</li>
</ul>
</li>
<li><code>floor(x)</code><ul>
<li>返回小于x的最大整数</li>
</ul>
</li>
</ul>
<h3 id="聚合函数-1"><a href="#聚合函数-1" class="headerlink" title="聚合函数"></a>聚合函数</h3><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul>
<li><code>substring(s,index,length)</code><ul>
<li>截取字符串，以字符为单位</li>
</ul>
</li>
<li><code>instr(s,key)</code><ul>
<li>判断字符串s中是否存在字符串key，返回位置</li>
</ul>
</li>
<li><code>insert(s,index,length,key)</code><ul>
<li>替换</li>
</ul>
</li>
<li><code>strcmp(s1,s2)</code><ul>
<li>字符串比较</li>
</ul>
</li>
</ul>
<h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h3><ul>
<li><code>now()</code><ul>
<li>返回当前时间。(yyyy-MM–dd HH:mm:ss)</li>
</ul>
</li>
<li><code>curdate() current_date()</code><ul>
<li>返回日期(yyyy-MM-dd)</li>
</ul>
</li>
<li><code>curtime() current_time()</code><ul>
<li>返回时间(HH:mm:ss)</li>
</ul>
</li>
<li><code>dayofweek(date)</code><ul>
<li>一周的第几天(周日是第一天)</li>
</ul>
</li>
<li><code>dayofmonth(date)</code></li>
<li><code>dayofyear(date)</code></li>
</ul>
<h3 id="条件判断函数"><a href="#条件判断函数" class="headerlink" title="条件判断函数"></a>条件判断函数</h3><ul>
<li><code>if(expr,v1,v2)</code><ul>
<li>如果表达式expr成立，返回结果v1；否则，返回结果v2</li>
</ul>
</li>
<li><code>ifnull(v1,v2)</code><ul>
<li>如果v1的值不为NULL，则返回v1，否则返回v2。</li>
</ul>
</li>
<li><p><code>case</code></p>
<ul>
<li><p><code>case when e1 then v1 when e2 then e2 ... else vn end</code></p>
<ul>
<li>CASE表示函数开始，END表示函数结束。如果e1成立，则返回v1,如果e2成立，则返回v2，当全部不成立则返回vn，而当有一个成立之后，后面的就不执行了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">　　WHEN e1</span><br><span class="line">　　THEN v1</span><br><span class="line">　　WHEN e2</span><br><span class="line">　　THEN e2</span><br><span class="line">　　...</span><br><span class="line">　　ELSE vn</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>case expr when e1 then v1 when e2 then v2...else vn end</code></p>
<ul>
<li>如果表达式expr的值等于e1，返回v1；如果等于e2,则返回e2。否则返回vn。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE expr </span><br><span class="line">　　WHEN e1 THEN v1</span><br><span class="line">　　WHEN e2 THEN v2</span><br><span class="line">　　...</span><br><span class="line">　　ELSE vn</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h3><ul>
<li><code>USER()</code><ul>
<li>返回当前用户及所在主机</li>
</ul>
</li>
<li><code>database()</code><ul>
<li>返回当前数据库名</li>
</ul>
</li>
<li><code>version()</code><ul>
<li>返回数据库的版本号</li>
</ul>
</li>
</ul>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Create function  函数名([形参列表]) returns 数据类型 -- 规定要返回的数据类型</span><br><span class="line">Begin</span><br><span class="line">	-- 函数体</span><br><span class="line">	-- 返回值: return 类型(指定数据类型);</span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><ul>
<li>自定义函数与系统函数的调用方式是一样:</li>
<li><code>select 函数名(实参列表)</code></li>
</ul>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ul>
<li><code>show function status [like ‘pattern’]</code><ul>
<li>查看所有函数或模糊匹配</li>
</ul>
</li>
<li><code>show create function 函数名</code><ul>
<li>查看函数的创建语句</li>
</ul>
</li>
</ul>
<h3 id="修改-amp-删除函数"><a href="#修改-amp-删除函数" class="headerlink" title="修改&amp;删除函数"></a>修改&amp;删除函数</h3><ul>
<li>函数不能修改</li>
<li><code>Drop function 函数名</code><ul>
<li>删除</li>
</ul>
</li>
</ul>
<h3 id="参数-amp-变量作用域"><a href="#参数-amp-变量作用域" class="headerlink" title="参数&amp;变量作用域"></a>参数&amp;变量作用域</h3><ul>
<li>在函数内部使用@定义的变量在函数外部也可以访问</li>
</ul>
<h1 id="存储过程procedure"><a href="#存储过程procedure" class="headerlink" title="存储过程procedure"></a>存储过程procedure</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ul>
<li>是一种用来处理数据的方式.</li>
<li>存储过程是一种没有返回值的函数</li>
</ul>
<h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Create procedure 过程名字([参数列表])</span><br><span class="line">Begin</span><br><span class="line">	-- 过程体</span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<h2 id="查看-1"><a href="#查看-1" class="headerlink" title="查看"></a>查看</h2><ul>
<li><code>show procedure status [like ‘pattern’]</code><ul>
<li>查看所有存储过程或模糊匹配</li>
</ul>
</li>
<li><code>show create procedure 过程名</code><ul>
<li>查看过程创建语句:</li>
</ul>
</li>
</ul>
<h2 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h2><ul>
<li>过程没有返回值: select是不能访问的.</li>
<li><code>call 存储过程名(参数)</code></li>
</ul>
<h2 id="修改-amp-删除"><a href="#修改-amp-删除" class="headerlink" title="修改&amp;删除"></a>修改&amp;删除</h2><ul>
<li>不可修改</li>
<li><code>drop procedure 过程名</code><ul>
<li>删除</li>
</ul>
</li>
</ul>
<h2 id="存储过程参数"><a href="#存储过程参数" class="headerlink" title="存储过程参数"></a>存储过程参数</h2><ul>
<li>函数的参数需要数据类型指定, 过程比函数更严格</li>
<li>过程还有自己的类型限定</li>
<li><code>Create procedure 过程名(in 形参名字 数据类型, out 形参名字 数据类型, inout 形参名字 数据类型)</code></li>
</ul>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><ul>
<li>数据只是从外部传入给内部使用(值传递): 可以是数值也可以是变量</li>
</ul>
<h3 id="out"><a href="#out" class="headerlink" title="out"></a>out</h3><ul>
<li>只允许过程内部使用(不用外部数据), 给外部使用的.(引用传递: 外部的数据会被先清空才会进入到内部)</li>
<li>只能传变量</li>
</ul>
<h3 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h3><ul>
<li>外部可以在内部使用,内部修改也可以给外部使用: 典型的引用传递</li>
<li>只能传变量</li>
</ul>
<h1 id="Myql数据库驱动"><a href="#Myql数据库驱动" class="headerlink" title="Myql数据库驱动"></a>Myql数据库驱动</h1><ul>
<li><code>mysql-connector-java-5x</code><ul>
<li><code>driverClass=com.mysql.jdbc.Driver</code></li>
<li><code>url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</code></li>
<li><code>username=root</code></li>
<li><code>password=root</code></li>
</ul>
</li>
<li><code>mysql-connector-java-6x</code><ul>
<li><code>driverClass=com.mysql.cj.jdbc.Driver</code></li>
<li><code>url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</code><ul>
<li>如果参数不是‘？’后的第一个<ul>
<li>会提示<code>The reference to entity “serverTimezone” must end with the ‘;’ delimiter</code></li>
<li>对实体xxx引用必须以 ‘;’ 分隔符结尾</li>
</ul>
</li>
<li>将<code>&amp;</code>改为<code>&amp;amp;</code></li>
</ul>
</li>
<li><code>username=root</code></li>
<li><code>password=root</code></li>
</ul>
</li>
<li><strong>5x和6x的区别</strong><ul>
<li>6x driver发生了变化</li>
<li>6x需要设置时区<code>serverTimezone</code><ul>
<li>UTC<ul>
<li>协调世界时，又称世界统一时间、世界标准时间、国际协调时间</li>
</ul>
</li>
</ul>
</li>
<li>综合分析<ul>
<li>5.1.X的确存在一些问题，只是我们没有开发用于多时区的应用，或者已经习以为常认为合理罢了，甚至总结出了用BigInt存储跨时区的信息那种经验。</li>
<li>6.X彻底解决了跨时区的应用问题，让我们开发中顾虑更少。</li>
</ul>
</li>
<li>建议<ul>
<li>数据库服务器的时间设置<ul>
<li>对于纯产生数据的应用，没有数据回流到数仓的话，数据库时区随意设置，知道机制就可以了</li>
<li>对于需要数据回流到数仓，或者数仓的数据会回流到前台应用数据库的话，那么需要设置成和数仓的时区一致，避免两个库之间同步时发生时区异常的问题</li>
</ul>
</li>
<li>应用<ul>
<li>老应用用5.1.X，如果没有useTimezone的参数，那么谨慎升级Driver到6.X，如果要升级，记得做好测试，先修改数据库的TimeZone，然后升级Driver</li>
<li>新的应用建议使用6.X的Driver，但必须事先调整数据库服务器时区，做好测试，避免一开始数据库时区有问题，造成脏数据或数据不一致现象</li>
</ul>
</li>
</ul>
</li>
<li>查询mysql时区<ul>
<li><code>select timediff(now(),convert_tz(now(),@@session.time_zone,&#39;+00:00&#39;));</code></li>
<li><code>SELECT TIMEDIFF(NOW(), UTC_TIMESTAMP);</code></li>
<li>两个都可以，如果是中国标准时间，会输出08:00</li>
</ul>
</li>
</ul>
</li>
<li><strong>安</strong><ul>
<li>当查询返回了一个空的结果集ResultSet<ul>
<li>注：<ul>
<li><code>rs=ps.executeQuery()</code>这个方法不会返回null</li>
<li>所以rs不可能为空，而是数据为空<br>*使用5x时</li>
</ul>
</li>
<li><code>rs.next()</code>返回false</li>
</ul>
</li>
<li>使用6x时<ul>
<li><code>rs.next()</code>返回true</li>
</ul>
</li>
<li>这是我在写一个登录时发现的，明明账号密码错误查询的结果集是空的，可是使用6x，<code>rs.next()</code>返回true这样就给user的各个属性赋了默认值，返回了一个各个属性都是默认的0，null。。。的user对象。 </li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-XML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-XML/" itemprop="url">
                  xd-XML
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:37:45" itemprop="dateCreated datePublished" datetime="2018-12-11T00:37:45+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-25 20:36:10" itemprop="dateModified" datetime="2018-12-25T20:36:10+08:00">2018-12-25</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>Extensible Markup Language</code>可扩展标记语言</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>配置文件</li>
<li>数据传输</li>
</ul>
<h2 id="html-amp-xml"><a href="#html-amp-xml" class="headerlink" title="html &amp; xml"></a>html &amp; xml</h2><ul>
<li>html语法松散，xml语法严格</li>
<li>html做页面展示，xml做数据存储</li>
<li>html所有标签都是预定义的，xml所有标签都是自定义的</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h2><ul>
<li><code>&lt;?xml 属性列表 ?&gt;</code><ul>
<li><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</code><ul>
<li>必须写在第一行</li>
</ul>
</li>
<li><code>version</code> <ul>
<li>版本 1.0</li>
<li>必须属性</li>
</ul>
</li>
<li><code>encoding</code> <ul>
<li>编码方式</li>
<li>默认<code>iso-8859-1</code></li>
</ul>
</li>
<li><code>standalone</code> <ul>
<li>文档是否独立(是否依赖其它文件)<ul>
<li><code>yes</code></li>
<li><code>no</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><ul>
<li>只有一个根元素</li>
<li>元素正确闭合，嵌套</li>
<li>元素名区分大小写，不能以数字开头</li>
</ul>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ul>
<li><code>CDATA</code><ul>
<li>数据原样输出</li>
<li><code>&lt;![CDATA[数据]]&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>值必须用引号<code>&#39;&#39;</code>或<code>&quot;&quot;</code></li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><code>&lt;!-- --&gt;</code></li>
</ul>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul>
<li>约束就是xml的书写规则。<ul>
<li>即根元素是什么，可以写哪些标签，有哪些属性，顺序….(安)</li>
</ul>
</li>
</ul>
<h2 id="dtd约束"><a href="#dtd约束" class="headerlink" title="dtd约束"></a>dtd约束</h2><ul>
<li>内部dtd<ul>
<li>在xml内部定义dtd</li>
</ul>
</li>
<li>外部dtd<ul>
<li>在外部定义dtd<ul>
<li>本地dtd<ul>
<li><code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件位置&quot;</code></li>
</ul>
</li>
<li>网络dtd<ul>
<li><code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;名称空间(dtd文件名)&quot; &quot;dtd文件位置&quot;&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="schema约束"><a href="#schema约束" class="headerlink" title="schema约束"></a>schema约束</h2><ul>
<li>xsd约束文档</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>编写根标签</li>
<li>引入实例名称空间(<strong>xsi前缀</strong>)<ul>
<li><code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code></li>
</ul>
</li>
<li>引入名称空间<ul>
<li><code>xsi:schemaLocation=&quot;http://www.com.cn/xml student.xsd&quot;</code><ul>
<li>如果不声明别名，使用标签时<code>&lt;地址值:标签名&gt;</code><ul>
<li><code>&lt;http://www.com.cn/xml student.xsd:students&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>命名空间声明(为每一个名称空间设置别名)<ul>
<li><code>xmlns=&quot;...&quot;</code><ul>
<li>默认</li>
<li>使用时直接写标签名即可</li>
<li>例<ul>
<li><code>xmlns=&quot;http://www.springframework.org/schema/beans&quot;</code></li>
<li><code>&lt;bean&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><code>xmlns:别名=&quot;...&quot;</code><ul>
<li>标签<code>&lt;别名&gt;</code></li>
<li>例<ul>
<li><code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></li>
<li><code>&lt;context&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><ul>
<li>如果xml作为配置文件：读</li>
<li>如果xml作为传输文件：写，读</li>
</ul>
<h2 id="解析思想"><a href="#解析思想" class="headerlink" title="解析思想"></a>解析思想</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><ul>
<li>将文档加载进内存，形成一颗dom树(document对象)，将文档的各个组成部分封装为一些对象。</li>
<li>优点<ul>
<li>因为，在内存中会形成dom树，可以对dom树进行增删改查。</li>
</ul>
</li>
<li>缺点<ul>
<li>dom树非常占内存，解析速度慢。</li>
</ul>
</li>
</ul>
<h3 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h3><ul>
<li>逐行读取，基于事件驱动</li>
<li>优点<ul>
<li>不占内存，速度快</li>
</ul>
</li>
<li>缺点<ul>
<li>只能读取，不能回写</li>
</ul>
</li>
<li>五个对象(安)<ul>
<li>StartDocument/endDocument</li>
<li>Characters 解析文本</li>
<li>StartElement/endElement</li>
</ul>
</li>
</ul>
<h2 id="常用的解析器"><a href="#常用的解析器" class="headerlink" title="常用的解析器"></a>常用的解析器</h2><h3 id="JAXP"><a href="#JAXP" class="headerlink" title="JAXP"></a>JAXP</h3><ul>
<li>sun公司提供的解析。支持dom和sax。</li>
</ul>
<h3 id="JDOM"><a href="#JDOM" class="headerlink" title="JDOM"></a>JDOM</h3><h3 id="PULL"><a href="#PULL" class="headerlink" title="PULL"></a>PULL</h3><ul>
<li>android内置的解析器</li>
<li>sax方式</li>
</ul>
<h3 id="DOM4J"><a href="#DOM4J" class="headerlink" title="DOM4J"></a>DOM4J</h3><ul>
<li><code>dom for java</code></li>
<li>民间方式，但是非常好。  支持dom</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ol>
<li>导入jar包 dom4j.jar</li>
<li>创建解析器<br> <code>SAXReader reader = new SAXReader();</code></li>
<li>解析xml 获得document对象<br> <code>Document document = reader.read(url);</code></li>
</ol>
<h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><ul>
<li>XML路径语言，它是一种用来确定XML文档中某部分位置的语言</li>
<li>专门用于查询</li>
</ul>
<h3 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h3><ul>
<li>一款java的html解析器，可以直接解析某个url地址、html文本内容。它提供了jQuery的操作方法来取出和操作数据</li>
</ul>
<h4 id="Jsoup-1"><a href="#Jsoup-1" class="headerlink" title="Jsoup"></a>Jsoup</h4><ul>
<li>工具类，可以解析html或xml文档，返回Document对象</li>
</ul>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul>
<li><code>static Document parse(File file, String character)</code><ul>
<li>解析html或xml文件</li>
</ul>
</li>
<li><code>static Document parse(String html)</code><ul>
<li>解析html或xml字符串</li>
<li>把html或xml 以字符串传入</li>
</ul>
</li>
<li><code>static Document parse(Url url, int timoutMillis)</code><ul>
<li>解析网络上的html或xml</li>
</ul>
</li>
</ul>
<h4 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h4><ul>
<li>文档对象，代表内存中的dom树</li>
<li>继承Element</li>
</ul>
<h5 id="方法-从Element中继承来的"><a href="#方法-从Element中继承来的" class="headerlink" title="方法(从Element中继承来的)"></a>方法(从Element中继承来的)</h5><ul>
<li><code>Element getElementById(String id)</code><ul>
<li>根据id获取元素对象</li>
</ul>
</li>
<li><code>Elements getElementsByClass(String className)</code><ul>
<li>根据class获取元素对象集合</li>
</ul>
</li>
<li><code>Elements getElementsByTag(String tagName)</code><ul>
<li>根据标签名获取元素对象集合</li>
</ul>
</li>
<li><code>Elements getElementsByAttribute(String key)</code><ul>
<li>根据属性名获取元素对象集合</li>
</ul>
</li>
<li><code>Elements getElementsByAttribute(String key, String value)</code><ul>
<li>根据属性名和值获取元素对象集合</li>
</ul>
</li>
</ul>
<h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h4><ul>
<li>元素对象的集合，可以当作<code>ArrayList&lt;Element</code>来使用</li>
</ul>
<h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><ul>
<li>元素对象</li>
<li>继承Node</li>
</ul>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul>
<li><code>String attr(String key)</code><ul>
<li>根据属性名获取值</li>
</ul>
</li>
<li><code>String text()</code><ul>
<li>获取文本内容</li>
</ul>
</li>
<li><code>String html()</code><ul>
<li>获取标签体所有内容</li>
</ul>
</li>
</ul>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><ul>
<li>节点对象</li>
</ul>
<h4 id="快捷查询"><a href="#快捷查询" class="headerlink" title="快捷查询"></a>快捷查询</h4><ol>
<li>使用选择器<ul>
<li><code>Elements select(String csssQuery)</code><ul>
<li>语法：参考selector中的定义</li>
</ul>
</li>
</ul>
</li>
<li>使用xpath</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Json/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Json/" itemprop="url">
                  xd-Json
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:37:29" itemprop="dateCreated datePublished" datetime="2018-12-11T00:37:29+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-05 01:26:33" itemprop="dateModified" datetime="2019-01-05T01:26:33+08:00">2019-01-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UI/" itemprop="url" rel="index"><span itemprop="name">UI</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据载体"><a href="#数据载体" class="headerlink" title="数据载体"></a>数据载体</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>服务端响应的是普通html字符串，无需JS解析，配合innerHTML属性效率高</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>如果需要更新WEB页面中的很多处地方，HTML不太方便，同时innerHTML属性不是DOM的标准，不能操作XML</li>
<li>注意<ul>
<li>innerHTML在xml中不能使用，用<code>firstChild.nodeValue</code>替代</li>
</ul>
</li>
</ul>
<h3 id="适合"><a href="#适合" class="headerlink" title="适合"></a>适合</h3><ul>
<li>小量数据载体，且只更新在web页面中的一个地方</li>
<li><code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code></li>
</ul>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><ul>
<li>重量级的数据交换语言</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>是种通用的普通字符串格式，任何技术都能解析，标签名可以任意，使用DOM标准规则能够解析XML的任何部分</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>XML文件格式相当严格，出错后，responseXML属性返回NULL，如果XML文件过长，导致解析效率低下</li>
</ul>
<h3 id="适合-1"><a href="#适合-1" class="headerlink" title="适合"></a>适合</h3><ul>
<li>大量具有层次数据载体</li>
<li><code>response.setContentType(&quot;text/xml;charset=utf-8&quot;)</code></li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>轻量级的数据交换语言</li>
<li>兼备HTML和XML的特点</li>
<li><code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code></li>
</ul>
<h1 id="JSON-1"><a href="#JSON-1" class="headerlink" title="JSON"></a>JSON</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><code>JavaScript Object Notation(记号，标记)</code></li>
<li>一种轻量级的数据交换语言，以文本字符串为基础，易于阅读。</li>
<li>采用完全独立于任何程序语言的文本格式，使JSON成为理想的数据交换语言</li>
<li>JSON本质上，就是用JS语法写的特殊文本记号，用JS可以直接解析，所以必须放在<code>&lt;script&gt;</code>标签中</li>
<li>JSON是不能完完全全替代XML的，只能在定义对象和数据交换语言方面替代</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul>
<li><code>{}</code>表示一个对象</li>
<li><code>[]</code>表示一个数组</li>
<li>键值对之间用<code>,</code>分割</li>
<li>对象与对象之间用<code>,</code>分割</li>
<li>键与值之间用<code>:</code></li>
<li>键<ul>
<li>可以用<code>&quot;&quot;</code>或<code>&#39;&#39;</code>也可以不加引号。</li>
</ul>
</li>
<li>值<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（必须用引号）</li>
<li>逻辑值（true/false）</li>
<li>数组（<code>[]</code>）</li>
<li>对象（<code>{}</code>）</li>
</ul>
</li>
</ul>
<h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var json = &#123;</span><br><span class="line">	键:值,</span><br><span class="line">	键:值,</span><br><span class="line">	...</span><br><span class="line">	键:值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var json = [</span><br><span class="line">	&#123;键:值,键:值&#125;,</span><br><span class="line">	&#123;键:[&#123;键:值&#125;]&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var json = &#123;</span><br><span class="line">	键:[&#123;键:值,键:值&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><ol>
<li><code>json对象.键</code></li>
<li><code>json对象[&quot;键&quot;]</code></li>
<li><code>json数组对象[索引]</code></li>
</ol>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h3><ul>
<li><p><code>for in</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var key in json对象) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意遍历中获取的<code>key</code>是json对象的键，是字符串形式，本身就带引号</p>
<ul>
<li><code>json对象.key</code><ul>
<li>获取数据是错误的，因为相当于<code>person.&quot;name&quot;</code></li>
</ul>
</li>
<li><code>json对象[key]</code><ul>
<li>这样可以获取数据，key不用加引号了，相当于<code>person[&quot;name&quot;]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><ul>
<li>先for循环遍历数组，获取每一个json对象，然后<code>for in</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 数组.length; i++) &#123;</span><br><span class="line">	var json对象 = 数组[i];</span><br><span class="line">	for (var key in json对象)&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="简化JavaScript自定义对象-。"><a href="#简化JavaScript自定义对象-。" class="headerlink" title="简化JavaScript自定义对象**。"></a>简化JavaScript自定义对象**。</h3><ul>
<li><p>javascript自定义对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Person(id,name)&#123;</span><br><span class="line">	this.id=id;</span><br><span class="line">	this.name=name;</span><br><span class="line">	this.show=function()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person=new Person(1,&quot;旺财&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>json格式自定义对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var person=&#123;</span><br><span class="line">			id:1,</span><br><span class="line">			name:&quot;旺财&quot;,</span><br><span class="line">			show:function()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="在AJAX中，作为数据载体之一"><a href="#在AJAX中，作为数据载体之一" class="headerlink" title="在AJAX中，作为数据载体之一"></a>在AJAX中，作为数据载体之一</h3><ul>
<li>如果JSON是采用JS格式书写的的，JS可以直接解析JSON</li>
<li>如果JSON是采用Java格式写的，必须使用eval()函数转换后，方可被JS解析<ul>
<li><code>eval(&quot;&quot;)</code><ul>
<li>将字符串当作脚本进行解析运行</li>
<li>函数接收一个字符串格式的内容。</li>
<li><code>eval(&quot;(&quot;+jsonJava+&quot;)&quot;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Struts2-Json"><a href="#Struts2-Json" class="headerlink" title="Struts2+Json"></a>Struts2+Json</h1><ol>
<li>导入<code>struts2-json-plugin.jar</code></li>
<li><code>struts.xml</code>配置中<code>&lt;package extends=&quot;json-default&quot;&gt;</code><ul>
<li><code>json-default</code>继承了<code>struts-default</code>所以还是继承了<code>struts-default</code>,只是多了json的功能。</li>
</ul>
</li>
<li><code>struts.xml</code>配置中<code>&lt;result type=&quot;json&quot;&gt;</code></li>
<li>action中只要是<code>getAbc()</code>形式的方法就能自动返回java格式的json(安)<ul>
<li>将get后边的首字母小写作为json的键</li>
<li>将方法的返回值作为值<ul>
<li><code>getNameById(){return &quot;success&quot;;}</code><ul>
<li><code>jsonJava={nameById:&quot;success&quot;}</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>成员变量要先初始化</strong>。</li>
<li>如果get形式的方法有很多，只想要指定的某个。<ul>
<li><code>&lt;result type=&quot;json&quot;&gt;&lt;param name=&quot;root&quot;&gt;指定的键&lt;/param&gt;&lt;/result&gt;</code><ul>
<li>这样返回的json不是键值对，而是只有指定键的值。(安)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>返回的java格式的json js不能直接解析要转成js的json<ul>
<li><code>jsonJs=eval(&quot;(&quot;+jsonJava+&quot;)&quot;);</code></li>
</ul>
</li>
</ol>
<h1 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>json数据与java对象的相互转换</li>
<li><strong>json→java对象</strong><ul>
<li>客户端发送json数据给服务器，服务器端将json转为java对象使用。</li>
</ul>
</li>
<li><strong>java对象→json</strong><ul>
<li>服务器端将java对象转为json，响应给客户端</li>
</ul>
</li>
</ul>
<h2 id="常见解析器"><a href="#常见解析器" class="headerlink" title="常见解析器"></a>常见解析器</h2><h3 id="Jsonlib"><a href="#Jsonlib" class="headerlink" title="Jsonlib"></a>Jsonlib</h3><ul>
<li>将JavaBean/list/set/map…转为json</li>
<li>这只是第三方工具之一。</li>
</ul>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li>导入jar包<ul>
<li><code>json-lib.jar</code></li>
<li><code>ezmorph.jar</code></li>
<li><code>commons-logging.jar</code></li>
<li><code>commons-lang.jar</code></li>
<li><code>commons-beanutils.jar</code></li>
<li><code>commons-collections.jar</code></li>
</ul>
</li>
<li>JSONObject &amp; JSONArray<ul>
<li>JSONObject<ul>
<li><code>static JSONObject fromObject(...)</code></li>
</ul>
</li>
<li>JSONArray<ul>
<li><code>static JSONArray fromObject(...)</code></li>
</ul>
</li>
</ul>
</li>
<li>调用toString()返回的是java格式的json</li>
</ol>
<h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><ul>
<li><code>Gson gson = new Gson()</code></li>
<li><code>String json = gson.toJson(数据)</code></li>
</ul>
<h2 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h2><h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2><h3 id="java对象→json-使用步骤"><a href="#java对象→json-使用步骤" class="headerlink" title="java对象→json 使用步骤"></a>java对象→json 使用步骤</h3><ol>
<li>导入jar包<ul>
<li><code>jackson-core.jar</code></li>
<li><code>jackson-databind.jar</code></li>
<li><code>jackson-annotations.jar</code></li>
</ul>
</li>
<li>创建jackson核心对象<code>ObjectMapper</code><ul>
<li><code>new ObjectMapper()</code></li>
</ul>
</li>
<li>使用ObjectMapper进行转换</li>
</ol>
<h3 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h3><ul>
<li><code>writeValue(参数1,Object obj)</code><ul>
<li>参数1<ul>
<li><code>File</code>：将obj对象转为json字符串，并保存到指定文件</li>
<li><code>Writer</code>：将obj对象转为json字符串，并关联到字符输出流</li>
<li><code>OutputStream</code>：将obj对象转为json字符串，并关联到字节输出流</li>
<li><code></code></li>
</ul>
</li>
</ul>
</li>
<li><code>String writeValueAsString(Object obj)</code><ul>
<li>将obj对象转为json字符串</li>
</ul>
</li>
<li><code>readValue(String json, Class clazz)</code><ul>
<li>将json字符串转为java对象</li>
</ul>
</li>
</ul>
<h3 id="复杂对象转json的格式"><a href="#复杂对象转json的格式" class="headerlink" title="复杂对象转json的格式"></a>复杂对象转json的格式</h3><ul>
<li>list set<ul>
<li>数组</li>
</ul>
</li>
<li>map<ul>
<li>对象</li>
</ul>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li><code>@JsonIgnore</code><ul>
<li>忽略该属性</li>
</ul>
</li>
<li><code>@JsonFormat</code><ul>
<li><code>@JsonFormat(patter=&quot;yyyy-MM-dd&quot;)</code></li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Jquery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Jquery/" itemprop="url">
                  xd-Jquery
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:37:12" itemprop="dateCreated datePublished" datetime="2018-12-11T00:37:12+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-05 01:54:10" itemprop="dateModified" datetime="2019-01-05T01:54:10+08:00">2019-01-05</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UI/" itemprop="url" rel="index"><span itemprop="name">UI</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>jQuery 是一个 JavaScript 库。</li>
<li>jQuery 极大地简化了 JavaScript 编程。</li>
</ul>
<h2 id="其它流行的库"><a href="#其它流行的库" class="headerlink" title="其它流行的库"></a>其它流行的库</h2><ul>
<li><strong>Bootstrap</strong><ul>
<li>来自twitter,基于jquery的一个ui工具</li>
</ul>
</li>
<li><code>http:docs.kissyui.com</code><ul>
<li>淘宝ui</li>
</ul>
</li>
<li><code>Dojo</code><ul>
<li>很多js单独文件，优化，打包(常见：开发小图标，一张图片)</li>
</ul>
</li>
<li><code>EXT_JS</code><ul>
<li>2.0开始收费</li>
</ul>
</li>
</ul>
<h2 id="Jquery分类"><a href="#Jquery分类" class="headerlink" title="Jquery分类"></a>Jquery分类</h2><h3 id="web版"><a href="#web版" class="headerlink" title="web版"></a>web版</h3><h3 id="UI版"><a href="#UI版" class="headerlink" title="UI版"></a>UI版</h3><ul>
<li>集成了ui组件</li>
</ul>
<h3 id="mobile版"><a href="#mobile版" class="headerlink" title="mobile版"></a>mobile版</h3><ul>
<li>移动端开发</li>
</ul>
<h3 id="qunit版"><a href="#qunit版" class="headerlink" title="qunit版"></a>qunit版</h3><ul>
<li>用于js测试</li>
</ul>
<h2 id="jquery版本说明"><a href="#jquery版本说明" class="headerlink" title="jquery版本说明"></a>jquery版本说明</h2><h3 id="1x"><a href="#1x" class="headerlink" title="1x"></a><code>1x</code></h3><ul>
<li>兼容ie678,使用最为广泛的，官方只做BUG维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4 (2016年5月20日)</li>
</ul>
<h3 id="2x"><a href="#2x" class="headerlink" title="2x"></a><code>2x</code></h3><ul>
<li>不兼容ie678，很少有人使用，官方只做BUG维护，功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，最终版本：2.2.4 (2016年5月20日)</li>
</ul>
<h3 id="3x"><a href="#3x" class="headerlink" title="3x"></a><code>3x</code></h3><ul>
<li>不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。目前该版本是官方主要更新维护的版本。</li>
</ul>
<h1 id="js-amp-jquery"><a href="#js-amp-jquery" class="headerlink" title="js &amp; jquery"></a>js &amp; jquery</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table>
<thead>
<tr>
<th>API</th>
<th>javascript</th>
<th>jquery</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>获取标签失败</strong></td>
<td>没有提示</td>
<td>提示undefined</td>
</tr>
<tr>
<td><strong>获取标签value</strong></td>
<td>value</td>
<td>val()</td>
</tr>
<tr>
<td><strong>获取标签体的值</strong></td>
<td>innerHTML</td>
<td>html() <br>text()</td>
</tr>
<tr>
<td><strong>删除标签</strong></td>
<td>removeChild()</td>
<td>remove()</td>
</tr>
<tr>
<td><strong>添加标签</strong></td>
<td>appendChild()</td>
<td>append()</td>
</tr>
<tr>
<td><strong>创建标签并添加属性</strong></td>
<td>var div=document.createElement(“div”);<br>div.setAttribute(“id”,”divID”)</td>
<td>var $div=$(“&lt;div id=’divID’&gt;&lt;/div&gt;”)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>jquery的html()和text()区别</strong><ul>
<li><code>html()</code><ul>
<li>强调的是标签中的内容，即便标签中的子标签，也会显示出来</li>
<li>要用于html/jsp，不能用在xml</li>
</ul>
</li>
<li><code>text()</code><ul>
<li>强调的是标签中的文本内容，即便标签中的子标签，也只会显示出文本内容，不会显示子标签</li>
<li>既能用于html/jsp，且能用于xml</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><ul>
<li><strong>js→jquery</strong><ul>
<li><code>jquery=$(js);</code></li>
</ul>
</li>
<li><strong>jquery-&gt;js</strong><ul>
<li>jquery是一个数组</li>
<li><code>js=jquery[0];</code></li>
<li><code>js=jquery.get(0);</code></li>
<li>jquery对象为一个数组,求大小<ul>
<li><code>size()</code></li>
<li><code>length</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><h2 id="selector"><a href="#selector" class="headerlink" title="$(selector)"></a><code>$(selector)</code></h2><h2 id="html"><a href="#html" class="headerlink" title="$(html)"></a><code>$(html)</code></h2><ul>
<li>1.8版本+</li>
<li>新建一个html标签的jqury对象</li>
<li>传入的是html标签完整书写的字符串<ul>
<li><code>var $div=$(&quot;&lt;div id=&#39;1&#39;&gt;xxx&lt;/div&gt;&quot;)</code></li>
</ul>
</li>
</ul>
<h2 id="fn"><a href="#fn" class="headerlink" title="$(fn)"></a><code>$(fn)</code></h2><ul>
<li><code>$(document).ready(fn)</code>的简写</li>
</ul>
<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="each-obj-fn"><a href="#each-obj-fn" class="headerlink" title="$.each(obj, fn)"></a><code>$.each(obj, fn)</code></h2><h2 id="jQuery对象-each-fn"><a href="#jQuery对象-each-fn" class="headerlink" title="jQuery对象.each(fn)"></a><code>jQuery对象.each(fn)</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;id&quot;).each(function(index, domEle)&#123;</span><br><span class="line">	this;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>this<ul>
<li>是js对象</li>
<li>转成jQuery对象<ul>
<li><code>$(this)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>index</code><ul>
<li>遍历的索引</li>
</ul>
</li>
<li><code>domEle</code><ul>
<li>相当于this</li>
</ul>
</li>
</ul>
<h2 id="for-of"><a href="#for-of" class="headerlink" title="for..of"></a>for..of</h2><ul>
<li>jquery3x才有的方式，类似增强for<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(a of b)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><ul>
<li><code>$(&quot;#id&quot;)</code></li>
<li><code>$(&quot;html标签名&quot;)</code></li>
<li><code>$(&quot;.class&quot;)</code></li>
<li><code>$(&quot;*&quot;)</code><ul>
<li>所有元素</li>
</ul>
</li>
<li><code>$(&quot;s1,s2,s3......)</code><ul>
<li>选择器可以并列</li>
</ul>
</li>
</ul>
<h2 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 s2	* s1下的所有s2标签(子，孙，重孙...)</span><br><span class="line">s1&gt;s2	* s1下的子级s2标签</span><br><span class="line">s1+s2	* s1同级的第一个标签(若非s2则undefined)</span><br><span class="line">s1~s2	* s1同级的所有s2标签(只会往s1下找,上边的不算)</span><br></pre></td></tr></table></figure>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[attribute]		   * 包含指定属性</span><br><span class="line">[attribute=value]	 * 指定属性的值为value</span><br><span class="line">[attribute!=value]	* 指定属性的值不为value(没有这个属性也包含在内)</span><br><span class="line">[attribute^=value]	* 指定属性的值以value开头</span><br><span class="line">[attribute$=value]	* 指定属性的值以value结尾</span><br><span class="line">[attribute*=value]	* 指定属性的值包含value</span><br><span class="line">[s1][s2][selectorN]   * 同时满足多个条件相当于&quot;&amp;&amp;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:first		* 第一个</span><br><span class="line">:last 		* 最后一个</span><br><span class="line">:not(s)	   * 非</span><br><span class="line">:even		 * 偶数索引 索引从0开始</span><br><span class="line">:odd		  * 奇数索引</span><br><span class="line">:eq(index)	* equles</span><br><span class="line">:gt(index)	* great than</span><br><span class="line">:lt(index)	* low than</span><br><span class="line">:header	   * 标题h1，h2...</span><br><span class="line">:animated 	* 获取所有动画</span><br><span class="line">:focus		* 获取焦点</span><br></pre></td></tr></table></figure>
<h2 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">:input	* 匹配所有 input, textarea, select 和 button 元素</span><br><span class="line">:type 	* type为</span><br><span class="line">			* text </span><br><span class="line">			* password</span><br><span class="line">			* radio</span><br><span class="line">			* checkbox</span><br><span class="line">			* submit</span><br><span class="line">			* image</span><br><span class="line">			* reset</span><br><span class="line">			* button</span><br><span class="line">			* file</span><br><span class="line">			* hidden</span><br><span class="line">				* 匹配所有不可见元素，或者type为hidden的元素</span><br></pre></td></tr></table></figure>
<h2 id="表单对象属性选择器"><a href="#表单对象属性选择器" class="headerlink" title="表单对象属性选择器"></a>表单对象属性选择器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:enabled	 * 匹配所有可用元素</span><br><span class="line">:disabled	* 匹配所有不可用元素(1`xxx disabled=&quot;disabled&quot;` 2`xxx disabled=&quot;&quot;` 3`xxx disabled`)</span><br><span class="line">:checked	 * 匹配所有选中的元素(复选框、单选框等,不包括select中的option)</span><br><span class="line">:selected	* 匹配下拉框所有选中的option元素</span><br></pre></td></tr></table></figure>
<h2 id="内容选择器"><a href="#内容选择器" class="headerlink" title="内容选择器"></a>内容选择器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:contains(text)		* 元素是否包含文本</span><br><span class="line">:empty				 * 是否为空(没有标签体(子元素，文本))</span><br><span class="line">:has(selector)		 * 是否包含某个selector</span><br><span class="line">:parent				* 是否是父元素(包含文本或者子标签)</span><br></pre></td></tr></table></figure>
<h2 id="可见性选择器"><a href="#可见性选择器" class="headerlink" title="可见性选择器"></a>可见性选择器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:hidden		* 匹配所有不可见元素(style=&quot;display:none&quot;)，或者type为hidden的元素</span><br><span class="line">:visible	   * 匹配所有的可见元素</span><br></pre></td></tr></table></figure>
<h2 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">:first-child	* 为每个父元素匹配第一个子元素</span><br><span class="line">					* :first有多个匹配也只返回文档中第一个符合的。</span><br><span class="line">:last-child	 * 为每个父元素匹配最后一个子元素</span><br><span class="line">					* :last有多个匹配也只返回文档中第一个符合的。</span><br><span class="line">:only-child	 * 如果某个元素是父元素中唯一的子元素，那将会被匹配</span><br><span class="line">:nth-child()	* 匹配其父元素下的第N个子或奇偶元素,索引从1开始。</span><br><span class="line">					* :eq(index)有多个匹配也只返回文档中第一个符合的。</span><br><span class="line">				* 可以写</span><br><span class="line">					* :nth-child(even)</span><br><span class="line">					* :nth-child(odd)</span><br><span class="line">					* :nth-child(3n)</span><br><span class="line">					* :nth-child(2)</span><br><span class="line">					* :nth-child(3n+1)</span><br><span class="line">					* :nth-child(3n+2)</span><br></pre></td></tr></table></figure>
<ul>
<li>表达式前边必须是元素<ul>
<li><code>$(&quot;div:nth-child(2)&quot;)</code></li>
</ul>
</li>
<li>如果元素加了条件，必须使用空格<ul>
<li><code>$(&quot;div[id=&#39;xx&#39;]空格:nth-child(2))</code></li>
</ul>
</li>
</ul>
<h1 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h1><h2 id="文档内容"><a href="#文档内容" class="headerlink" title="文档内容"></a>文档内容</h2><h3 id="获取-amp-设置"><a href="#获取-amp-设置" class="headerlink" title="获取&amp;设置"></a>获取&amp;设置</h3><ul>
<li><code>html()</code><ul>
<li>空参<ul>
<li>获取标签体，包含标签</li>
</ul>
</li>
<li>有参<ul>
<li>设置标签体</li>
</ul>
</li>
</ul>
</li>
<li><code>text()</code><ul>
<li>空参<ul>
<li>获取标签体纯文本内容</li>
</ul>
</li>
<li>有参<ul>
<li>设置标签体</li>
</ul>
</li>
</ul>
</li>
<li><code>val()</code><ul>
<li>空参<ul>
<li>获取元素value属性的值</li>
</ul>
</li>
<li>有参<ul>
<li>设置元素value属性的值 </li>
<li><code>val(&quot;&quot;)</code><ul>
<li>设置value属性值为””，相当于清空</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li><code>append()</code><ul>
<li>添加到父元素尾部</li>
<li><code>A.append(B)</code><ul>
<li>B添加到A内部</li>
</ul>
</li>
<li>想把一个select的option选项移到另一个。只需把这个select的option对象加入要移动到的select对象中。</li>
</ul>
</li>
<li><code>appendTo()</code><ul>
<li><code>A.appendTo(B)</code><ul>
<li>A添加到B内部</li>
</ul>
</li>
</ul>
</li>
<li><code>prepend()</code><ul>
<li>添加到父元素首部</li>
</ul>
</li>
<li><code>prependTo()</code></li>
<li><code>after()</code><ul>
<li>添加到兄弟元素之后</li>
</ul>
</li>
<li><code>before()</code><ul>
<li>添加到兄弟元素之前    </li>
</ul>
</li>
<li><code>insertAfter()</code><ul>
<li>添加到兄弟元素之后</li>
</ul>
</li>
<li><code>insertBefore()</code><ul>
<li>添加到兄弟元素之前    </li>
</ul>
</li>
</ul>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul>
<li><code>replaceWith()</code></li>
<li><code>replaceAll()</code></li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li><code>remove()</code><ul>
<li>删除自已及后代节点</li>
<li>移除绑定事件及绑定数据</li>
</ul>
</li>
<li><code>detach()</code><ul>
<li>删除</li>
<li>保留绑定事件及绑定数据</li>
</ul>
</li>
<li><code>empty()</code><ul>
<li>将后代元素清空，但保留自己及属性节点</li>
</ul>
</li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul>
<li><code>clone()</code><ul>
<li>只复制样式，不复制行为</li>
</ul>
</li>
<li><code>clone(true)</code><ul>
<li>既复制样式，又复制行为</li>
</ul>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><code>$.trim(str)</code><ul>
<li>去掉字符串起始和结尾的空格</li>
</ul>
</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul>
<li><code>data(key,value)</code><ul>
<li>绑定数据</li>
</ul>
</li>
<li><code>data(key)</code><ul>
<li>获取绑定数据</li>
</ul>
</li>
<li><code>removeData(key)</code><ul>
<li>移除绑定数据</li>
</ul>
</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>attr(key)</code><ul>
<li>获取元素指定属性key的值。</li>
</ul>
</li>
<li><code>attr(key,value)</code><ul>
<li>设置元素指定属性key的值为指定的值value。</li>
<li>可以串写。<ul>
<li><code>$().attr(key,value).attr(key,value);</code></li>
</ul>
</li>
</ul>
</li>
<li><code>removeAttr(key)</code><ul>
<li>删除元素指定属性key。</li>
</ul>
</li>
<li><code>prop</code><ul>
<li>用法同attr</li>
<li>如果是标签的固有属性，建议prop，自定义建议attr。</li>
</ul>
</li>
</ul>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><ul>
<li><code>css(key,value)</code><ul>
<li>添加样式属性key值value</li>
<li>可串写<ul>
<li><code>$().css(key,value).css(key,value)</code></li>
</ul>
</li>
<li>可以写多个值<ul>
<li><code>$().css({&quot;width&quot;:&quot;10px&quot;,&quot;height&quot;:&quot;10px&quot;,...});</code></li>
</ul>
</li>
</ul>
</li>
<li><code>addClass(&quot;class&quot;)</code><ul>
<li>添加样式class</li>
</ul>
</li>
<li><code>removeClass(&quot;class&quot;)</code><ul>
<li>删除样式class</li>
</ul>
</li>
<li><code>toggleClass(&quot;class&quot;)</code><ul>
<li>如果标签有样式class就删除，否则增加样式class</li>
</ul>
</li>
<li><code>hasClass(&quot;class&quot;)</code><ul>
<li>是否有样式class</li>
</ul>
</li>
</ul>
<h2 id="位置尺寸"><a href="#位置尺寸" class="headerlink" title="位置尺寸"></a>位置尺寸</h2><ul>
<li><code>offset()</code><ul>
<li>获取匹配元素在当前视口的相对偏移。</li>
<li>获取的是json对象</li>
<li>属性<ul>
<li>top</li>
<li>left</li>
</ul>
</li>
</ul>
</li>
<li><code>offset({top:value,left:value})</code><ul>
<li>设置匹配元素在当前视口的left和top坐标</li>
</ul>
</li>
<li><code>width()</code><ul>
<li>获取元素的宽度</li>
</ul>
</li>
<li><code>width(value)</code><ul>
<li>设置元素的宽度为value</li>
</ul>
</li>
<li><code>height()</code><ul>
<li>获取元素的高度</li>
</ul>
</li>
<li><code>height(value)</code><ul>
<li>设置元素的高度为value</li>
</ul>
</li>
</ul>
<h1 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>选择器能完成的，筛选提供相同函数</li>
<li>例<ul>
<li>选择器<code>:first</code></li>
<li>筛选<code>first()</code></li>
<li>区别<ul>
<li><code>$(&quot;div:first&quot;)</code><ul>
<li>直接获取第一个div(只能操作第一个)</li>
</ul>
</li>
<li><code>$(&quot;div&quot;).first()</code><ul>
<li>先获取所有div，再从所有中获取第一个。(可以操作第一个，也可以操作所有)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul>
<li><code>eq(index | -index)</code><ul>
<li>index 从0开始</li>
<li>-index 倒数，从-1开始</li>
</ul>
</li>
<li><code>first()</code></li>
<li><code>last()</code></li>
<li><code>is(expr | obj | ele | fn)</code><ul>
<li>判断</li>
<li>如<code>is($&quot;option:selected&quot;)</code></li>
</ul>
</li>
<li><code>filter(expr | obj | ele | fn)</code><ul>
<li>筛选出与指定表达式匹配的元素集合</li>
<li>安<ul>
<li>两个选择器挨着写类似于筛选</li>
<li><code>$(&quot;div.myClass&quot;)</code></li>
<li><code>$(&quot;div&quot;).filter(&quot;.myClass&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>not(expr | ele | fn)</code><ul>
<li>相当于从结果集中移除</li>
</ul>
</li>
<li><code>has(expr | ele)</code></li>
<li><code>slice(start, [end])</code><ul>
<li>截取元素，含头不含尾</li>
</ul>
</li>
<li><code>map(callback)</code></li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><code>children()</code><ul>
<li>获取所有子元素，不包括后代元素。</li>
</ul>
</li>
<li><code>next()</code><ul>
<li>获取下一个兄弟元素。</li>
</ul>
</li>
<li><code>nextAll()</code></li>
<li><code>prev()</code><ul>
<li>获取上一个兄弟元素</li>
</ul>
</li>
<li><code>prevAll()</code></li>
<li><code>siblings()</code><ul>
<li>获取所有兄弟元素</li>
</ul>
</li>
<li><code>parent()</code><ul>
<li>父元素</li>
</ul>
</li>
<li><code>closest()</code><ul>
<li>向上获取指定父元素(包含自己)</li>
</ul>
</li>
<li><code>find(expr)</code><ul>
<li>查找符合筛选的元素</li>
</ul>
</li>
</ul>
<h2 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h2><ul>
<li>将多条语句改为一条（装x用）</li>
<li><code>add()</code><ul>
<li><code>A.add(B)</code></li>
<li>将AB组合成一个对象，类似<code>$(&quot;A,B&quot;)</code></li>
</ul>
</li>
<li><code>addSelf()</code><ul>
<li>将之前对象添加到…</li>
<li><code>A.children().addSelf()</code></li>
<li>将A添加到A的后代中</li>
</ul>
</li>
<li><code>contents()</code></li>
<li><code>end()</code><ul>
<li>回到最后一个“破坏性”操作之前。</li>
<li><code>A.children().end()</code></li>
<li>回到A的后代之前，就是A</li>
</ul>
</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="页面加载"><a href="#页面加载" class="headerlink" title="页面加载"></a>页面加载</h2><ol>
<li><code>$(document).ready(fn)</code><ul>
<li>标准API</li>
</ul>
</li>
<li><code>$(fn)</code><ul>
<li>简化版</li>
</ul>
</li>
</ol>
<h3 id="js与jquery页面加载的区别"><a href="#js与jquery页面加载的区别" class="headerlink" title="js与jquery页面加载的区别"></a>js与jquery页面加载的区别</h3><ul>
<li><code>window.onload=function(){}</code><ul>
<li>可以写多个onload但是后者会覆盖前者。</li>
</ul>
</li>
<li><code>$(fn)</code><ul>
<li>可以写多个ready,会依次执行不会覆盖。</li>
<li>ready和onload同时存在时，二者都会触发执行，ready快于onload</li>
</ul>
</li>
</ul>
<h2 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h2><ul>
<li><code>change()</code><ul>
<li>当内容改变时触发</li>
</ul>
</li>
<li><code>click()</code><ul>
<li>单击</li>
</ul>
</li>
<li><code>dblclick()</code><ul>
<li>双击</li>
</ul>
</li>
<li><code>blur()</code><ul>
<li>失去焦点</li>
</ul>
</li>
<li><code>focus()</code><ul>
<li>焦点获取</li>
</ul>
</li>
<li><code>select()</code><ul>
<li>文本框或文本域被选中</li>
</ul>
</li>
<li><code>keyup()</code><ul>
<li>鼠标弹起</li>
<li>ie浏览器会自动创建event事件对象.<ul>
<li><code>event.keyCode</code><br>  获取按键的unicode编码</li>
<li><code>event.clientX</code><ul>
<li>获取鼠标x坐标</li>
</ul>
</li>
<li><code>event.clientY</code><ul>
<li>获取鼠标y坐标</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>keydown()</code></li>
<li><code>keypress()</code></li>
<li><code>mousedown</code></li>
<li><code>mousemove()</code><ul>
<li>鼠标在指定区域中不断移动触发</li>
</ul>
</li>
<li><code>mouseover()</code><ul>
<li>鼠标移入时触发</li>
</ul>
</li>
<li><code>mouseout()</code><ul>
<li>鼠标移出时触发</li>
</ul>
</li>
<li><code>submit()</code><ul>
<li>提交表单时触发，true表示提交，false表示不提交</li>
</ul>
</li>
</ul>
<h3 id="juqery提供的额外事件，用于完善js缺失的"><a href="#juqery提供的额外事件，用于完善js缺失的" class="headerlink" title="juqery提供的额外事件，用于完善js缺失的"></a>juqery提供的额外事件，用于完善js缺失的</h3><ul>
<li><code>focusin</code><ul>
<li>获得焦点</li>
<li>与focus区别<ul>
<li>可以在父元素上检测子元素的焦点获得</li>
</ul>
</li>
</ul>
</li>
<li><code>focusout</code><ul>
<li>失去焦点</li>
<li>与blur区别 同上</li>
</ul>
</li>
<li><code>mouseenter</code><ul>
<li>鼠标移入</li>
<li>与mouseover区别<ul>
<li>在父元素与子元素之间穿越时，不触发</li>
</ul>
</li>
</ul>
</li>
<li><code>mouseleave</code><ul>
<li>鼠标移岀</li>
</ul>
</li>
</ul>
<h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><ul>
<li><code>jq对象.事件方法名(fn);</code><ul>
<li>标准方式</li>
<li><code>$().ckick(fn).focus(fn).change(fn);</code><ul>
<li>可以连续绑定。</li>
</ul>
</li>
</ul>
</li>
<li><code>on/off(事件方法名,fn)</code><ul>
<li>绑定/解绑事件</li>
<li><code>jq对象.on(&quot;click blur change&quot;,fn)</code><ul>
<li>可以绑定多个，用空格隔开，表示都执行后边的一个方法</li>
</ul>
</li>
<li><code>jq对象.off()</code><ul>
<li>解除所有绑定的事件</li>
</ul>
</li>
</ul>
</li>
<li><code>toggle(fn1,fn2...)</code><ul>
<li>事件切换</li>
<li>第一次执行fn1,依此类推，执行完，从头开始</li>
</ul>
</li>
<li><code>bind(type,fn)</code><ul>
<li>给当前对象绑定<strong>一个</strong>事件</li>
<li>例<ul>
<li><code>$().bind(&quot;click&quot;,fn);</code></li>
</ul>
</li>
</ul>
</li>
<li><code>unbind(type)</code><ul>
<li>解绑，会解绑所有绑定事件。</li>
<li>解绑指定的事件，可以使用别名</li>
<li><strong>事件别名</strong><ul>
<li>格式<ul>
<li><code>事件.别名</code></li>
</ul>
</li>
<li>例<ul>
<li><code>$().bind(&quot;click.aaa&quot;,fn);</code></li>
<li><code>$().unbind(&quot;click.aaa&quot;);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>triggerHandler(type)</code><ul>
<li>在每一个匹配的元素上触发某类事件</li>
</ul>
</li>
<li><code>triggerHa(type)</code><ul>
<li>在每一个匹配的元素上触发某类事件。但不会执行浏览器默认动作，也不会产生事件冒泡</li>
</ul>
</li>
</ul>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><h2 id="显示隐藏"><a href="#显示隐藏" class="headerlink" title="显示隐藏"></a>显示隐藏</h2><p>通过改变元素<strong>宽和高</strong>，来显示和隐藏</p>
<ul>
<li><code>show(speed,easing,fn)</code><ul>
<li>speed<ul>
<li>时间值</li>
<li>固定字符串 slow normal,fast 等等</li>
</ul>
</li>
<li>easing<ul>
<li>swing<ul>
<li>默认，动画效果 慢-块-慢</li>
</ul>
</li>
<li>linear<ul>
<li>动画匀速</li>
</ul>
</li>
</ul>
</li>
<li>fn<ul>
<li>动画执行完，执行的函数</li>
</ul>
</li>
</ul>
</li>
<li><code>hide()</code></li>
<li><code>toggle()</code><ul>
<li>切换</li>
</ul>
</li>
</ul>
<h2 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h2><p>通过改变元素<strong>高</strong>，来滑动显示和隐藏</p>
<ul>
<li><code>slideUp()</code><ul>
<li>向上滑动</li>
</ul>
</li>
<li><code>slideDown()</code><ul>
<li>向下滑动</li>
</ul>
</li>
<li><code>slideToggle()</code><ul>
<li>上下切换滑动</li>
</ul>
</li>
</ul>
<h2 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h2><p>通过改变元素<strong>透明度</strong>，来淡入淡出显示和隐藏</p>
<ul>
<li><code>fadeIn()</code><ul>
<li>淡入显示</li>
</ul>
</li>
<li><code>fadeOut()</code><ul>
<li>淡出隐藏</li>
</ul>
</li>
<li><code>fadeToggle()</code><ul>
<li>切换</li>
</ul>
</li>
<li><code>fadeTo(speed,opacity,fn)</code><ul>
<li>指定透明度</li>
<li>opacity 透明度<ul>
<li>0-1之间的数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li>用于增强jQuery功能</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="fn-extend-json格式"><a href="#fn-extend-json格式" class="headerlink" title="$.fn.extend(json格式)"></a><code>$.fn.extend(json格式)</code></h3><ul>
<li>增强通过jQuery获取的对象的功能</li>
</ul>
<h3 id="extend-obj"><a href="#extend-obj" class="headerlink" title="$.extend(obj)"></a><code>$.extend(obj)</code></h3><ul>
<li>增强jQuery对象自身的功能（$/jQeury）</li>
</ul>
<h1 id="jquery中的ajax"><a href="#jquery中的ajax" class="headerlink" title="jquery中的ajax"></a>jquery中的ajax</h1><h2 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h2><h3 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h3><ul>
<li><code>$.ajax()</code><ul>
<li>最底层ajax请求，编写复杂，功能最全</li>
</ul>
</li>
</ul>
<h3 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h3><ul>
<li><code>load(),$.get(),$.post()</code></li>
</ul>
<h3 id="第三层-高级开发"><a href="#第三层-高级开发" class="headerlink" title="第三层 高级开发"></a>第三层 高级开发</h3><ul>
<li><code>$.getJSON()</code><ul>
<li>可以完成js<strong>跨域</strong>请求</li>
<li>域名：域名+端口+项目</li>
<li>js默认不能跨域请求</li>
</ul>
</li>
<li><code>$.getScript()</code><ul>
<li>相当于<code>&lt;script src=&quot;&quot;&gt;</code>导入js</li>
<li>这个可以动态加载js</li>
</ul>
</li>
</ul>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	url:&quot;&quot;,</span><br><span class="line">	type:&quot;&quot;,</span><br><span class="line">	data:&quot;&quot;,</span><br><span class="line">	async:true,</span><br><span class="line">	dataType:&quot;&quot;,</span><br><span class="line">	success:function()&#123;&#125;,</span><br><span class="line">	error:function()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>url</strong><ul>
<li>请求地址</li>
</ul>
</li>
<li><strong>type</strong><ul>
<li>GET或POST…，默认GET。</li>
</ul>
</li>
<li><strong>data</strong><ul>
<li>请求数据</li>
<li><code>key=value</code>字符串或者json</li>
</ul>
</li>
<li><strong>async</strong><ul>
<li>是否异步，默认true。false为同步。</li>
</ul>
</li>
<li><strong>dataType</strong><ul>
<li>响应数据类型</li>
<li><code>xml html json text script jsonp</code></li>
</ul>
</li>
<li><strong>success</strong><ul>
<li>请求成功后的回调函数(参数可选)</li>
<li><code>function(data,textStatus,XHR){}</code><ul>
<li>data<ul>
<li>响应数据，已根据dataType参数进行处理后的数据</li>
</ul>
</li>
<li>textStatus<ul>
<li>描述状态的字符串</li>
</ul>
</li>
<li>XHR<ul>
<li>ajax引擎,XMLHttpRequest对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>error</strong><ul>
<li>请求失败时调用此函数(参数可选)</li>
<li><code>function(XMLHttpRequest,textStatus,errorThrown){}</code><ul>
<li>XMLHttpRequest<ul>
<li>XMLHttpRequest对象</li>
</ul>
</li>
<li>textStatus<ul>
<li>错误信息</li>
</ul>
</li>
<li>errorThrown<ul>
<li>捕获的异常对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="s-load"><a href="#s-load" class="headerlink" title="$(s).load()"></a>$(s).load()</h2><ul>
<li><code>$(jquery对象).load(url,[sendData],[callback])</code><ul>
<li>调用时必须使用jquery对象。</li>
<li><strong>url</strong><ul>
<li>请求地址</li>
</ul>
</li>
<li><strong>sendData</strong><ul>
<li>请求参数<ul>
<li><code>key=value</code>字符串或者json</li>
<li>无参数则为GET请求</li>
<li>有参数则为POST请求</li>
</ul>
</li>
</ul>
</li>
<li><strong>callback</strong><ul>
<li>回调函数</li>
<li><code>function(backData,textStatus,XHR){}</code><ul>
<li><strong>backData</strong><ul>
<li>响应数据</li>
<li>load永远获取的是字符串，使用需要手动转成json</li>
<li><code>var jsonData=eval(&quot;(&quot;+backData+&quot;)&quot;);</code></li>
</ul>
</li>
<li>textStatus<ul>
<li>描述状态的字符串（success,error…）</li>
</ul>
</li>
<li>XHR<ul>
<li>ajax引擎，XMLHttpRequest对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>load方法的编码<ul>
<li>请求自动编码</li>
<li>响应存在中文乱码，需要设置<ul>
<li><code>res.setContentType(&quot;application/json;charset=UTF-8&quot;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="get"><a href="#get" class="headerlink" title="$.get()"></a>$.get()</h2><ul>
<li><code>$.get(url,[sendData],[callback],[type]){})</code><ul>
<li>请求时存在乱码，需要手动解码<code>new String(...)</code></li>
<li><strong>type</strong><ul>
<li>客户端认为的服务器响应数据类型</li>
<li>“json”</li>
</ul>
</li>
<li>客户端将服务器响应数据当作json<ol>
<li><code>application/json;charset=utf-8</code><ul>
<li>通过设置响应mime类型，直接告诉客户端响应的就是json</li>
</ul>
</li>
<li><code>text/html;charset-utf-8</code><ul>
<li>需要通过设置参数type</li>
<li><strong><code>type=json</code></strong>，客户端才会将数据当作json</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="post"><a href="#post" class="headerlink" title="$.post"></a>$.post</h2><ul>
<li><code>$.post(url,[sendData],[callback],[type]){})</code><ul>
<li>请求时存在乱码，需要设置，其它同get</li>
</ul>
</li>
</ul>
<h3 id="安"><a href="#安" class="headerlink" title="安"></a>安</h3><ul>
<li>backData和xmlHttpRequest.responseText区别<ul>
<li>backData是js对象</li>
<li>xmlHttpRequest.responseText是字符串</li>
</ul>
</li>
<li>用jquery解析xml文件时xml就是js对象<ul>
<li>可以按照js的api解析xml</li>
</ul>
</li>
<li>ajax解析xml文件，直接把url写成xml地址即可</li>
</ul>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h2><ul>
<li><code>serialize()</code><ul>
<li><code>$(&quot;form&quot;).serialize()</code></li>
<li>将表单中所有项拼凑成一个字符串，类似get请求参数<ul>
<li><code>usernmae=an3&amp;passwrod=123&amp;...</code></li>
</ul>
</li>
<li>将表单项的name属性作为key</li>
<li>注意：<ul>
<li>必须用<code>&lt;form&gt;</code>标签元素</li>
<li>为每个jQuery对象设置一个name属性，因为name属性会被认为请求参数名</li>
<li>如果属性过多，强烈推荐采用这个API </li>
</ul>
</li>
</ul>
</li>
<li><code>serializeArray()</code><ul>
<li>将表单中所有项拼凑成一个json数组<ul>
<li><code>[{&quot;name&quot;:&quot;an3&quot;},{&quot;password&quot;:&quot;123&quot;},{}...]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>子元素事件触发时，也会触发父元素事件。</p>
<ul>
<li>阻止事件冒泡<ol>
<li><code>return false</code></li>
<li><code>event.stopPropagation()</code><ul>
<li>阻止事件冒泡（传播行为）</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="浏览器默认行为"><a href="#浏览器默认行为" class="headerlink" title="浏览器默认行为"></a>浏览器默认行为</h2><ul>
<li>如a标签的默认跳转行为</li>
<li>阻止默认行为<ol>
<li><code>return false</code></li>
<li><code>event.preventDefault()</code><ul>
<li>阻止默认事件行为的触发</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="附-跨域"><a href="#附-跨域" class="headerlink" title="附 跨域"></a>附 跨域</h1><ul>
<li><strong>域</strong><ul>
<li>服务器域名，唯一标识（协议，域名，端口）必须保证一致，说明域相同。</li>
</ul>
</li>
<li><strong>跨域</strong><ul>
<li>在一个服务器上，去访问另一个服务器。</li>
<li>两个不同域名之间的通信。</li>
</ul>
</li>
<li>js如果调用另一个域程序，不能执行当前域的js函数。</li>
<li><strong>js的跨域处理</strong></li>
<li><strong>JSONP</strong><ul>
<li>是json的一种“使用模式”，可以从别的域要资料。</li>
<li>可以通过<code>&lt;script&gt;</code>这个元素的开放策略，从其它源动态的获取json，这种使用模式就叫JSONP.</li>
<li>大致原理<ul>
<li>现又两个服务器<code>tom1</code>，<code>tom2</code>，1要从2获取数据。</li>
<li>则1中<ul>
<li><code>&lt;script src=&quot;&quot;&gt;</code></li>
<li>src中是指向2的请求地址。而由于不同域，2响应的json数据，1的回调函数是无法接收的。所以需要在请求地址中将回调函数名称当作参数传给2.<ul>
<li><code>http:.../xxx?callback=showData()</code></li>
</ul>
</li>
<li>2获取1的回调函数后，将回调函数域json数据组合后响应给1，意思是通知1调用这个函数。<ul>
<li>响应的是一个函数</li>
<li><code>res.print(callback+&quot;(&quot;&quot;+jsonData+&quot;&quot;)&quot;)</code></li>
<li>callback<ul>
<li>1传过来的回调函数名</li>
</ul>
</li>
<li>jsonData<ul>
<li>2的json数据</li>
</ul>
</li>
</ul>
</li>
<li>这样1就会执行回调函数，并有了json数据</li>
</ul>
</li>
<li>注意，1中回到函数写在<code>&lt;script&gt;</code>标签前，以免找不到函数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>jquery的跨域处理</strong><ul>
<li><code>$.getJson(url,[data],fn)</code><ul>
<li>url<ul>
<li>指向另一个域的请求地址</li>
<li>因为回调函数是匿名的所以url这样写<ul>
<li><code>http:.../xx?callback=?</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Ajax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Ajax/" itemprop="url">
                  xd-Ajax
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:36:58" itemprop="dateCreated datePublished" datetime="2018-12-11T00:36:58+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-04 16:43:29" itemprop="dateModified" datetime="2019-01-04T16:43:29+08:00">2019-01-04</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UI/" itemprop="url" rel="index"><span itemprop="name">UI</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><code>Asynchronous JavaScript And XML</code></li>
<li>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。</li>
<li>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新</li>
<li>传统<ul>
<li>客户端发送请求到服务端，服务端返回数据给客户端。</li>
</ul>
</li>
<li>Ajax<ul>
<li>客户端通过<code>javascript call</code> ajax引擎，由<code>ajax engine</code>发送请求到服务端，服务端，返回数据给<code>ajax engine</code>再由<code>ajax engine</code>把数据交给客户端</li>
</ul>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。</li>
</ul>
<h2 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h2><ul>
<li>客户端与服务器相互通信时<ul>
<li>同步<ul>
<li>客户端必须等待服务器的响应，等待期间客户端不能做其它操作</li>
</ul>
</li>
<li>异步<ul>
<li>客户端不需要等待服务器的响应，在服务器处理请求的过程中，客户端可以进行其它操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h1><ul>
<li>异步通讯对象</li>
<li>XMLHttpRequest 是 AJAX 的基础。</li>
<li>IE5 和 IE6 使用 <strong>ActiveXObject</strong></li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><code>onreadystatechange</code></li>
<li>存储函数（或函数名），每当 <code>readyState</code> 属性改变时，就会调用该函数。</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>readyState</code><ul>
<li>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</li>
<li>0<ul>
<li>请求未初始化</li>
</ul>
</li>
<li>1<ul>
<li>服务器连接已建立</li>
<li>已经调用了<code>open()</code>但没有真正发送请求</li>
</ul>
</li>
<li>2<ul>
<li>请求已接收</li>
<li>已调用<code>send()</code>但暂时没有到达服务器</li>
</ul>
</li>
<li>3<ul>
<li>请求处理中</li>
</ul>
</li>
<li>4<ul>
<li>请求已完成，且响应已就绪</li>
</ul>
</li>
</ul>
</li>
<li><code>status</code><ul>
<li>200<ul>
<li>OK</li>
</ul>
</li>
<li>404<ul>
<li>未找到页面</li>
</ul>
</li>
</ul>
</li>
<li><code>responseText</code><ul>
<li>获得字符串形式的响应数据。 </li>
</ul>
</li>
<li><code>responseXML</code><ul>
<li>获得 XML 形式的响应数据。</li>
</ul>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>open(method,url,async)</code><ul>
<li>method<ul>
<li>请求的类型；GET 或 POST</li>
</ul>
</li>
<li>url<ul>
<li>文件在服务器上的位置</li>
</ul>
</li>
<li>async<ul>
<li>true（异步，默认）</li>
<li>false（同步）</li>
</ul>
</li>
</ul>
</li>
<li><code>send(string)</code><ul>
<li>string<ul>
<li>发送的数据，仅用于 POST 请求。</li>
<li>POST发送前要设置请求头。<ul>
<li><code>setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-form-urlencoded&quot;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="创建AJAX"><a href="#创建AJAX" class="headerlink" title="创建AJAX"></a>创建AJAX</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ajax;</span><br><span class="line">if(window.XMLHttpRequest)&#123;</span><br><span class="line">	ajax=new XMLHttpRequest();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	ajax=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return ajax;</span><br></pre></td></tr></table></figure>
<h1 id="AJAX的使用"><a href="#AJAX的使用" class="headerlink" title="AJAX的使用"></a>AJAX的使用</h1><ol>
<li><strong>创建XMLHttpRequest对象</strong>。</li>
<li><p><strong>向服务器发送请求</strong></p>
<ul>
<li><p><strong>GET</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ajax.open(&quot;GET&quot;,&quot;url?name=&quot;+name);</span><br><span class="line">ajax.send();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>POST</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax.open(&quot;POST&quot;,&quot;url&quot;);</span><br><span class="line">ajax.setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">ajax.send(&quot;name=xxx&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>等待判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ajax.onreadystatechange=function()&#123;</span><br><span class="line">	if (ajax.readyState==4 &amp;&amp; ajax.status==200)&#123;</span><br><span class="line">		//获取返回的值</span><br><span class="line">		var res=ajax.responseText;</span><br><span class="line">		var res=ajax.responseXml;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul>
<li>服务端不能使用转发或重定向到web页面，因为这样会起浏览器全面刷新<ul>
<li>只能以流的方式响应给浏览器</li>
</ul>
</li>
<li>异步提交下form标签的action和method没有意义</li>
<li>AJAX适合用在什么地方<ul>
<li>AJAX【适合】不用来传递大量数据，而只用来【传递少量数据】，在用户的【体验】上，【更加人性化】。</li>
</ul>
</li>
<li>AJAX是一个和服务器无关的技术，即服务器可使用：JavaEE，.NET，PHP，。。。这些技术都可。AJAX只管向服务器发送请求，同时只管接收服务器的HTML或XML或JSON载体响应。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png"
                alt="安₃" />
            
              <p class="site-author-name" itemprop="name">安₃</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">59</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安₃</span>

  

  
</div>



<!--





-->





        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  


<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
