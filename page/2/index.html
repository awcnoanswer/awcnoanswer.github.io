<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="安₃">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="安₃">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安₃">






  <link rel="canonical" href="http://yoursite.com/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>安₃</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<!--github start-->
	<a href="https://github.com/awcnoanswer" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	<!--github end-->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安₃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/xd-工作流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/xd-工作流/" itemprop="url">
                  xd-工作流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-03 14:56:06" itemprop="dateCreated datePublished" datetime="2019-01-03T14:56:06+08:00">2019-01-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:48:38" itemprop="dateModified" datetime="2019-03-08T14:48:38+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/xd-工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/xd-工具/" itemprop="url">
                  xd-工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-28 00:44:53" itemprop="dateCreated datePublished" datetime="2018-12-28T00:44:53+08:00">2018-12-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:48:23" itemprop="dateModified" datetime="2019-03-08T14:48:23+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>在<code>commons-lang3.jar</code>中</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>boolean isEmpty(String s)</code><ul>
<li>判断字符串是否为空，不会去除字符串空格。</li>
<li><code>String s=null</code><ul>
<li>true</li>
</ul>
</li>
<li><code>String s=&quot;&quot;</code><ul>
<li>true</li>
</ul>
</li>
<li><code>String s=&quot; &quot;</code> <ul>
<li>false</li>
</ul>
</li>
</ul>
</li>
<li><code>boolean isBlank(String s)</code><ul>
<li>判断字符串是否为空，会去除字符串空格。    </li>
<li><code>String s=null</code><ul>
<li>true</li>
</ul>
</li>
<li><code>String s=&quot;&quot;</code><ul>
<li>true</li>
</ul>
</li>
<li><code>String s=&quot; &quot;</code> <ul>
<li>true</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>java编程中的数据库操作实用工具，小巧简单实用</li>
<li>封装了对JDBC的操作，简化了JDBC操作<ul>
<li>对于数据表的读操作，它可以把结果转换成List，Array，Set等等</li>
<li>对于数据表的写操作，只需写sql语句</li>
<li>可以使用数据源，使用JNDI，数据库连接池等技术来优化性能–重用已经构建好的数据库连接对象</li>
</ul>
</li>
<li>一个工具类,定义了关闭资源与事务处理的方法</li>
</ul>
<h2 id="QueryRunner"><a href="#QueryRunner" class="headerlink" title="QueryRunner"></a>QueryRunner</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>提供对sql语句操作的API.</li>
<li>构造和方法中<ul>
<li>有Connection参数可以自己控制事务</li>
<li>没有Connection参数自动事务</li>
</ul>
</li>
</ul>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul>
<li><code>QueryRunner([boolean pmdKnownBroken])</code></li>
<li><code>QueryRunner(DataSource ds,[boolean pmdKnownBroken])</code><ul>
<li>true<ul>
<li>Oracle使用</li>
</ul>
</li>
<li>false或空参<ul>
<li>mysql    </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>&lt;T&gt; T query(String sql,ResultSetHandler&lt;T&gt; rsh,[Object... params])</code><ul>
<li>查询select</li>
</ul>
</li>
<li><code>int update([Connection conn].String sql,[Object... params])</code><ul>
<li>增删改(insert delete update)</li>
<li>int 影响行数</li>
</ul>
</li>
<li><code>int[] batch([Connection conn],String sql,Object[][] params)</code><ul>
<li>批处理</li>
</ul>
</li>
</ul>
<h4 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><ul>
<li>用于定义select操作后，怎样封装结果集</li>
</ul>
<h5 id="结果处理器"><a href="#结果处理器" class="headerlink" title="结果处理器"></a>结果处理器</h5><ul>
<li><code>ArrayHandler</code><ul>
<li>适合取1条记录。把该条记录的每列值封装到一个数组中Object[]</li>
<li><code>Object[]</code></li>
</ul>
</li>
<li><code>ArrayListHandler</code><ul>
<li>适合取多条记录。把每条记录的每列值封装到一个数组中Object[]，把数组封装到一个List中</li>
<li><code>List&lt;Object[]&gt;</code></li>
</ul>
</li>
<li><code>ColumnListHandler</code><ul>
<li>取某一列的数据(sql语句中的某一列)。封装到List中</li>
<li><code>List&lt;Object&gt;</code></li>
</ul>
</li>
<li><code>KeyedHandler</code><ul>
<li>取多条记录，每一条记录封装到一个Map中，再把这个Map封装到另外一个Map中，key为指定的字段值。</li>
<li><code>Map&lt;自定义key,Map&lt;列名,列值&gt;&gt;</code></li>
</ul>
</li>
<li><code>MapHandler</code><ul>
<li>适合取1条记录。把当前记录的列名和列值放到一个Map中</li>
<li><code>Map&lt;列名,列值&gt;</code></li>
</ul>
</li>
<li><code>MapListHandler</code><ul>
<li>适合取多条记录。把每条记录封装到一个Map中，再把Map封装到List中</li>
<li><code>List&lt;Map&lt;列名,列值&gt;&gt;</code></li>
</ul>
</li>
<li><code>ScalarHandler</code><ul>
<li>适合取单行单列数据</li>
<li>如取<code>count(*)</code></li>
<li><code>Object</code></li>
</ul>
</li>
<li><code>BeanHandler</code><ul>
<li>取一个对象</li>
<li><code>Object</code></li>
</ul>
</li>
<li><code>BeanListHandler</code><ul>
<li><code>取对象的集合</code></li>
<li><code>List&lt;Object&gt;</code></li>
</ul>
</li>
</ul>
<h1 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul>
<li>spring 提供用于操作JDBC工具类，类似DBUtils</li>
<li>依赖 连接池DataSource （数据源）</li>
</ul>
<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>update(String sql, Object... obj)</code><ul>
<li>执行DML语句 （增删改）</li>
</ul>
</li>
<li><code>queryForMap(String sql, Object... obj)</code><ul>
<li>查询的结果集封装为map集合</li>
<li>此方法查询结果集长度只能是1<ul>
<li>列名为key，列值为value</li>
</ul>
</li>
</ul>
</li>
<li><code>queryForList(String sql, Object... obj)</code><ul>
<li>将每一条记录封装为map集合，然后将map集合封装到list集合中</li>
<li><code>List&lt;Map&lt;String, Object&gt;&gt;</code></li>
</ul>
</li>
<li><code>query(String sql, RowMapper&lt;Object obj&gt; rowMapper, Object... obj)</code><ul>
<li>查询结果封装为javabean对象，然后封装到list集合</li>
<li><code>List&lt;Object obj&gt;</code></li>
</ul>
</li>
<li><code>queryForObject(String sql, Class&lt;? extends Object&gt; type, Object... obj)</code><ul>
<li>查询结果封装为对象（通常是基本数据类型包装类）</li>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
</ul>
<h3 id="RowMapper"><a href="#RowMapper" class="headerlink" title="RowMapper"></a>RowMapper</h3><ul>
<li>类似于DBUtils的ResultSetHandler</li>
<li>可以自己实现，也可使用提供的</li>
</ul>
<h4 id="BeanPropertyRowMapper"><a href="#BeanPropertyRowMapper" class="headerlink" title="BeanPropertyRowMapper"></a>BeanPropertyRowMapper</h4><ul>
<li>将结果集封装为对象，然后存在list中</li>
</ul>
<h1 id="内省-Introspector"><a href="#内省-Introspector" class="headerlink" title="内省(Introspector)"></a>内省(Introspector)</h1><h2 id="Introspector"><a href="#Introspector" class="headerlink" title="Introspector"></a>Introspector</h2><ul>
<li>Introspector根据<code>JavaBean.class</code>构建一个BeanInfo对象。</li>
<li>BeanInfo封装了一个类的所有属性</li>
<li>由BeanInfo获取属性描述器<code>PropertyDescriptor</code><ul>
<li><code>Method getReadMethod()</code><ul>
<li>对应get</li>
</ul>
</li>
<li><code>Method getWriteMethod()</code><ul>
<li>对应set</li>
</ul>
</li>
</ul>
</li>
<li>开发框架时，经常使用java对象的属性来封装程序的数据，每次都使用反射来完成此类操作过于麻烦。</li>
</ul>
<h2 id="java-beans"><a href="#java-beans" class="headerlink" title="java.beans"></a>java.beans</h2><ul>
<li>sun公司开发的一套api专门用于操作java对象的属性。</li>
<li>上述操作太过繁琐，Apache组织开发了一套api以简化编写</li>
</ul>
<h2 id="Beanutils"><a href="#Beanutils" class="headerlink" title="Beanutils"></a>Beanutils</h2><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><ul>
<li><code>void setProperty(Object bean,String filedName,Object value)</code></li>
<li><code>String getProperty(Object bean,String filedName)</code></li>
<li><code>void populate(Object bean,Map map)</code><ul>
<li>map中存字段名和值的键值对。</li>
</ul>
</li>
</ul>
<h3 id="PropertyUtils"><a href="#PropertyUtils" class="headerlink" title="PropertyUtils"></a>PropertyUtils</h3><h3 id="ConvertUtils"><a href="#ConvertUtils" class="headerlink" title="ConvertUtils"></a>ConvertUtils</h3><ul>
<li><code>void register(Converter con,Class&lt;?&gt; clazz)</code><ul>
<li>注册转换器</li>
<li>Beanutils默认支持8种基本类型，自动转换。</li>
<li>对于如日期需要先注册转换器。</li>
<li>使用<ul>
<li>在上述<code>BeanUtils</code>赋值前，调用一下。</li>
<li>可以使用内部类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="发邮件"><a href="#发邮件" class="headerlink" title="发邮件"></a>发邮件</h1><ul>
<li><code>javaMail.jar</code></li>
<li>然后工具类指定一些配置即可。</li>
</ul>
<h1 id="JS-插件"><a href="#JS-插件" class="headerlink" title="JS 插件"></a>JS 插件</h1><h3 id="validate-js"><a href="#validate-js" class="headerlink" title="validate.js"></a>validate.js</h3><ul>
<li>校验插件</li>
<li><p>使用</p>
<ul>
<li><p><code>$(&quot;form表单&quot;).validate(json数据);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#myForm&quot;).validate(&#123;</span><br><span class="line">	rules:&#123;</span><br><span class="line">		&quot;username&quot;:&#123;</span><br><span class="line">			&quot;required&quot;:true</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;password&quot;:&#123;</span><br><span class="line">			&quot;rerquired&quot;:true</span><br><span class="line">			&quot;rangelength&quot;:[6,12]</span><br><span class="line">		&#125;,	</span><br><span class="line">		......</span><br><span class="line">	&#125;,</span><br><span class="line">	messages:&#123;</span><br><span class="line">		&quot;username&quot;:&#123;</span><br><span class="line">			&quot;required&quot;:&quot;用户名不能为空&quot;,			</span><br><span class="line">		&#125;，</span><br><span class="line">		&quot;password&quot;:&#123;</span><br><span class="line">			&quot;rerquired&quot;:true</span><br><span class="line">			&quot;rangelength&quot;:&quot;密码长度6-12&quot;</span><br><span class="line">		&#125;,	</span><br><span class="line">		.......		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个规则，一个信息</p>
</li>
<li>可自定义规则</li>
</ul>
</li>
</ul>
<h1 id="第三方支付"><a href="#第三方支付" class="headerlink" title="第三方支付"></a>第三方支付</h1><h2 id="国付宝"><a href="#国付宝" class="headerlink" title="国付宝"></a>国付宝</h2><h2 id="连连支付"><a href="#连连支付" class="headerlink" title="连连支付"></a>连连支付</h2><ul>
<li>拍拍贷</li>
<li>陆金所</li>
<li>温商贷</li>
<li>玖富</li>
<li>360金融</li>
<li>点融 </li>
</ul>
<h2 id="易宝"><a href="#易宝" class="headerlink" title="易宝"></a>易宝</h2><h1 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h1><h2 id="邮箱客户端"><a href="#邮箱客户端" class="headerlink" title="邮箱客户端"></a>邮箱客户端</h2><ul>
<li>客户端<ul>
<li>foxmail</li>
<li>outlook</li>
</ul>
</li>
<li>网页</li>
</ul>
<h2 id="邮箱服务端"><a href="#邮箱服务端" class="headerlink" title="邮箱服务端"></a>邮箱服务端</h2><ul>
<li>邮件的接收和推送</li>
</ul>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul>
<li>接收<ul>
<li>POP3</li>
<li>IMAP</li>
</ul>
</li>
<li>发送<ul>
<li>SMTP</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/23/xd-日志/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/23/xd-日志/" itemprop="url">
                  xd-日志
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-23 17:28:05" itemprop="dateCreated datePublished" datetime="2018-11-23T17:28:05+08:00">2018-11-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:47:58" itemprop="dateModified" datetime="2019-03-08T14:47:58+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/xd-SSM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/xd-SSM/" itemprop="url">
                  xd-SSM
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-03 14:55:49" itemprop="dateCreated datePublished" datetime="2019-01-03T14:55:49+08:00">2019-01-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:46:37" itemprop="dateModified" datetime="2019-03-08T14:46:37+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-Springmvc"><a href="#Spring-Springmvc" class="headerlink" title="Spring + Springmvc"></a>Spring + Springmvc</h1><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><ul>
<li>通常情况下, 类似于数据源, 事务, 整合其他框架，还有Service/dao…都是放在 Spring 的配置文件中(而不是放在 SpringMVC 的配置文件中).</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>spring的ioc和springmvc的ioc容器都扫描，会创建两次bean<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;&quot; use-default-filters=&quot;&quot;&gt;</span><br><span class="line">	&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;&quot;/&gt;</span><br><span class="line">	&lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>通过排除或者包含来配置扫描哪个注解</li>
<li><code>use-default-filters</code><ul>
<li>默认true</li>
<li>如使用<code>include</code>，<code>use-default-filters</code>要设为<code>false</code></li>
<li>如使用<code>exclude</code>，<code>use-default-filters</code>要设为<code>true</code></li>
</ul>
</li>
<li><code>type</code><ul>
<li><code>annotation</code><ul>
<li><code>expression</code>为注解全类名</li>
</ul>
</li>
<li><code>assignable</code><ul>
<li><code>expression</code>为bean全类名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="springmvc的ioc和spring的ioc的关系"><a href="#springmvc的ioc和spring的ioc的关系" class="headerlink" title="springmvc的ioc和spring的ioc的关系"></a>springmvc的ioc和spring的ioc的关系</h2><p><img src="https://gitee.com/3noanswer/pics/raw/master/frame/springmvc-ioc和spring-ioc.png" alt=""></p>
<ul>
<li>spring的ioc包含springmvc的ioc<ul>
<li>springmvc的ioc的bean中可以获取spring的ioc的bean<ul>
<li>如在handler中可以获取service</li>
</ul>
</li>
<li>spring的ioc的bean中不可以获取springmvc的ioc的bean<ul>
<li>如在service中不能获取handler</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Spring-Mybatis"><a href="#Spring-Mybatis" class="headerlink" title="Spring + Mybatis"></a>Spring + Mybatis</h1><ol>
<li><code>mybatis-spring.jar</code></li>
<li>数据源和事务交给Spring配置</li>
<li><p>SqlSession对象的创建和管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">		&lt;!-- 数据源 --&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">		&lt;!-- 指定mybatis的全局配置文件的路径 --&gt;</span><br><span class="line">		&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;</span><br><span class="line">		&lt;!-- Mybatis的SQL映射文件--&gt;</span><br><span class="line">		&lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:cn/an/ssm/mapper/*.xml&quot;/&gt;</span><br><span class="line">		&lt;!--别名--&gt;</span><br><span class="line">		&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mapper接口代理实现类对象的创建和管理</p>
<ol>
<li><p>单个配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">			&lt;!-- 设置代理类的接口 --&gt;</span><br><span class="line">			&lt;property name=&quot;mapperInterface&quot; value=&quot;&quot;/&gt;</span><br><span class="line">			&lt;!-- 注入SqlSessionFactory --&gt;</span><br><span class="line">			&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量配置代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--默认代理类 id为类名首字母小写--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">			&lt;!-- 配置Mapper接口所在的包 --&gt;</span><br><span class="line">			&lt;property name=&quot;basePackage&quot; value=&quot;&quot;/&gt;</span><br><span class="line">			&lt;!-- 默认不需要配置SqlSessionFactory（只有一个SqlSessionFactory时），单独配置也可以 --&gt;</span><br><span class="line">			&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--另一种方式 和上边一样--&gt;</span><br><span class="line">&lt;mybatis-spring:scan base-package=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/xd-SSH/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/xd-SSH/" itemprop="url">
                  xd-SSH
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-03 14:55:42" itemprop="dateCreated datePublished" datetime="2019-01-03T14:55:42+08:00">2019-01-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:46:22" itemprop="dateModified" datetime="2019-03-08T14:46:22+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Spring/" itemprop="url">
                  xd-Spring
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:40:07" itemprop="dateCreated datePublished" datetime="2018-12-11T00:40:07+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:46:11" itemprop="dateModified" datetime="2019-03-08T14:46:11+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源容器框架<ul>
<li><strong>分层</strong><ul>
<li>web层：struts，spring-MVC</li>
<li>service层：spring</li>
<li>dao层：hibernate，mybatis ， jdbcTemplate  –&gt; spring-data</li>
</ul>
</li>
<li><strong>一站式</strong><ul>
<li>每一个层都提供的解决方案</li>
<li>在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上Spring 自身也提供了表述层的SpringMVC和持久层的Spring JDBC）</li>
</ul>
</li>
<li><strong>轻量级</strong><ul>
<li>与EJB对比，依赖资源少，销毁的资源少</li>
</ul>
</li>
</ul>
</li>
<li>Spring的核心是<strong>控制反转（IOC（DI））</strong>和<strong>面向切面（AOP）</strong></li>
</ul>
<h2 id="Spring-优良特性"><a href="#Spring-优良特性" class="headerlink" title="Spring 优良特性"></a>Spring 优良特性</h2><ol>
<li>非侵入式<ul>
<li>基于Spring开发的应用中的对象可以不依赖于Spring的API</li>
</ul>
</li>
<li>依赖注入<ul>
<li>DI——Dependency Injection，反转控制(IOC)最经典的实现</li>
</ul>
</li>
<li>面向切面编程<ul>
<li>Aspect Oriented Programming——AOP</li>
</ul>
</li>
<li>容器<ul>
<li>Spring是一个容器，因为它包含并且管理应用对象的生命周期</li>
</ul>
</li>
<li>组件化<ul>
<li>Spring实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象</li>
</ul>
</li>
</ol>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li><code>https://repo.spring.io/webapp/#/home</code><ul>
<li><code>artifacts</code>→<code>libs-release-loacl</code>→<code>springframework</code>→<code>spring</code></li>
</ul>
</li>
</ul>
<h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><ul>
<li>解耦和<ul>
<li>不直接new对象，通过反射创建对象，编译时就不依赖对象类了。</li>
<li>通过工厂，读取配置文件的方式。配置文件中<code>key=对象全类名</code></li>
</ul>
</li>
<li>单例<ul>
<li>每次都是用反射创建对象，是多例的，</li>
<li>而service和dao中通常没有成员变量，不存在线程安全问题，所以单例比较好。</li>
<li>在反射创建对象后，将对象存在一个容器中（如map），获取对象时从容器中获得，就是同一个对象了。</li>
</ul>
</li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li><code>Expert One-to-One J2EE Design and Development</code></li>
<li><code>Expert One-to-One J2EE Development without EJB</code></li>
</ul>
<h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><p><img src="https://gitee.com/3noanswer/pics/raw/master/spring-overview.png" alt=""></p>
<h2 id="Core-Container-核心容器"><a href="#Core-Container-核心容器" class="headerlink" title="Core Container(核心容器)"></a>Core Container(核心容器)</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ol>
<li><code>Beans</code><ul>
<li>管理bean    </li>
</ul>
</li>
<li><code>Core</code>    <ul>
<li>核心</li>
</ul>
</li>
<li><code>Context</code><ul>
<li>上下文(配置文件…)</li>
</ul>
</li>
<li><code>Expression Language</code><ul>
<li>SpEL(springEl表达式…)</li>
</ul>
</li>
</ol>
<h2 id="Aop-Aspect-Oriented-Programming"><a href="#Aop-Aspect-Oriented-Programming" class="headerlink" title="Aop(Aspect Oriented Programming)"></a>Aop(Aspect Oriented Programming)</h2><ol>
<li><code>AOP</code><ul>
<li>面向切面编程</li>
</ul>
</li>
<li><code>Aspects</code><ul>
<li>AOP框架</li>
</ul>
</li>
<li><code>Instrumentation</code></li>
<li><code>Messaging</code></li>
</ol>
<h2 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access/Integration"></a>Data Access/Integration</h2><ol>
<li><code>JDBC</code><ul>
<li>jdbc的支持 JdbcTemplate</li>
</ul>
</li>
<li><code>ORM</code><ul>
<li>对象关系映射</li>
</ul>
</li>
<li><code>OXM</code><ul>
<li>对象xml映射，集成orm框架</li>
</ul>
</li>
<li><code>JMS</code><ul>
<li>java消息服务</li>
</ul>
</li>
<li><code>Transactions</code></li>
</ol>
<h2 id="Web-MVC-Remoting"><a href="#Web-MVC-Remoting" class="headerlink" title="Web(MVC/Remoting)"></a>Web(MVC/Remoting)</h2><ol>
<li><code>Web</code></li>
<li><code>Servlet</code></li>
<li><code>Portlet</code></li>
<li><code>WebSocket</code></li>
<li><code>struts</code></li>
</ol>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><h1 id="Jar包"><a href="#Jar包" class="headerlink" title="Jar包"></a>Jar包</h1><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><ul>
<li><code>spring-core.jar</code><ul>
<li>IoC与DI的最基本实现</li>
<li>依赖<code>commons-logging.jar</code></li>
<li>其他模块都依赖了<code>spring-core.jar</code>，所以整个spring框架都依赖了<code>commons-logging.jar</code></li>
<li>如果有自己的日志实现如log4j，可以排除对<code>commons-logging</code>的依赖</li>
</ul>
</li>
<li><code>spring-jcl.jar</code><ul>
<li>spring集成了<code>commons-logging.jar</code></li>
</ul>
</li>
<li><code>spring-beans.jar</code><ul>
<li>Bean工厂与bean的装配</li>
</ul>
</li>
<li><code>spring-context.jar</code><ul>
<li>spring的上下文即IoC容器</li>
</ul>
</li>
<li><code>spring-expression.jar</code><ul>
<li>spring表达式语言</li>
</ul>
</li>
</ul>
<h2 id="Aop"><a href="#Aop" class="headerlink" title="Aop"></a>Aop</h2><ul>
<li><code>spring-aop.jar</code><ul>
<li>aop实现</li>
<li>依赖<code>aopalliance.jar</code><ul>
<li>aop联盟的包</li>
</ul>
</li>
</ul>
</li>
<li><code>spring-aspects.jar</code><ul>
<li>集成AspectJ</li>
<li>依赖<code>aspectjweaver.jar</code><ul>
<li>aspect规范</li>
</ul>
</li>
</ul>
</li>
<li><code>spring-instrument.jar</code><ul>
<li>提供一些类级的工具支持和ClassLoader级的实现，用于服务器</li>
</ul>
</li>
<li><code>spring-instrument-tomcat.jar</code><ul>
<li>针对tomcat的instrument实现</li>
</ul>
</li>
</ul>
<h2 id="data-access"><a href="#data-access" class="headerlink" title="data access"></a>data access</h2><ul>
<li><code>spring-jdbc.jar</code><ul>
<li>jdbc的支持</li>
</ul>
</li>
<li><code>spring-tx.jar</code><ul>
<li>事务控制</li>
</ul>
</li>
<li><code>spring-orm.jar</code><ul>
<li>对象关系映射，集成orm框架</li>
</ul>
</li>
<li><code>spring-oxm.jar</code><ul>
<li>对象xml映射</li>
</ul>
</li>
<li><code>spring-jms.jar</code><ul>
<li>java消息服务</li>
</ul>
</li>
</ul>
<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><ul>
<li><code>spring-web.jar</code><ul>
<li>基础web功能，如文件上传</li>
</ul>
</li>
<li><code>spring-webmvc.jar</code><ul>
<li>mvc实现</li>
</ul>
</li>
<li><code>spring-webmvc-portlet.jar</code><ul>
<li>基于portlet的mvc实现</li>
</ul>
</li>
<li><code>spring-struts.jar</code><ul>
<li>与struts的集成，不推荐，spring4不再提供</li>
</ul>
</li>
</ul>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><ul>
<li><code>spring-test.jar</code><ul>
<li>spring测试，提供junit与mock测试功能</li>
</ul>
</li>
</ul>
<h2 id="support"><a href="#support" class="headerlink" title="support"></a>support</h2><ul>
<li><code>spring-context-support.jar</code><ul>
<li>spring额外支持包，比如邮件服务、视图解析等</li>
</ul>
</li>
</ul>
<h1 id="IOC（Inversion-of-Control）"><a href="#IOC（Inversion-of-Control）" class="headerlink" title="IOC（Inversion of Control）"></a>IOC（<code>Inversion of Control</code>）</h1><ul>
<li>控制反转</li>
<li>把创建对象的权力交给Spring。</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>在应用程序中的组件需要获取资源时，传统的方式是组件主动的从容器中获取所需要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，增加了学习成本，同时降低了开发效率。</li>
<li>反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取方向——改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发的效率。这种行为也称为查找的被动形式</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>降低耦合。</p>
<h2 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h2><ul>
<li>DI（<code>Dependency Injection</code>）依赖注入</li>
<li>DL（<code>Dependency Lookup</code>）依赖查找</li>
</ul>
<h1 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><ul>
<li>IOC的另一种表述方式：即组件以一些预先定义好的方式(例如：setter 方法)接受来自于容器的资源注入。相对于IOC而言，这种表述更直接</li>
<li>IOC 描述的是一种思想，而DI 是对IOC思想的具体实现</li>
</ul>
<h2 id="bean之间的关系"><a href="#bean之间的关系" class="headerlink" title="bean之间的关系"></a>bean之间的关系</h2><ul>
<li>依赖<ul>
<li>一个对象需要使用另一个对象</li>
<li>has a：有一个，成员变量，依赖</li>
</ul>
</li>
<li>继承<ul>
<li>is a ：是一个，继承。</li>
<li><code>&lt;bean parent=&quot;&quot;&gt;&lt;/bean&gt;</code></li>
</ul>
</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="注解扫描"><a href="#注解扫描" class="headerlink" title="注解扫描"></a>注解扫描</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;&quot; use-default-filters=&quot;&quot;&gt;</span><br><span class="line">	&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;&quot;/&gt;</span><br><span class="line">	&lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>use-default-filters</code><ul>
<li>默认true</li>
<li>如使用<code>include</code>，<code>use-default-filters</code>要设为<code>false</code></li>
<li>如使用<code>exclude</code>，<code>use-default-filters</code>要设为<code>true</code></li>
</ul>
</li>
<li><code>type</code><ul>
<li><code>annotation</code><ul>
<li><code>expression</code>为注解全类名</li>
</ul>
</li>
<li><code>assignable</code><ul>
<li><code>expression</code>为bean全类名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="引入配置文件"><a href="#引入配置文件" class="headerlink" title="引入配置文件"></a>引入配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:包名xxx.properties&quot;/&gt;</span><br><span class="line">// 2</span><br><span class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;location&quot; value=&quot;classpath:包名xxx.properties&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>classpath</code><ul>
<li>工程分模块时，当前模块类路径下</li>
</ul>
</li>
<li><code>classpath*</code><ul>
<li>从所有模块类路径下</li>
</ul>
</li>
</ul>
<h1 id="核心API-了解"><a href="#核心API-了解" class="headerlink" title="核心API(了解)"></a>核心API(了解)</h1><h2 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h2><p><img src="https://gitee.com/3noanswer/pics/raw/master/springAPI体系.png" alt=""></p>
<ul>
<li>IOC在Spring中的实现<ol>
<li><code>BeanFactory</code></li>
<li><code>ApplicationContext</code></li>
</ol>
</li>
</ul>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><ul>
<li>spring原始接口，针对原始接口的实现类功能较为单一</li>
<li>IOC容器的基本实现，是Spring内部的基础设施，是面向Spring本身的，不是提供给开发人员使用的</li>
<li>特点<ul>
<li>此接口实现类的容器，每次获取对象时才会创建对象。</li>
<li><strong>延迟加载，第一次获取对象（getBean()）时才实例化Bean</strong></li>
</ul>
</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>Object getBean(String name)</code></li>
<li><code>T getBean(String name, Class&lt;T&gt; requiredType)</code></li>
</ul>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><ul>
<li>BeanFactory子接口，功能更强大。面向Spring的使用者<ul>
<li>国际化，事件传递，bean自动装配….</li>
</ul>
</li>
<li>特点<ul>
<li><strong>立即加载，配置文件一加载就会实例化配置的所有Bean</strong></li>
</ul>
</li>
</ul>
<h3 id="ApplicationContext实现类"><a href="#ApplicationContext实现类" class="headerlink" title="ApplicationContext实现类"></a>ApplicationContext实现类</h3><h4 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h4><ul>
<li>用于加载类路径下的xml</li>
</ul>
<h4 id="FileSystemXmlApplicaitonContext"><a href="#FileSystemXmlApplicaitonContext" class="headerlink" title="FileSystemXmlApplicaitonContext"></a>FileSystemXmlApplicaitonContext</h4><ul>
<li>用于加载磁盘任意路径下的xml</li>
</ul>
<h4 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h4><ul>
<li>用于读取注解创建容器</li>
</ul>
<h2 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h2><ul>
<li>是ApplicationContext的子接口，包含一些扩展方法</li>
<li>让ApplicationContext具有启动、关闭和刷新上下文的能力</li>
<li><code>refresh()</code></li>
<li><code>close()</code></li>
</ul>
<h2 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h2><ul>
<li>专门为WEB应用而准备的，它允许从相对于WEB根目录的路径中完成初始化工作</li>
</ul>
<h1 id="基于xml"><a href="#基于xml" class="headerlink" title="基于xml"></a>基于xml</h1><h2 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h2><h3 id="默认构造"><a href="#默认构造" class="headerlink" title="默认构造"></a>默认构造</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;bean全类名&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须提供空参构造，因为反射<code>newInstance()</code>调用的是默认空参构造</li>
</ul>
<h3 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot;  class=&quot;静态工厂全类名&quot;  factory-method=&quot;静态工厂中获取bean的静态方法&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>常用于    spring整合其他框架（工具）</li>
</ul>
<h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;工厂id&quot; class=&quot;工厂全限定类名&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;&quot; factory-bean=&quot;工厂id&quot; factory-method=&quot;工厂中获取bean的方法&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须先有工厂实例对象，通过工厂实例对象创建对象。</li>
</ul>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><ul>
<li>使用<ol>
<li>编写此接口实现类</li>
<li>配置实现类bean</li>
</ol>
</li>
<li>如果一个bean实现了FactoryBean，spring会把这个bean当成一个工厂，不再返回配置的bean类型，返回的bean类型为<code>getObjetct()</code>方法返回的类型</li>
<li>BeanFactory<ul>
<li>bean的工厂</li>
</ul>
</li>
<li>FactoryBean<ul>
<li>工厂bean</li>
</ul>
</li>
</ul>
<h2 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h2><ul>
<li><code>&lt;bean id=&quot;&quot; class=&quot;&quot;  scope=&quot;&quot;&gt;</code></li>
</ul>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><ul>
<li><code>singleton</code><ul>
<li>单例 默认</li>
<li>并非是JavaBean是单例的，而是容器中的bean是单例的，即在ioc容器中只能存在一个bean的对象。</li>
<li>IOC容器创建时就会创建bean</li>
</ul>
</li>
<li><code>prototype</code><ul>
<li>多例 每执行一次getBean将获得一个实例</li>
<li>启动容器并不会创建对象，获得 bean 的时候才会创建对象</li>
</ul>
</li>
<li><code>request</code><ul>
<li>作用于web应用的请求范围，仅适用于WebApplicationContext环境</li>
<li>每次http请求会创建一个新的bean</li>
</ul>
</li>
<li><code>session</code><ul>
<li>作用于web应用的会话范围，仅适用于WebApplicationContext环境</li>
<li>同一个HTTP session共享一个bean</li>
</ul>
</li>
<li><code>globalSession</code><ul>
<li>作用于集群环境的会话范围（全局会话范围）</li>
<li>若不是集群，就是<code>session</code></li>
</ul>
</li>
</ul>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h3><h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;an.s1.domain.User&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;id&quot; value=&quot;3&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;旺财&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;property&gt;</code><ul>
<li><code>name</code><ul>
<li>bean中set方法中的属性名</li>
</ul>
</li>
<li><code>value</code><ul>
<li>为基本类型数据赋值</li>
</ul>
</li>
<li><code>ref</code><ul>
<li>为引用类型数据赋值</li>
<li>一般是另一个bean 的id</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;an.s1.domain.User&quot;&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;name&quot; value=&quot;小强&quot;/&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;age&quot; value=&quot;24&quot;/&gt;</span><br><span class="line">	&lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;xx&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;constructor-arg&gt;</code><ul>
<li><code>name</code><ul>
<li>属性名</li>
</ul>
</li>
<li><code>index</code><ul>
<li>构造参数的索引 从0开始。</li>
<li>若只有索引，匹配到多个构造方法时，使用第一个匹配的。</li>
<li>配合type使用。</li>
</ul>
</li>
<li><code>type</code><ul>
<li>参数类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="P命名空间"><a href="#P命名空间" class="headerlink" title="P命名空间"></a>P命名空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;属性名&quot; value=&quot;普通值&quot; ref=&quot;引用值&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean p:属性名=&quot;普通值&quot; p:属性名-ref=&quot;引用值&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>对set方法注入进行简化，去掉了标签体中的<code>&lt;property&gt;</code>标签，用属性代替</li>
<li><code>&lt;property name=&quot;key&quot; value=&quot;value&quot;/&gt;</code>替换成<code>p:key=&quot;value&quot;</code></li>
</ul>
<h4 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;&quot; value=&quot;#&#123;spEL表达式&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>spEL表达式<ul>
<li><code>#{123}</code><ul>
<li>数字</li>
</ul>
</li>
<li><code>#{&#39;an&#39;}</code><ul>
<li>字符串</li>
</ul>
</li>
<li><code>#{beanId}</code><ul>
<li>另一个bean引用</li>
</ul>
</li>
<li><code>#{beanId.propName}</code><ul>
<li>操作属性数据</li>
</ul>
</li>
<li><code>#{beanId.toString()}</code><ul>
<li>执行方法</li>
</ul>
</li>
<li><code>#{xx?.method()}</code><ul>
<li>如果xx为空则不调用方法,不为空调用</li>
</ul>
</li>
<li><code>#{T(类).字段|方法}</code><ul>
<li>静态方法或字段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h3><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><ol>
<li><p>可以用字符串表示的值（基本类型及其封装类，String），可以通过value属性或value子节点的方式指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property value=&quot;值&quot;&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">	&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊字符</p>
<ol>
<li>使用实体（即html特殊符号如<code>&amp;nbmp/&amp;lt/</code>）</li>
<li><code>&lt;![CDATA[]]</code></li>
</ol>
</li>
</ol>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul>
<li>外部Bean<ul>
<li><code>ref</code></li>
</ul>
</li>
<li>内部Bean<ul>
<li>即直接在<code>&lt;property&gt;&lt;bean&gt;&lt;/bean&gt;&lt;/property&gt;</code>声明bean</li>
</ul>
</li>
<li>为引用类型级联赋值<ul>
<li>使用对象导航图</li>
</ul>
</li>
</ul>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><ul>
<li><code>&lt;null/&gt;</code><ul>
<li><code>&lt;property&gt;&lt;null/&gt;&lt;/property&gt;</code></li>
<li>不写默认其实也是null</li>
</ul>
</li>
</ul>
<h4 id="数组-集合的注入"><a href="#数组-集合的注入" class="headerlink" title="数组/集合的注入"></a>数组/集合的注入</h4><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><ul>
<li>分为两种结构，同一种结构的标签可以通用<ul>
<li><strong>list</strong><ul>
<li>数组，list，set</li>
</ul>
</li>
<li><strong>map</strong><ul>
<li>map，properties</li>
</ul>
</li>
</ul>
</li>
<li>还有一种注入的方法是使用<code>util</code>名称空间定义一个集合，然后直接在注入时<code>ref</code>引入即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;util:list id=&quot;&quot;&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;数组属性名&quot;&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">			&lt;ref bean=&quot;&quot;/&gt;</span><br><span class="line">			&lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">		&lt;/array&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;List属性名&quot;&gt;</span><br><span class="line">		&lt;list&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">			&lt;ref bean=&quot;&quot;/&gt;</span><br><span class="line">			&lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">		&lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;Set属性名&quot;&gt;</span><br><span class="line">		&lt;set&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">			&lt;ref bean=&quot;&quot;/&gt;</span><br><span class="line">			&lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">		&lt;/set&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;Map属性名&quot;&gt;</span><br><span class="line">		&lt;map&gt;</span><br><span class="line">			&lt;entry key=&quot;键&quot; value=&quot;值&quot; /&gt;</span><br><span class="line">		&lt;/map&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;Properties属性名&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;键&quot;&gt;值&lt;/prop&gt;</span><br><span class="line">			&lt;prop key=&quot;键&quot;&gt;值&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><p><img src="https://gitee.com/3noanswer/pics/raw/master/Bean实例化过程.png" alt=""></p>
<ol>
<li>instantiate bean<ul>
<li>对象实例化</li>
</ul>
</li>
<li>populate properties<ul>
<li>属性注入</li>
</ul>
</li>
<li>BeanNameAware <ul>
<li>如果Bean实现了BeanNameAware接口，执行 <code>setBeanName()</code>传入Bean的id</li>
</ul>
</li>
<li>BeanFactoryAware<ul>
<li>如果Bean实现了BeanFactoryAware接口，执行<code>setBeanFactory()</code>传入BeanFactory实例</li>
</ul>
</li>
<li>ApplicationContextAware <ul>
<li>如果Bean实现了ApplicationContextAware接口，执行<code>setApplicationContext()</code>传入ApplicationContext实例</li>
</ul>
</li>
<li><strong>BeanPostProcessor（后处理Bean）</strong><ul>
<li>如果Bean实现了BeanPostProcessor接口，执行<code>postProcessBeforeInitialization()</code>（前置处理）</li>
</ul>
</li>
<li>InitializingBean<ul>
<li>如果Bean实现了InitializingBean接口，执行<code>afterPropertiesSet()</code></li>
</ul>
</li>
<li><strong>Bean定义文件中的 init-method</strong><ul>
<li><code>&lt;bean init-method=&quot;初始化方法&quot;&gt;</code></li>
<li>若配置则执行此指定初始化方法</li>
</ul>
</li>
<li><strong>BeanPostProcessor（后处理Bean）</strong><ul>
<li>如果Bean实现了BeanPostProcessor接口，执行<code>postProcessAfterInitialization()</code>（后置处理）</li>
<li>此时，Bean已经可以被应用系统使用，并且将保留在BeanFactory中直到它不在被使用。</li>
</ul>
</li>
<li>执行业务处理</li>
<li>DisposableBean <ul>
<li>如果Bean实现了DisposableBean接口，执行 <code>destroy()</code></li>
</ul>
</li>
<li><strong>Bean定义文件中的 destroy-method</strong><ul>
<li><code>&lt;bean destroy-method=&quot;销毁方法&quot;&gt;</code></li>
<li>若配置则执行此指定销毁方法</li>
<li>销毁方法要执行<ul>
<li>必须关闭容器。</li>
<li>必须是单例</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="简单过程"><a href="#简单过程" class="headerlink" title="简单过程"></a>简单过程</h3><ol>
<li>实例化</li>
<li>属性注入</li>
<li>后处理bean-前置处理</li>
<li>初始化</li>
<li>后处理bean-后置处理</li>
<li>业务方法</li>
<li>销毁</li>
</ol>
<h3 id="单例Bean"><a href="#单例Bean" class="headerlink" title="单例Bean"></a>单例Bean</h3><ul>
<li>创建<ul>
<li>容器创建，bean就会创建</li>
</ul>
</li>
<li>存活<ul>
<li>容器存在，bean就存在</li>
</ul>
</li>
<li>销毁<ul>
<li>容器销毁，bean就销毁</li>
</ul>
</li>
</ul>
<h3 id="多例Bean"><a href="#多例Bean" class="headerlink" title="多例Bean"></a>多例Bean</h3><ul>
<li>创建<ul>
<li>第一次使用bean对象时，bean创建</li>
</ul>
</li>
<li>存活<ul>
<li>对象使用过程中，存活</li>
</ul>
</li>
<li>销毁<ul>
<li>当对象长时间不用，且没有别的对象引用时，由java垃圾回收器回收。</li>
</ul>
</li>
</ul>
<h3 id="BeanPostProcessor-后处理Bean"><a href="#BeanPostProcessor-后处理Bean" class="headerlink" title="BeanPostProcessor (后处理Bean)"></a>BeanPostProcessor (后处理Bean)</h3><ul>
<li>spring提供的工厂勾子，用于修改实例对象，如可以生成代理对象，是AOP底层</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>spring提供的一种机制，只要实现此接口，并将实现类提供给spring容器，spring容器将自动针对容器中所有bean<ul>
<li>在初始化方法前<ul>
<li>执行<code>postProcessBeforeInitialization(Object bean,String beanName)</code><ul>
<li><code>bean</code><ul>
<li>就是spring创建的要初始化的目标类对象</li>
</ul>
</li>
<li>返回值<ol>
<li>可以是spring创建的目标对象</li>
<li>也可以是目标对象的代理对象</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>在初始化方法后<ul>
<li>执行<code>postProcessAfterInitialization(Object bean,String beanName)</code> <ul>
<li>返回值<ol>
<li>spring创建的目标对象</li>
<li>目标对象的代理对象</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>写一个类实现BeanPostProcessor接口</li>
<li>配置<code>&lt;bean class=&quot;&quot;&gt;</code><ul>
<li>后处理bean会对所有目标类有效     </li>
<li>如何针对某一个目标类？<ul>
<li>利用实现类中<code>postProcessBeforeInitialization()</code>/<code>postProcessAfterInitialization()</code>方法的第二个参数beanName来进行判断</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="类A的创建→初始化→目标方法→销毁过程"><a href="#类A的创建→初始化→目标方法→销毁过程" class="headerlink" title="类A的创建→初始化→目标方法→销毁过程"></a>类A的创建→初始化→目标方法→销毁过程</h4><ol>
<li><p>一般过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a=new A()</span><br><span class="line">a.init()</span><br><span class="line">a.add()</span><br><span class="line">a.destroy()</span><br></pre></td></tr></table></figure>
</li>
<li><p>现有一类B实现了BeanPostProcessor接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A a=new A()</span><br><span class="line">a/aProxy=B.postProcessBeforeInitialization(a)</span><br><span class="line">a.init()</span><br><span class="line">a/aproxy=B.postProcessAfterInitialization(a)</span><br><span class="line">a.add()</span><br><span class="line">a.destroy()</span><br></pre></td></tr></table></figure>
<ul>
<li>如上在初始化方法前后都可以获取代理对象。代理对象又可以在目标方法前后做一些事，如事务…<ul>
<li>注意在初始化方法前获取代理对象，则初始化方法使用的就是代理对象。而可能指定的初始化方法只有实现类中有，接口中可能没有，</li>
</ul>
</li>
<li>对于jdk代理，使用的是接口。<ul>
<li>前获取代理对象<ul>
<li>指定的初始化方法接口中必须有。</li>
</ul>
</li>
<li>后获取代理对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><ul>
<li>手动装配<ul>
<li>通过<code>value/ref</code>注入的都是手动装配</li>
</ul>
</li>
<li>自动装配<ul>
<li><code>&lt;bean autowire=&quot;&quot;&gt;&lt;/bean&gt;</code><ul>
<li><code>byName</code><ul>
<li>按照属性名（setXxx）注入</li>
</ul>
</li>
<li><code>byType</code><ul>
<li>如果IOC中类型有多个匹配，则出错。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h1><h2 id="Bean实例化-1"><a href="#Bean实例化-1" class="headerlink" title="Bean实例化"></a>Bean实例化</h2><ul>
<li><code>@Component</code><ul>
<li>默认bean id为 类名首字母小写</li>
</ul>
</li>
<li><code>@Controller</code><ul>
<li>web层</li>
</ul>
</li>
<li><code>@Service</code><ul>
<li>service层</li>
</ul>
</li>
<li><code>@Repository</code><ul>
<li>dao层</li>
</ul>
</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li><code>@Scope</code><ul>
<li><code>@Scope(&quot;prototype&quot;)</code>多例</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li><code>@PostConstruct</code><ul>
<li>初始化</li>
</ul>
</li>
<li><code>@PreDestroy</code><ul>
<li>销毁</li>
</ul>
</li>
</ul>
<h2 id="依赖注入-1"><a href="#依赖注入-1" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="Value-value-”值-spEL”"><a href="#Value-value-”值-spEL”" class="headerlink" title="@Value(value=”值/spEL”)"></a>@Value(value=”值/spEL”)</h3><ul>
<li>注入基本数据类型和String</li>
<li>spEL在类文件中格式为<code>${}</code>，在xml中为<code>#{}</code></li>
</ul>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><ul>
<li>按照类型<code>byType</code>注入<ul>
<li>如果容器没有此类型匹配项<ul>
<li>注入失败</li>
</ul>
</li>
<li>如果容器有一个此类型匹配项<ul>
<li>注入成功</li>
</ul>
</li>
<li>如果容器有多个此类型匹配项<ul>
<li>按照<code>byName</code>注入，若有，成功。没有，失败。</li>
<li>即以要注入的对象变量名（即成员变量名）作为Bean的id去匹配所有匹配项，若有此id则注入成功，无此id则注入失败。</li>
</ul>
</li>
</ul>
</li>
<li><code>requied</code><ul>
<li>默认<code>true</code>，即只要加了<code>@Autowired</code>则必须注入成功。注入失败会报错</li>
</ul>
</li>
</ul>
<h3 id="Qualifier-value-”beanId”"><a href="#Qualifier-value-”beanId”" class="headerlink" title="@Qualifier(value=”beanId”)"></a>@Qualifier(value=”beanId”)</h3><ul>
<li>作用在字段上<ul>
<li>不能单独使用，配合<code>@Autowire</code></li>
<li>在按照类型注入的基础上指定bean的id</li>
</ul>
</li>
<li>作用在方法上<ul>
<li>可以单独使用</li>
</ul>
</li>
</ul>
<h3 id="Resource-name-”beanId”"><a href="#Resource-name-”beanId”" class="headerlink" title="@Resource(name=”beanId”)"></a>@Resource(name=”beanId”)</h3><ul>
<li>按照bean的id注入</li>
</ul>
<h2 id="新注解"><a href="#新注解" class="headerlink" title="新注解"></a>新注解</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>原有注解还是要配合xml一起使用，如扫描注解，配置不是我们编写的bean如数据源..</li>
</ul>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>配置在类上，指定当前类是一个spring配置类，创建容器时会从该类上加载注解。相当于<code>applicationContext.xml</code></li>
<li>创建容器要使用ApplicationContext的注解实现类AnnotationApplicationContext<ul>
<li><code>ApplicationContext ac = new AnnotationApplicationContext(有@Configuration 注解的类.class)</code></li>
</ul>
</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>value</code><ul>
<li>用于指定配置类的字节码</li>
</ul>
</li>
</ul>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul>
<li>用于指定 spring 在初始化容器时要扫描的包，即原来的扫描注解</li>
</ul>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>basePackages</code><ul>
<li>用于指定要扫描的包</li>
</ul>
</li>
<li><code>value</code><ul>
<li>和basePackages一样</li>
</ul>
</li>
</ul>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><ul>
<li>只能写在方法上，把当前方法的返回值作为bean对象存入spring的ioc容器中</li>
<li>如果方法有参数，spring会去容器中查找是否有参数对应的bean，查找方式与<code>@Autowire</code>一样，且也可以加<code>@Qualifier</code>注解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean(name=&quot;runner&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public QueryRunner createQueryRunner(@Qualifier(&quot;ds&quot;) DataSource dataSource)&#123;</span><br><span class="line">		return new QueryRunner(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>name</code><ul>
<li>给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）</li>
<li>默认为方法名。</li>
</ul>
</li>
</ul>
<h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><ul>
<li>用于加载<code>.properties</code> 文件</li>
</ul>
<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>value[]</code><ul>
<li>用于指定 properties 文件位置</li>
<li>类路径下要加上<code>classpath:</code></li>
</ul>
</li>
</ul>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h4><ul>
<li>用于导入其他配置类</li>
<li>当我们使用@Import的注解之后，有@Import注解的类就父配置类，而导入的都是子配置类</li>
</ul>
<h4 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h4><ul>
<li><code>value[]</code><ul>
<li>用于指定其他配置类的字节码</li>
</ul>
</li>
</ul>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><ul>
<li><code>Aspect Oriented Programming</code> </li>
<li>面向切面编程</li>
</ul>
<h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul>
<li>AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码<ul>
<li>经典应用：事务管理、权限校验、异常处理、性能监视、安全检查、缓存 、日志等</li>
</ul>
</li>
<li>将核心业务代码与外围业务（日志记录、权限校验、异常处理、事务控制）代码分离出来，提高模块化，降低代码耦合度，使职责更单一</li>
<li>AOP编程操作的主要对象是切面（aspect），切面模块化横切关注点</li>
<li>AOP编程时，仍需定义公共功能，但可以明确的定义这个功能应用在哪里，以什么方式应用，且不必修改受影响的类。这样一来横切关注点就被模块化到特殊的类里-这样的类称为切面</li>
</ul>
<h2 id="AOP的实现框架"><a href="#AOP的实现框架" class="headerlink" title="AOP的实现框架"></a>AOP的实现框架</h2><h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><ul>
<li>java社区最完整最流行的AOP框架</li>
<li>AspectJ是一个比较牛逼的AOP框架，他可以对类的成员变量，方法进行拦截。由于 AspectJ 是 Java 语言语法和语义的扩展，所以它提供了自己的一套处理方面的关键字。除了包含字段和方法之外，AspectJ 的方面声明还包含切入点和通知成员。</li>
<li>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）</li>
<li>静态织入<ul>
<li>在编译期使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入</li>
<li>即先编译aspect类再编译目标类</li>
</ul>
</li>
</ul>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring-AOP"></a>Spring-AOP</h3><ul>
<li>Spring AOP依赖的是 Spring 框架方便的、最小化的运行时配置，所以不需要独立的启动器。但是，使用这个技术，只能通知从 Spring 框架检索出的对象。Spring的AOP技术只能是对方法进行拦截</li>
<li>Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码</li>
<li>动态织入<ul>
<li>在运行时动态将要增强的代码织入到目标类中</li>
<li>通过动态代理技术完成<ul>
<li><strong>JDK动态代理</strong><ul>
<li>基于反射技术的实现</li>
<li><code>接口+实现类</code></li>
<li>代理对象格式<code>$Proxy</code></li>
<li><code>Proxy.newProxyInstance()</code></li>
</ul>
</li>
<li><strong>CGLIB动态代理</strong><ul>
<li>基于继承的机制实现</li>
<li><code>实现类</code></li>
<li>代理对象格式<code>xxxx$$EnhancerByCGLIB$$xxxxxx</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">// 确定父类</span><br><span class="line">enhancer.setSuperclass(testService.getClass());</span><br><span class="line">// 设置回调函数</span><br><span class="line">enhancer.setCallback() </span><br><span class="line">// 创建代理</span><br><span class="line">Object proxy =  enhancer.create();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="AspectJ-amp-Spring-AOP"><a href="#AspectJ-amp-Spring-AOP" class="headerlink" title="AspectJ &amp; Spring-AOP"></a>AspectJ &amp; Spring-AOP</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li>Spring AOP 与ApectJ 的目的一致，都是为了统一处理横切业务</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>Spring AOP 并不尝试提供完整的AOP功能(即使它完全可以实现)Spring AOP 更注重的是与Spring IOC容器的结合，并结合该优势来解决横切业务的问题</li>
<li>AOP的功能完善方面AspectJ具有更大的优势</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>AspectJ 1.5后，引入<code>@Aspect</code>形式的注解</li>
<li>Spring 2.0后便使用了与AspectJ一样的注解，并使用Aspectj来做切入点解析和匹配(AspectJ 5让第三方使用AspectJ的切入点解析和匹配引擎的工具API)。但是spring AOP底层依然是动态代理技术的实现，运行时仍旧是纯的spring AOP,并不依赖于Aspectj的编译器或者织入器</li>
</ul>
<h2 id="AOP使用"><a href="#AOP使用" class="headerlink" title="AOP使用"></a>AOP使用</h2><h3 id="开发阶段（程序员）"><a href="#开发阶段（程序员）" class="headerlink" title="开发阶段（程序员）"></a>开发阶段（程序员）</h3><ul>
<li>编写核心业务代码</li>
<li>公共代码抽取为通知</li>
<li>配置中声明切入点和通知的关系，即切面</li>
</ul>
<h3 id="运行阶段（Spring）"><a href="#运行阶段（Spring）" class="headerlink" title="运行阶段（Spring）"></a>运行阶段（Spring）</h3><ul>
<li>spring监控切入点方法的执行，一旦切入点方法运行，使用代理机制，动态创建目标对象的代理对象，根据通知类型，在代理对象的相应位置，将通知织入。</li>
</ul>
<h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><h3 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h3><ul>
<li>从每个方法中抽取出来的同一类非核心业务。</li>
</ul>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><ul>
<li>目标类</li>
<li>需要被代理的类。</li>
</ul>
<h3 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h3><ul>
<li>连接点</li>
<li>指目标类中那些可能被拦截到的方法</li>
</ul>
<h3 id="PointCut"><a href="#PointCut" class="headerlink" title="PointCut"></a>PointCut</h3><ul>
<li>切入点</li>
<li>已经被增强的连接点。即目标类中被拦截了的方法。</li>
</ul>
<h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><ul>
<li>通知/增强</li>
<li>切面要完成的各个具体功能</li>
<li>如日志，权限验证。。。</li>
</ul>
<h3 id="Weaving"><a href="#Weaving" class="headerlink" title="Weaving"></a>Weaving</h3><ul>
<li>织入</li>
<li>是指把切面的代码应用到目标对象target的目标函数的过程</li>
<li>spring采用动态代理织入</li>
<li>Aspectj采用编译期织入和类装载期织入</li>
</ul>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><ul>
<li>织入后创建的目标对象的代理对象</li>
</ul>
<h3 id="Aspect-advisor"><a href="#Aspect-advisor" class="headerlink" title="Aspect/advisor"></a>Aspect/advisor</h3><ul>
<li>切面</li>
<li>是切入点pointcut和通知advice的结合,定义通知应用到哪些切入点上<ul>
<li>一个切入点和一个通知组成一条线</li>
<li>一个线是一个特殊的面。</li>
</ul>
</li>
</ul>
<h2 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h2><ul>
<li><code>org.aopalliance.aop.Advice</code></li>
<li>AOP联盟定义的通知</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h4><ul>
<li><code>org.springframework.aop.MethodBeforeAdvice</code></li>
<li>在目标方法执行前实施增强</li>
</ul>
<h4 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h4><ul>
<li><code>org.springframework.aop.AfterReturningAdvice</code></li>
<li>在目标方法执行后实施增强</li>
</ul>
<h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><ul>
<li><code>org.aopalliance.intercept.MethodInterceptor</code></li>
<li>在目标方法执行前后实施增强</li>
<li>必须手动执行目标方法</li>
</ul>
<h4 id="异常抛出通知"><a href="#异常抛出通知" class="headerlink" title="异常抛出通知"></a>异常抛出通知</h4><ul>
<li><code>org.springframework.aop.ThrowsAdvice</code></li>
<li>在方法抛出异常后实施增强</li>
</ul>
<h4 id="引介通知"><a href="#引介通知" class="headerlink" title="引介通知"></a>引介通知</h4><ul>
<li><code>org.springframework.aop.IntroductionInterceptor</code></li>
<li>在目标类中添加一些新的方法和属性</li>
</ul>
<h2 id="AspectJ-1"><a href="#AspectJ-1" class="headerlink" title="AspectJ"></a>AspectJ</h2><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><h4 id="execution"><a href="#execution" class="headerlink" title="execution()"></a><code>execution()</code></h4><ul>
<li>用于描述方法。</li>
</ul>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li><code>execution(修饰符 返回值 包.类.方法(参数)throws 异常)</code></li>
</ul>
<h6 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h6><ul>
<li>一般省略</li>
<li><code>*</code> <ul>
<li>通配符，任意</li>
</ul>
</li>
<li><code>public</code><ul>
<li>公共</li>
</ul>
</li>
</ul>
<h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><ul>
<li>不可省略</li>
<li><code>void</code> <ul>
<li>无返回值</li>
</ul>
</li>
<li><code>String</code> <ul>
<li>返回字符串</li>
</ul>
</li>
<li><code>*</code> <ul>
<li>任意</li>
</ul>
</li>
</ul>
<h6 id="包"><a href="#包" class="headerlink" title="包"></a>包</h6><ul>
<li><code>..</code> 当前包及其子包</li>
<li><code>*</code> 任意</li>
</ul>
<h6 id="类"><a href="#类" class="headerlink" title="类"></a>类</h6><ul>
<li>不可省略</li>
<li><code>C</code> <ul>
<li>指定类</li>
</ul>
</li>
<li><code>*x</code> <ul>
<li>以x结尾的类</li>
</ul>
</li>
<li><code>x*</code> <ul>
<li>以x开头的类</li>
</ul>
</li>
<li><code>*</code> <ul>
<li>任意</li>
</ul>
</li>
</ul>
<h6 id="方法-1"><a href="#方法-1" class="headerlink" title="方法()"></a>方法()</h6><ul>
<li>不可省略</li>
<li><code>M</code> <ul>
<li>指定方法</li>
</ul>
</li>
<li><code>*x</code> <ul>
<li>以x结尾的方法</li>
</ul>
</li>
<li><code>x*</code> <ul>
<li>以x开头的方法</li>
</ul>
</li>
<li><code>*</code> <ul>
<li>任意</li>
</ul>
</li>
</ul>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul>
<li>可以直接写数据类型<ul>
<li>基本类型直接写名称，如<code>int</code></li>
<li>引用类型写<code>包名.类名</code>，如<code>java.lang.String</code></li>
</ul>
</li>
<li><code>..</code><ul>
<li>任意类型，且有无参数皆可</li>
</ul>
</li>
<li><code>*</code><ul>
<li>任意类型，必须有参数</li>
</ul>
</li>
<li><code>()</code> 无参</li>
<li><code>(int)</code> 一个整数</li>
<li><code>(int,int)</code> 两个整数</li>
<li><code>(..)</code> 任意参数</li>
</ul>
<h6 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h6><ul>
<li>一般不写。</li>
</ul>
<h4 id="within-了解"><a href="#within-了解" class="headerlink" title="within(了解)"></a><code>within</code>(了解)</h4><ul>
<li>匹配包或子包中的方法</li>
<li><code>within(包目录)</code><ul>
<li><code>within(cn.an...*)</code></li>
</ul>
</li>
</ul>
<h4 id="this-了解"><a href="#this-了解" class="headerlink" title="this(了解)"></a><code>this</code>(了解)</h4><ul>
<li>匹配实现接口的代理对象中的方法</li>
<li><code>this(接口全限定名)</code><ul>
<li><code>this(cn.an.UserDao)</code></li>
</ul>
</li>
</ul>
<h4 id="target-了解"><a href="#target-了解" class="headerlink" title="target(了解)"></a><code>target</code>(了解)</h4><ul>
<li>匹配实现接口的目标对象中的方法</li>
<li><code>target(接口全限定名)</code><ul>
<li><code>target(cn.an.UserDao)</code></li>
</ul>
</li>
</ul>
<h4 id="args-了解"><a href="#args-了解" class="headerlink" title="args(了解)"></a><code>args</code>(了解)</h4><ul>
<li>匹配参数格式符合标准的方法</li>
<li><code>args(int,int)</code></li>
</ul>
<h4 id="bean-了解"><a href="#bean-了解" class="headerlink" title="bean(了解)"></a><code>bean</code>(了解)</h4><ul>
<li>匹配指定的bean所有的方法</li>
<li><code>bean(&quot;beanId&quot;)</code></li>
</ul>
<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul>
<li>aop联盟通知类型<ul>
<li>具有特性接口，必须实现，从而确定方法名称。</li>
</ul>
</li>
<li>aspectj通知类型<ul>
<li>只定义类型名称以及方法格式    </li>
</ul>
</li>
</ul>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><h5 id="前置通知-1"><a href="#前置通知-1" class="headerlink" title="前置通知"></a>前置通知</h5><ul>
<li><code>before</code><ul>
<li>应用：各种校验</li>
<li>在方法执行前执行，如果通知抛出异常，阻止方法运行</li>
</ul>
</li>
<li><p>前置通知方法定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义方法名([JoinPoint jp])&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>jp</code><ul>
<li>用于描述连接点(目标方法)</li>
<li>可以获取目标方法方法名等。。。。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="后置通知-1"><a href="#后置通知-1" class="headerlink" title="后置通知"></a>后置通知</h5><ul>
<li><code>afterReturning</code><ul>
<li>应用：常规数据处理</li>
<li>方法正常返回后执行，如果方法中抛出异常，通知无法执行</li>
<li>必须在方法执行后才执行，所以可以获得方法的返回值。</li>
</ul>
</li>
<li><p>后置通知方法定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义方法名([JoinPoint jp],[Object obj])&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>obj</code><ul>
<li>目标方法返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="环绕通知-1"><a href="#环绕通知-1" class="headerlink" title="环绕通知"></a>环绕通知</h5><ul>
<li><code>around</code><ul>
<li>应用：十分强大，可以做任何事情</li>
<li>方法执行前后分别执行，可以阻止方法的执行</li>
</ul>
</li>
<li>必须手动执行目标方法<ul>
<li>spring为我们提供了一个接口<code>ProceedingJoinPoint</code>，该接口有一个方法<code>proceed()</code>，相当于调用目标方法，该接口作为环绕通知的方法参数，程序执行时，spring会自动提供实现类。</li>
</ul>
</li>
<li>环绕通知方法定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object 自定义方法名(ProceedingJoinPoint pjp) &#123;</span><br><span class="line">	Object obj = null;</span><br><span class="line">	try&#123;</span><br><span class="line">		// 获取方法执行所需参数</span><br><span class="line">		Object[] args = pjp.getArges();</span><br><span class="line">		// 目标方法前 前置通知</span><br><span class="line">		// 执行目标方法 </span><br><span class="line">		obj = pjp.proceed();</span><br><span class="line">		// 目标方法后 前置通知</span><br><span class="line">		return obj;</span><br><span class="line">	&#125;catch()&#123;</span><br><span class="line">		// 异常通知</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">		// 最终通知</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="抛出异常通知"><a href="#抛出异常通知" class="headerlink" title="抛出异常通知"></a>抛出异常通知</h5><ul>
<li><code>afterThrowing</code><ul>
<li>应用：包装异常信息</li>
</ul>
</li>
<li>方法抛出异常后执行，如果方法没有抛出异常，无法执行</li>
<li>异常通知方法定义<ul>
<li><code>自定义方法名([JoinPoint jp],[Throwable e])</code></li>
</ul>
</li>
</ul>
<h5 id="最终通知"><a href="#最终通知" class="headerlink" title="最终通知"></a>最终通知</h5><ul>
<li><code>after</code><ul>
<li>应用：清理现场</li>
</ul>
</li>
<li>方法执行完毕后执行，无论方法中是否出现异常</li>
<li>最终通知方法定义<ul>
<li><code>自定义方法名([JoinPoint jp])</code></li>
</ul>
</li>
</ul>
<h1 id="Spring-AOP编程"><a href="#Spring-AOP编程" class="headerlink" title="Spring AOP编程"></a>Spring AOP编程</h1><h2 id="基于经典的SpringAOP"><a href="#基于经典的SpringAOP" class="headerlink" title="基于经典的SpringAOP"></a>基于经典的SpringAOP</h2><ul>
<li>使用aop联盟的通知类型</li>
<li>通知需要实现指定的接口</li>
</ul>
<h2 id="Spring-AspectJ"><a href="#Spring-AspectJ" class="headerlink" title="Spring+AspectJ"></a>Spring+AspectJ</h2><ul>
<li>使用AspectJ的通知类型</li>
</ul>
<h3 id="AspectJ基于xml的AOP编程"><a href="#AspectJ基于xml的AOP编程" class="headerlink" title="AspectJ基于xml的AOP编程"></a>AspectJ基于xml的AOP编程</h3><ol>
<li>编写目标类</li>
<li><p>编写通知类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdvice &#123;</span><br><span class="line">		public void myBefore(JoinPoint jp) &#123;</span><br><span class="line">		    System.out.println(&quot;前置通知 :name=&quot;+jp.getSignature().getName());</span><br><span class="line">		&#125;</span><br><span class="line">		public void myAfterReturning(JoinPoint jp,Object obj) &#123;</span><br><span class="line">		    System.out.println(&quot;后置通知 :return=&quot;+obj);</span><br><span class="line">		&#125;</span><br><span class="line">		public Object myAround(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">		    System.out.println(&quot;环绕通知...前&quot;);</span><br><span class="line">		    Object proceed = pjp.proceed();</span><br><span class="line">		    System.out.println(&quot;环绕通知...后&quot;);</span><br><span class="line">		    return proceed;</span><br><span class="line">		&#125;</span><br><span class="line">		public void myAfterThrowning() &#123;</span><br><span class="line">		    System.out.println(&quot;异常通知&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		public void myAfter() &#123;</span><br><span class="line">		    System.out.println(&quot;最终通知&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置aop织入通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置目标类--&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;an.s6.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--配置通知类--&gt;</span><br><span class="line">&lt;bean id=&quot;myAdvice&quot; class=&quot;an.s6.advice.MyAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--aop配置--&gt;</span><br><span class="line">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">    &lt;aop:aspect id=&quot;aspectID&quot; ref=&quot;myAdvice&quot;&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pontcutID&quot; expression=&quot;execution(* an.s6.service.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;</span><br><span class="line">        &lt;aop:before method=&quot;myBefore&quot; pointcut-ref=&quot;pontcutID&quot;/&gt;</span><br><span class="line">        &lt;aop:after-returning method=&quot;myAfterReturning&quot; pointcut-ref=&quot;pontcutID&quot; returning=&quot;obj&quot;/&gt;</span><br><span class="line">        &lt;aop:around method=&quot;myAround&quot; pointcut-ref=&quot;pontcutID&quot;/&gt;</span><br><span class="line">        &lt;aop:after-throwing method=&quot;myAfterThrowning&quot; pointcut-ref=&quot;pontcutID&quot;/&gt;</span><br><span class="line">        &lt;aop:after method=&quot;myAfter&quot; pointcut-ref=&quot;pontcutID&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">	&lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>proxy-target-class</code><ul>
<li>默认false</li>
<li>true<ul>
<li>使用cglib代理</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;aop:aspect&gt;</code><ul>
<li>用于配置切面</li>
</ul>
</li>
<li><code>&lt;aop:advisor&gt;</code><ul>
<li>特殊的切面，只有一个通知 和 一个切入点</li>
</ul>
</li>
<li><code>&lt;aop:pointcut&gt;</code><ul>
<li>配置切入点</li>
<li>如果此标签在<code>&lt;/aop:config&gt;</code>下与<code>&lt;aop:aspect&gt;</code>平级<ul>
<li>则必须写在<code>&lt;aop:aspect&gt;</code>之前，且多个<code>&lt;aop:aspect&gt;</code>中都可以使用</li>
</ul>
</li>
<li>如果在<code>&lt;aop:aspect&gt;</code>下<ul>
<li>则只能当前<code>&lt;aop:aspect&gt;</code>使用</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;aop:after-returning&gt;</code><ul>
<li>如果定义的后置通知方法有第二个参数<code>Object xxx</code>,则需配置<code>returning=&quot;xxx&quot;</code></li>
</ul>
</li>
<li><code>&lt;aop:after-throwing&gt;</code><ul>
<li>如果定义的异常通知方法有第二个参数<code>Throwable xxx</code>,则需配置<code>throw=&quot;xxx&quot;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="AspectJ基于注解的AOP编程"><a href="#AspectJ基于注解的AOP编程" class="headerlink" title="AspectJ基于注解的AOP编程"></a>AspectJ基于注解的AOP编程</h3><ol>
<li>编写目标类</li>
<li>使用注解编写通知类，并织入<ul>
<li>类<ul>
<li><code>@Aspect</code><ul>
<li>声明切面</li>
</ul>
</li>
<li><code>@Order()</code><ul>
<li>值为int数，用来表示切面的优先级</li>
</ul>
</li>
</ul>
</li>
<li>方法<ul>
<li><code>@PointCut</code><ul>
<li>相当于声明了一个切入点，id是方法名</li>
<li>在其它通知方法上<ul>
<li><code>@Xxx(value=&quot;execution(表达式)&quot;)</code><ul>
<li>相当于定义切入点表达式</li>
</ul>
</li>
<li><code>@Xxx(value=&quot;声明切入点的方法名（方法带括号）&quot;)</code><ul>
<li>相当于引入一个切入点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>@Before</code></li>
<li><code>@AfterReturning</code><ul>
<li><code>returning=&quot;第二个参数Object xxx&quot;</code></li>
</ul>
</li>
<li><code>@Around</code></li>
<li><code>@AfterThrowing</code><ul>
<li><code>throwing=&quot;第二个参数Throwable xxx&quot;</code></li>
</ul>
</li>
<li><code>@After</code></li>
</ul>
</li>
</ul>
</li>
<li>开启aop注解<ol>
<li><code>&lt;aop:aspectj-autoproxy/&gt;</code><ul>
<li>主要作用是为切面中通知能作用到的目标类生成代理。</li>
</ul>
</li>
<li><code>@EnableAspectJAutoProxy</code><ul>
<li>配置在注解配置类上（带<code>@Configuraction</code>的）</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="JDBC-Template"><a href="#JDBC-Template" class="headerlink" title="JDBC Template"></a>JDBC Template</h1><ul>
<li>spring 提供用于操作JDBC工具类，类似：DBUtils。</li>
<li>依赖<ul>
<li>DataSource （数据源）</li>
</ul>
</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="手动创建方式-了解"><a href="#手动创建方式-了解" class="headerlink" title="手动创建方式 (了解)"></a>手动创建方式 (了解)</h3><ol>
<li>创建数据源<ul>
<li><code>DriverManagerDataSource</code><ul>
<li>spring内置数据源</li>
</ul>
</li>
<li><code>ComboPooledDataSource</code><ul>
<li>c3p0数据源</li>
</ul>
</li>
<li><code>BasicDataSource</code><ul>
<li>dbcp数据源</li>
</ul>
</li>
</ul>
</li>
<li>创建JdbcTemplate，并设置数据源（构造/set方法）<ul>
<li><code>JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);</code></li>
</ul>
</li>
<li>使用jdbcTemplate操作 </li>
</ol>
<h3 id="spring-ioc之JdbcTemplate"><a href="#spring-ioc之JdbcTemplate" class="headerlink" title="spring ioc之JdbcTemplate"></a>spring ioc之JdbcTemplate</h3><ul>
<li>xml或注解配置使用</li>
</ul>
<ol>
<li>创建dao 并持有JdbcTemplate</li>
<li>spring配置 <ol>
<li>配置数据源bean</li>
<li>配置JdbcTemplate bean，并注入数据源</li>
<li>配置dao bean，并注入JdbcTemplate bean</li>
</ol>
</li>
<li>dao中直接使用JdbcTemplate操作</li>
</ol>
<h3 id="spring-ioc之-JdbcDaoSupport"><a href="#spring-ioc之-JdbcDaoSupport" class="headerlink" title="spring ioc之 JdbcDaoSupport"></a>spring ioc之 JdbcDaoSupport</h3><ul>
<li>xml配置使用</li>
</ul>
<ol>
<li><p>创建dao 继承<code>JdbcDaoSupport</code></p>
<ul>
<li><p>JdbcDaoSupport</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate getJdbcTemplate()&#123;&#125;</span><br><span class="line">void setDataSource(DataSource dataSource)&#123;</span><br><span class="line">	if (jdbcTemplate == null) &#123;</span><br><span class="line">		jdbcTemplate = createJdbcTemplate(DataSource dataSource);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">JdbcTemplate createJdbcTemplate(DataSource dataSource)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只要给dao注入了数据源，就可以创建JdbcTemplate</p>
</li>
</ul>
</li>
<li>spring配置<ol>
<li>配置数据源bean</li>
<li>配置dao bean，并注入数据源</li>
</ol>
</li>
<li>dao中直接使用<code>getJdbcTemplate()</code>获取JdbcTemplate进行操作</li>
</ol>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><ul>
<li><code>int update(String sql, Object... obj)</code></li>
</ul>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li><code>List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, Object... obj)</code><ul>
<li>查询结果封装为javabean对象，然后封装到list集合</li>
<li>查询所有</li>
<li>查询一个，集合中只有一个获取即可。</li>
</ul>
</li>
<li><code>T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... obj)</code><ul>
<li>查询单值，返回单个值。</li>
</ul>
</li>
<li><code>T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... obj )</code><ul>
<li>查询单行数据，返回一个对象</li>
</ul>
</li>
<li><code>Map&lt;String, Object&gt; queryForMap(String sql, Object... obj)</code><ul>
<li>查询的结果集封装为map集合</li>
<li>此方法查询结果集长度只能是1<ul>
<li>列名为key，列值为value</li>
</ul>
</li>
</ul>
</li>
<li><code>List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... obj)</code><ul>
<li>将每一条记录封装为map集合，然后将map集合封装到list集合中</li>
</ul>
</li>
</ul>
<h4 id="RowMapper"><a href="#RowMapper" class="headerlink" title="RowMapper"></a>RowMapper</h4><ul>
<li>类似于DBUtils的ResultSetHandler</li>
<li>可以自己实现，也可使用spring提供的</li>
</ul>
<h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><ul>
<li><code>T mapRow(ResultSet rs, int rowNum)</code></li>
</ul>
<h5 id="Spring提供的RowMapper实现"><a href="#Spring提供的RowMapper实现" class="headerlink" title="Spring提供的RowMapper实现"></a>Spring提供的RowMapper实现</h5><h6 id="BeanPropertyRowMapper"><a href="#BeanPropertyRowMapper" class="headerlink" title="BeanPropertyRowMapper"></a>BeanPropertyRowMapper</h6><ul>
<li>将结果集封装为对象</li>
</ul>
<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><h2 id="三个顶级接口"><a href="#三个顶级接口" class="headerlink" title="三个顶级接口"></a>三个顶级接口</h2><h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ul>
<li>平台事务管理器 <code>spring-tx.jar</code>中</li>
<li>因为不同平台，操作事务的代码各不相同，spring提供了此接口</li>
<li>spring要管理事务，必须使用事务管理器</li>
</ul>
<h4 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h4><ul>
<li><code>TransactionStatus getTransaction(TransactionDefinition definition)</code><ul>
<li>事务管理器 通过“事务详情”，获得“事务状态”，从而管理事务。</li>
</ul>
</li>
<li><code>void commit(TransactionStatus status)</code><ul>
<li>根据状态提交</li>
</ul>
</li>
<li><code>void rollback(TransactionStatus status)</code><ul>
<li>根据状态回滚</li>
</ul>
</li>
</ul>
<h4 id="事务管理器（实现）"><a href="#事务管理器（实现）" class="headerlink" title="事务管理器（实现）"></a>事务管理器（实现）</h4><h5 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h5><ul>
<li>jdbc开发时事务管理器，采用JdbcTemplate</li>
<li>在<code>spring-jdbc.jar</code>中</li>
</ul>
<h5 id="HibernateTransactionManager"><a href="#HibernateTransactionManager" class="headerlink" title="HibernateTransactionManager"></a>HibernateTransactionManager</h5><ul>
<li>hibernate开发时事务管理器，整合hibernate时用</li>
<li>在<code>spring-orm.jar</code>中</li>
</ul>
<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><ul>
<li>事务详情（事务定义、事务属性）</li>
<li>spring用于确定事务具体详情<ul>
<li>例如：隔离级别、是否只读、超时时间 等</li>
</ul>
</li>
<li>进行事务配置时，必须配置详情。spring将配置项封装到该对象实例</li>
</ul>
<h4 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h4><ul>
<li><code>getPropagationBehavior()</code><ul>
<li>获取传播行为</li>
<li>传播行为：在两个业务之间如何共享事务。</li>
</ul>
</li>
<li><code>getName()</code><ul>
<li>配置事务详情名称</li>
</ul>
</li>
<li><code>isReadOnly()</code><ul>
<li>是否只读(增删改：读写，查：只读)</li>
<li>默认非只读</li>
</ul>
</li>
<li><code>getTimeout()</code><ul>
<li>获取超时时间。</li>
</ul>
</li>
<li><code>getIsolationlevel()</code><ul>
<li>获取隔离级别</li>
<li>隔离级别<ul>
<li>0 1 2 4 8</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><h5 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h5><ul>
<li>如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为</li>
</ul>
<h5 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h5><ul>
<li><strong>PROPAGATION_REQUIRED</strong> (required 必须)(默认值)<ul>
<li>支持当前事务<ul>
<li>如果A（调用者）有事务，B（被调用者）将使用该事务。</li>
<li>如果A没有事务，B将创建一个新的事务。</li>
</ul>
</li>
</ul>
</li>
<li>PROPAGATION_SUPPORTS (supports 支持)<ul>
<li>支持当前事务<ul>
<li>如果A有事务，B将使用该事务。</li>
<li>如果A没有事务，B将以非事务执行。</li>
</ul>
</li>
</ul>
</li>
<li>PROPAGATION_MANDATORY (mandatory 强制)<ul>
<li>支持当前事务<ul>
<li>如果A有事务，B将使用该事务。</li>
<li>如果A没有事务，B将抛异常</li>
</ul>
</li>
</ul>
</li>
<li><strong>PROPAGATION_REQUIRES_NEW</strong> (requires_new 必须新的)<ul>
<li>如果A有事务，将A的事务挂起，B创建一个新的事务</li>
<li>如果A没有事务，B创建一个新的事务</li>
</ul>
</li>
<li>PROPAGATION_NOT_SUPPORTED (not_supported 不支持)<ul>
<li>如果A有事务，将A的事务挂起，B将以非事务执行</li>
<li>如果A没有事务，B将以非事务执行</li>
</ul>
</li>
<li>PROPAGATION_NEVER (never 从不)<ul>
<li>如果A有事务，B将抛异常</li>
<li>如果A没有事务，B将以非事务执行</li>
</ul>
</li>
<li><strong>PROPAGATION_NESTED</strong> (nested 嵌套)<ul>
<li>A和B底层采用保存点机制，形成嵌套事务。</li>
</ul>
</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul>
<li><code>ISOLATION_DEFAULT</code><ul>
<li>默认</li>
<li>表示底层使用数据库的默认隔离级别</li>
</ul>
</li>
<li><code>ISOLATION_READ_UNCOMMITTED</code></li>
<li><code>ISOLATION_READ_COMMITTED</code></li>
<li><code>ISOLATION_REPEATABLE_READ</code></li>
<li><code>ISOLATION_SERIALIZABLE</code></li>
</ul>
<h4 id="是否回滚"><a href="#是否回滚" class="headerlink" title="是否回滚"></a>是否回滚</h4><ul>
<li>spring默认会对所有运行时异常回滚</li>
<li><code>rollbackFor</code></li>
<li><code>rollbackForClassName</code></li>
<li><code>noRollbackFor</code></li>
<li><code>noRollbackForClassName</code></li>
</ul>
<h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><ul>
<li>事务状态，spring用于记录当前事务运行状态。<ul>
<li>例如：是否有保存点，事务是否完成。</li>
</ul>
</li>
<li>spring底层根据状态进行相应操作。</li>
</ul>
<h4 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h4><ul>
<li><code>isNewtransaction()</code><ul>
<li>是否是新的事务</li>
</ul>
</li>
<li><code>hasSavepoint()</code></li>
<li><code>setRollbackOnly()</code></li>
<li><code>isRollbackOnly()</code></li>
<li><code>flush()</code></li>
<li><code>isCompleted()</code></li>
</ul>
<h2 id="事务管理详解"><a href="#事务管理详解" class="headerlink" title="事务管理详解"></a>事务管理详解</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><ul>
<li>spirng底层使用TransactionTemplate模板管理事务。<ul>
<li>模板需要注入事务管理器</li>
<li>事务管理器需要事务</li>
<li>事务从Connection获得</li>
<li>Connection不管直接创建还是从连接池中获得都需要数据源</li>
<li>所以事务管理器需要注入数据源DataSource</li>
</ul>
</li>
</ul>
<h3 id="手动管理事务-了解"><a href="#手动管理事务-了解" class="headerlink" title="手动管理事务(了解)"></a>手动管理事务(了解)</h3><ol>
<li>配置TransactionTemplate，并注入Service中</li>
<li>配置事务管理器，并注入到TransactionTemplate中</li>
<li>Service中业务方法中使用事务模板操作<ul>
<li><code>transactionTemplate.execute();</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) &#123;</span><br><span class="line">        accountDao.raise(to, money);</span><br><span class="line">        int i = 1/0;</span><br><span class="line">        accountDao.reduce(from, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="半自动管理事务"><a href="#半自动管理事务" class="headerlink" title="半自动管理事务"></a>半自动管理事务</h3><ol>
<li>使用工厂bean生成代理</li>
<li>为代理对象注入事务管理器及事务详情</li>
<li>使用代理对象执行业务方法</li>
</ol>
<h4 id="TransactionProxyFactoryBean"><a href="#TransactionProxyFactoryBean" class="headerlink" title="TransactionProxyFactoryBean"></a>TransactionProxyFactoryBean</h4><ul>
<li>spring提供 管理事务的代理工厂bean<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 4 service 代理对象 </span><br><span class="line">	4.1 proxyInterfaces 接口 </span><br><span class="line">	4.2 target 目标类</span><br><span class="line">	4.3 transactionManager 事务管理器</span><br><span class="line">	4.4 transactionAttributes 事务属性（事务详情）</span><br><span class="line">		prop.key ：确定哪些方法使用当前事务配置</span><br><span class="line">		prop.text:用于配置事务详情</span><br><span class="line">			格式：PROPAGATION,ISOLATION,readOnly,-Exception,+Exception</span><br><span class="line">				传播行为		隔离级别	是否只读		异常回滚		异常提交</span><br><span class="line">			例如：</span><br><span class="line">				&lt;prop key=&quot;save&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;/prop&gt; 默认传播行为，和隔离级别</span><br><span class="line">				&lt;prop key=&quot;add&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly&lt;/prop&gt; 只读</span><br><span class="line">				&lt;prop key=&quot;add&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT,+java.lang.ArithmeticException&lt;/prop&gt;  有异常扔提交</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;proxyAccountService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.itheima.service.AccountService&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;target&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;transactionAttributes&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;方法名&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自动管理事务"><a href="#自动管理事务" class="headerlink" title="自动管理事务"></a>自动管理事务</h3><ol>
<li>spring配置aop自动生成代理，进行事务管理</li>
<li>Aop从连接点中选出切入点</li>
<li>TxAdvice从切入点中再次筛选，确定哪些方法需要什么样的事务</li>
</ol>
<h4 id="Aop配置事务基于xml"><a href="#Aop配置事务基于xml" class="headerlink" title="Aop配置事务基于xml"></a>Aop配置事务基于xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--事务管理器--&gt;</span><br><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--事务详情--&gt;&lt;!--对什么方法使用什么样的事务 readOnly默认false--&gt;</span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; readOnly=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line">&lt;!--aop配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;pointcutID&quot; expression=&quot;execution(* an.s8.service.*.*(..))&quot;/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcutID&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Aop配置事务基于注解"><a href="#Aop配置事务基于注解" class="headerlink" title="Aop配置事务基于注解"></a>Aop配置事务基于注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 将事务管理器交予spring --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@Transactional</code><ul>
<li>事务详情的配置在注解的括号里</li>
<li>用在类上<ul>
<li>所有方法都开事务</li>
</ul>
</li>
<li>用在方法上<ul>
<li>此方法开事务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="spring整合junit"><a href="#spring整合junit" class="headerlink" title="spring整合junit"></a>spring整合junit</h1><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><ul>
<li><code>junti的jar包</code></li>
<li><code>spring核心4+1</code></li>
<li><code>spring-test.jar</code></li>
</ul>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><ul>
<li>与junit整合,不需要在spring配置中配置扫描</li>
</ul>
<h3 id="RunWith-SpringJunit4ClassRunner-class"><a href="#RunWith-SpringJunit4ClassRunner-class" class="headerlink" title="@RunWith(SpringJunit4ClassRunner.class)"></a>@RunWith(SpringJunit4ClassRunner.class)</h3><ul>
<li>在类上</li>
<li>替换原有运行器</li>
</ul>
<h3 id="ContextConfiguration"><a href="#ContextConfiguration" class="headerlink" title="@ContextConfiguration"></a>@ContextConfiguration</h3><ul>
<li><code>location</code><ul>
<li>指定spring配置文件的位置，类路径要加<code>classpath:</code></li>
</ul>
</li>
<li><code>classes</code><ul>
<li>用于指定注解的配置类。当不使用 xml 配置时，需要用此属性指定注解类的位置</li>
</ul>
</li>
</ul>
<h3 id="Autowired-1"><a href="#Autowired-1" class="headerlink" title="@Autowired"></a>@Autowired</h3><ul>
<li>注入数据</li>
</ul>
<h1 id="spring整合web"><a href="#spring整合web" class="headerlink" title="spring整合web"></a>spring整合web</h1><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><ul>
<li>普通java项目<ul>
<li>我们手动读取spring配置，创建spring容器。</li>
</ul>
</li>
<li>web项目<ul>
<li>服务器启动就创建spring容器。(安)</li>
</ul>
</li>
</ul>
<h2 id="web技术之服务器-tomcat-一启动就加载配置文件的方式"><a href="#web技术之服务器-tomcat-一启动就加载配置文件的方式" class="headerlink" title="web技术之服务器(tomcat)一启动就加载配置文件的方式"></a>web技术之服务器(tomcat)一启动就加载配置文件的方式</h2><ol>
<li>Servlet<ul>
<li><code>init(ServletConfig config)</code><ul>
<li><code>&lt;load-on-startup&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>Filter<ul>
<li><code>init(FilterConfig config)</code><ul>
<li><code>web.xml</code>注册过滤器自动调用初始化</li>
</ul>
</li>
</ul>
</li>
<li>Listener<ul>
<li><code>ServletContextListener</code><ul>
<li><code>web.xml</code>中配置监听器</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>spring使用的是<strong>Listener</strong><ul>
<li>spring提供了<code>ContextLoaderListener</code>监听器<ul>
<li><code>spring-web.jar</code>中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="spring监听器的配置"><a href="#spring监听器的配置" class="headerlink" title="spring监听器的配置"></a>spring监听器的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>此监听器默认加载的是<code>WEB-INF/applicationContext.xml</code></li>
<li>而我们的配置文件通常在src下即<code>WEB-INF/classes/applicationContext.cml</code></li>
<li>通过配置参数指定配置文件</li>
</ul>
<h2 id="手动获取spring容器"><a href="#手动获取spring容器" class="headerlink" title="手动获取spring容器"></a>手动获取spring容器</h2><ul>
<li>一般一个应用中只有一份spring容器放在ServletContext域中</li>
</ul>
<ol>
<li>从application域中根据key获取容器,spring把key封装成了一个常量<code>ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code><br> <code>this.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</code></li>
<li>通过工具类（WebApplicationContextUtils）获取，其实是封装了方法一<ul>
<li><code>WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());</code></li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-MyBatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-MyBatis/" itemprop="url">
                  xd-MyBatis
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:40:45" itemprop="dateCreated datePublished" datetime="2018-12-11T00:40:45+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:46:04" itemprop="dateModified" datetime="2019-03-08T14:46:04+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>mybatis就是一个封装来jdbc的持久层框架，它和hibernate都属于ORM框架</li>
<li>hibernate是一个完全的orm框架，而mybatis是一个不完全的orm框架</li>
<li>Mybatis让程序员只关注sql本身，而不需要去关注如连接的创建、statement的创建等操作</li>
<li>mybatis通过 xml 或注解的方式将要执行的各种statement配置起来，并通过java对象和statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并<br>返回</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="原生jdbc的问题"><a href="#原生jdbc的问题" class="headerlink" title="原生jdbc的问题"></a>原生jdbc的问题</h2><ul>
<li>在创建连接时，存在硬编码<ul>
<li>解决：配置文件（全局配置文件）</li>
</ul>
</li>
<li>在执行statement时存在硬编码<ul>
<li>解决：配置文件（映射文件）</li>
</ul>
</li>
<li>频繁的开启和关闭数据库连接，会造成数据库性能下降<ul>
<li>解决：数据库连接池（全局配置文件）</li>
</ul>
</li>
</ul>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><ul>
<li>MyBatis应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactory在根据配置，配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个SqlSession。SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的sql语句，完成对数据的增删改查和事务提交等，用完之后关闭SqlSession</li>
</ul>
<h1 id="maven加载映射文件"><a href="#maven加载映射文件" class="headerlink" title="maven加载映射文件"></a>maven加载映射文件</h1><ul>
<li>由于maven不会编译<code>src/main/java</code>下的<code>xml,properties...</code>等文件，所以加载不到</li>
</ul>
<ol>
<li><p>配置加载<code>src/main/java</code>下的资源文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">     &lt;resources&gt;</span><br><span class="line">         &lt;resource&gt;</span><br><span class="line">             &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">             &lt;includes&gt;</span><br><span class="line">                 &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">             &lt;/includes&gt;</span><br><span class="line">         &lt;/resource&gt;</span><br><span class="line">     &lt;/resources&gt;</span><br><span class="line"> &lt;/build&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源文件放到<code>src/main/resources</code>下，并建立与mapper接口相同的目录结构</p>
<ul>
<li>注<ul>
<li>由于在resources下不能建package，只能建directory，所以需要一级一级的建。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h1><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><ul>
<li>方法作用域（也就是局部方法变量）</li>
<li>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</li>
</ul>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><ul>
<li>应用作用域</li>
<li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</li>
</ul>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><ul>
<li>请求作用域</li>
<li>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</li>
<li>下面的示例就是一个确保 SqlSession 关闭的标准模式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">  	// do work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="映射器实例（Mapper-Instances）"><a href="#映射器实例（Mapper-Instances）" class="headerlink" title="映射器实例（Mapper Instances）"></a>映射器实例（Mapper Instances）</h2><ul>
<li>方法作用域</li>
<li>映射器是创建用来绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，映射器实例的最大作用域是和 SqlSession 相同的，因为它们都是从 SqlSession 里被请求的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求作用域（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域（method scope）内。下面的示例就展示了这个实践：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line"> 	 BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  	// do work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="加载核心配置并获取SqlSessionFactory"><a href="#加载核心配置并获取SqlSessionFactory" class="headerlink" title="加载核心配置并获取SqlSessionFactory"></a>加载核心配置并获取SqlSessionFactory</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = &quot;SqlMapConfig.xml的路径&quot;</span><br><span class="line">InputStream in = Resources.getResourceAsStream(resource)</span><br><span class="line">SqlSessionFactory sf = new SqlSessionFactoryBuilder().build(in)</span><br></pre></td></tr></table></figure>
<h2 id="获取SqlSession"><a href="#获取SqlSession" class="headerlink" title="获取SqlSession"></a>获取SqlSession</h2><ul>
<li><code>SqlSession sqlSession = sf.openSession();</code></li>
</ul>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><ul>
<li><code>insert(String insertId, Object o)</code><ul>
<li><code>xxxId</code>皆为<code>namespace.id</code>，其它方法同</li>
<li>o为参数</li>
</ul>
</li>
</ul>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><ul>
<li><code>delete(String deleteId, Object o)</code></li>
</ul>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><ul>
<li><code>update(String updateId, Object o)</code></li>
</ul>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><ul>
<li><code>selectOne(String selectID, Object o)</code></li>
<li><code>selectList(String selectID, Object o</code></li>
</ul>
<h2 id="获取Mapper"><a href="#获取Mapper" class="headerlink" title="获取Mapper"></a>获取Mapper</h2><ul>
<li><code>getMapper(Class clazz)</code></li>
</ul>
<h1 id="mybatis使用"><a href="#mybatis使用" class="headerlink" title="mybatis使用"></a>mybatis使用</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>直接使用SqlSession的增删改查API<ul>
<li>只需核心配置文件+映射配置文件</li>
<li>手动获取SqlSession使用API进行增删改查</li>
</ul>
</li>
<li>通过SqlSession获取Mapper接口的代理对象<ul>
<li>需要核心配置文件+映射配置文件</li>
<li>Mapper接口</li>
<li>获取Mapper代理对象，调用接口方法</li>
</ul>
</li>
</ol>
<h2 id="开发dao的方式"><a href="#开发dao的方式" class="headerlink" title="开发dao的方式"></a>开发dao的方式</h2><h3 id="原始dao-接口-实现类"><a href="#原始dao-接口-实现类" class="headerlink" title="原始dao(接口+实现类)"></a>原始dao(接口+实现类)</h3><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>有大量的重复的模板代码</li>
<li>存在硬编码</li>
</ul>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ul>
<li>我们使用实现类直接调用curd的方法</li>
<li><code>selectOne()/selectList() → ... → query()</code><ul>
<li>查询经过一系列过程，最后是jdbc</li>
<li>query()中<code>PreparedStatement.execute()</code></li>
</ul>
</li>
<li><code>insert()/delete()/update() → ... → update()</code><ul>
<li>增删改经过一系列过程，最后是jdbc</li>
<li>update()中<code>PreparedStatement.execute()</code></li>
</ul>
</li>
</ul>
<h3 id="Mapper代理"><a href="#Mapper代理" class="headerlink" title="Mapper代理"></a>Mapper代理</h3><ul>
<li>mapper接口（相当于dao接口）<ul>
<li>Mapper代理使用的是jdk的代理策略</li>
</ul>
</li>
</ul>
<h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><ul>
<li>我们调用<code>getMapper()</code>方法</li>
<li><code>getMapper()  → ... → selectOne()/selectList()/insert()/delete()/update()  → ... → ...</code><ul>
<li>经过一系列过程，mybatis判断后调用curd对应的方法，后边过程就和直接使用实现类一致。</li>
</ul>
</li>
</ul>
<h4 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h4><ul>
<li>mapper接口的全限定名要和mapper映射文件的namespace值一致</li>
<li>mapper接口的方法名称要和mapper映射文件的statement的id一致</li>
<li>mapper接口的方法参数类型要和mapper映射文件的statement的parameterType的值一致，而且它的参数是一个</li>
<li>mapper接口的方法返回值类型要和mapper映射文件的statement的resultType的值一致</li>
</ul>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="全局xml配置"><a href="#全局xml配置" class="headerlink" title="全局xml配置"></a>全局xml配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	* properties 属性</span><br><span class="line">	* settings 设置</span><br><span class="line">	* typeAliases 类型别名</span><br><span class="line">	* typeHandlers 类型处理器</span><br><span class="line">	* objectFactory 对象工厂</span><br><span class="line">	* plugins 插件</span><br><span class="line">	* environments 环境</span><br><span class="line">		* environment 环境变量</span><br><span class="line">		* transactionManager 事务管理器</span><br><span class="line">		* dataSource 数据源</span><br><span class="line">	* databaseIdProvider 数据库厂商标识</span><br><span class="line">	* mappers 映射器</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><ul>
<li><code>resource</code><ul>
<li>指定类路径下的资源配置文件位置</li>
</ul>
</li>
<li><code>url</code><ul>
<li>指定网络或者磁盘下的资源配置文件位置，是按照url的写法来写</li>
<li><code>协议 主机 端口 uri</code></li>
</ul>
</li>
</ul>
<h4 id="替换动态配置的属性值有三种方法"><a href="#替换动态配置的属性值有三种方法" class="headerlink" title="替换动态配置的属性值有三种方法"></a>替换动态配置的属性值有三种方法</h4><ol>
<li>引入外部properties文件<ul>
<li><code>&lt;properties resource=&quot;jdbc.properties&quot;&gt;</code></li>
</ul>
</li>
<li><p><code>properties</code>标签中也可添加属性配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">	 &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;</span><br><span class="line">	 &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SqlSessionFactoryBuilder.build()</code>方法中传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);</span><br><span class="line">// ... or ...</span><br><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>注<ul>
<li>如果属性在不只一个地方进行了配置，加载顺序<ul>
<li>2-1-3</li>
</ul>
</li>
<li>后加载的会覆盖先加载的，所以优先级<ul>
<li>方法传递属性&gt;外部properties文件&gt;内部<code>properties</code>标签</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">	&lt;setting name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">	......</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>影响mybatis的运行行为</li>
</ul>
<h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>配置别名</li>
<li>如果配置了别名，就不区分大小写</li>
</ul>
<h4 id="mybatis内置别名"><a href="#mybatis内置别名" class="headerlink" title="mybatis内置别名"></a>mybatis内置别名</h4><ul>
<li>基本类型，别名为在前边加一个<code>_</code><ul>
<li><code>_byte _int ...</code></li>
</ul>
</li>
<li>基本类型包装类，别名为其基本类型<ul>
<li><code>byte int ...</code></li>
</ul>
</li>
<li>字符串和集合，别名为其首字母小写<ul>
<li><code>string map list ...</code></li>
</ul>
</li>
</ul>
<h4 id="单个自定义"><a href="#单个自定义" class="headerlink" title="单个自定义"></a>单个自定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;</span><br><span class="line">	&lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type</code><ul>
<li>要配置别名的类型</li>
</ul>
</li>
<li><code>alias</code><ul>
<li>别名，不配置默认为类名首字母小写</li>
</ul>
</li>
</ul>
<h4 id="批量自定义"><a href="#批量自定义" class="headerlink" title="批量自定义"></a>批量自定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;package name=&quot;domain.blog&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>会为包及其子包下的类配置别名，默认为类名首字母小写</li>
<li>问题<ul>
<li>如果父包和子包有相同名称的类会出错</li>
<li>可以使用注解</li>
</ul>
</li>
</ul>
<h4 id="使用注解配置别名"><a href="#使用注解配置别名" class="headerlink" title="使用注解配置别名"></a>使用注解配置别名</h4><ul>
<li><code>@Alias</code></li>
</ul>
<h3 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li>java类型和数据库类型的相互处理</li>
<li>例如新型日期类型，mybatis3.4之前没有内置新日期类型处理器，需要自己配置，之后内置了</li>
</ul>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><h3 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">	&lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">		&lt;transactionManager type=&quot;JDBC&quot;&gt;</span><br><span class="line">			&lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;</span><br><span class="line">		&lt;/transactionManager&gt;</span><br><span class="line">		&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">			&lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">		&lt;/dataSource&gt;</span><br><span class="line">	&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">#### environments</span><br><span class="line">* 尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一</span><br><span class="line">* `default`</span><br><span class="line">	* 可以配置多个`environment`，通过`default=id`指定使用哪一个</span><br><span class="line"></span><br><span class="line">#### transactionManager</span><br><span class="line">* `type`</span><br><span class="line">	* `JDBC`</span><br><span class="line">		* `JdbcTransactionFactory`</span><br><span class="line">		* 直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域</span><br><span class="line">	* `MANAGED`</span><br><span class="line">		* `ManagedTransactionFactory`</span><br><span class="line">		* 几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如: </span><br><span class="line">			* `&lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;`</span><br><span class="line">* 事务管理器交给Spring</span><br><span class="line"></span><br><span class="line">#### dataSource</span><br><span class="line">* `type`</span><br><span class="line">	* `UNPOOLED`</span><br><span class="line">		* `UnpooledDataSourceFactory`</span><br><span class="line">		* 采用传统的获取连接的方式，虽然也实现了`javax.sql.DataSource`接口，但并没有使用池的思想</span><br><span class="line">	* `POOLED`</span><br><span class="line">		* `PooledDataSourceFactory`</span><br><span class="line">		* 采用传统的`javax.sql.DataSource`规范中的连接池，mybatis中有规范的实现</span><br><span class="line">	* `JNDI`</span><br><span class="line">		* `PooledDataSourceFactory`</span><br><span class="line">		* 采用服务器提供的JNDI技术实现，来获取`DataSource`对象，不同的服务器所能拿到的`DataSource`是不同的</span><br><span class="line">		* 注意：如果不上web或者maven的war工程，不能使用。</span><br><span class="line">		* tomcat服务器，采用的是dbcp连接池。</span><br><span class="line">* 数据源交给Spring</span><br><span class="line"></span><br><span class="line">### databaseIdProvider</span><br><span class="line">#### 作用</span><br><span class="line">* 获取数据库厂商标识(驱动`getDatabaseProductName()`)，mybatis就能根据数据库厂商标识执行不同sql</span><br><span class="line"></span><br><span class="line">#### 配置</span><br></pre></td></tr></table></figure>
<p><databaseidprovider type="DB_VENDOR"><br>    <property name="MySQL" value="别名"><br>    <property name="Oracle" value="别名"><br></property></property></databaseidprovider><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 在映射配置文件中的增删改查配置中</span><br><span class="line">	* `databaseId`</span><br><span class="line">		* 配置数据库标识别名，表示该crud操作是针对哪个数据库的</span><br><span class="line"></span><br><span class="line">### mappers</span><br><span class="line">#### 作用</span><br><span class="line">* 告诉 MyBatis 到哪里去找映射文件</span><br><span class="line"></span><br><span class="line">#### 配置</span><br><span class="line">1. 相对于类路径的资源引用</span><br></pre></td></tr></table></figure></p>
<p><mappers><br>    <mapper resource="org/mybatis/builder/AuthorMapper.xml"><br>    <mapper resource="org/mybatis/builder/BlogMapper.xml"><br>    <mapper resource="org/mybatis/builder/PostMapper.xml"><br></mapper></mapper></mapper></mappers><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 使用完全限定资源定位符引入网络或磁盘的资源（包括 file:/// 的 URL）</span><br></pre></td></tr></table></figure></p>
<p><mappers><br>    <mapper url="file:///D:/config/User.xml"><br></mapper></mappers><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3. 使用映射器接口的全限定名</span><br><span class="line">	* 要求mapper接口和mapper映射文件要名称相同，且放到同一个目录下</span><br></pre></td></tr></table></figure></p>
<p><mappers><br>    <mapper class="org.mybatis.builder.AuthorMapper"><br>    <mapper class="org.mybatis.builder.BlogMapper"><br>    <mapper class="org.mybatis.builder.PostMapper"><br></mapper></mapper></mapper></mappers><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4. 包名（推荐）</span><br><span class="line">	* 将包内的映射器接口实现全部注册为映射器</span><br><span class="line">	* 要求mapper接口和mapper映射文件要名称相同，且放到同一个目录下</span><br></pre></td></tr></table></figure></p>
<p><mappers><br>    <package name="org.mybatis.builder"><br></package></mappers><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 映射xml配置</span><br></pre></td></tr></table></figure></p>
<p><mapper></mapper></p>
<pre><code>* cache – 给定命名空间的缓存配置。
* cache-ref – 其他命名空间缓存配置的引用。
* resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。
* sql – 可被其他语句引用的可重用语句块。
* insert – 映射插入语句
* update – 映射更新语句
* delete – 映射删除语句
* select – 映射查询语句
</code></pre><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### select</span><br><span class="line">* `id`</span><br><span class="line">	* 在命名空间中唯一的标识符，可以被用来引用这条语句</span><br><span class="line">* `parameterType`</span><br><span class="line">	* 将会传入这条语句的参数类的完全限定名或别名</span><br><span class="line">	* 可以省略</span><br><span class="line">* `resultType`</span><br><span class="line">	* 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。（即集合泛型）</span><br><span class="line">	* 使用 resultType 或 resultMap，但不能同时使用。</span><br><span class="line">* `resultMap`</span><br><span class="line">	* 外部 resultMap 的命名引用</span><br><span class="line"></span><br><span class="line">### insert update delete</span><br><span class="line">* mytatis允许增删改返回值</span><br><span class="line">	* `Integer`</span><br><span class="line">		* 影响条数</span><br><span class="line">	* `Long`</span><br><span class="line">		* 影响条数</span><br><span class="line">	* `Boolean`</span><br><span class="line">		* 是否操作成功</span><br><span class="line">	* `void`</span><br><span class="line"></span><br><span class="line">#### 添加并获取自增主键</span><br><span class="line">* 获取后封装给了添加的javabean对象</span><br><span class="line"></span><br><span class="line">##### Mysql</span><br></pre></td></tr></table></figure></p>
<p><insert id="insert" parametertype="User" usegeneratedkeys="true" keyproperty="id"><br>    INSERT INTO USER(username,birthday,sex,address)<br>    VALUES(#{username},#{birthday},#{sex},#{address})<br></insert><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* mysql支持自增主键及其获取，mytaties也是利用`statment`的`getGeneratedKeys()`获取主键</span><br><span class="line">* `useGeneratedKeys`</span><br><span class="line">	* 告诉Mybatis使用自增主键获取主键策略</span><br><span class="line">* `keyProperty`</span><br><span class="line">	* 指定用对象的哪个属性保存Mybatis返回的主键</span><br><span class="line">	* 即mytatis获取主键后，将值封装到javabean的哪个属性上</span><br></pre></td></tr></table></figure></p>
<p><insert id="insert" parametertype="User"><br>    <selectkey keyproperty="id" resulttype="int" order="AFTER"><br>        SELECT LAST_INSERT_ID()<br>    </selectkey><br>    INSERT INTO USER(username,birthday,sex,address)<br>    VALUES(#{username},#{birthday},#{sex},#{address})<br></insert><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* `selectKey`</span><br><span class="line">	* 查询主键，在标签内需要输入查询主键的sql</span><br><span class="line">* `keyProperty`</span><br><span class="line">	* pojo类的主键字段名</span><br><span class="line">* `order`</span><br><span class="line">	* 指定查询主键的sql和insert语句的执行顺序，相当于insert语句来说</span><br><span class="line">	* `BEFORE`</span><br><span class="line">		* 会首先选择主键，设置 keyProperty 然后执行插入语句</span><br><span class="line">	* `AFTER`</span><br><span class="line">		* 先执行插入语句，然后是 selectKey 元素</span><br><span class="line">* `LAST_INSERT_ID`</span><br><span class="line">	* 该函数是mysql的函数，获取自增主键的ID，它必须配合insert语句一起使用</span><br><span class="line"></span><br><span class="line">##### Oracle</span><br></pre></td></tr></table></figure></p>
<p><insert id="insert" parametertype="User"><br>    <selectkey keyproperty="id" resulttype="int" order="before"><br>        SELECT 表序列.nextval from dual<br>    </selectkey><br>    INSERT INTO USER(id,username,birthday,sex,address)<br>    VALUES(#{id},#{username},#{birthday},#{sex},#{address})<br></insert><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* Oracle不支持自增，使用序列来模拟自增</span><br><span class="line">* 每次插入的主键是从序列中获取的，所以为`before`</span><br><span class="line"></span><br><span class="line">#### 添加并获取自增主键之uuid</span><br></pre></td></tr></table></figure></p>
<p><insert id="insert" parametertype="User"><br>    <selectkey keyproperty="id" resulttype="string" order="BEFORE"><br>        SELECT UUID()<br>    </selectkey><br>    INSERT INTO USER(id,username,birthday,sex,address)<br>    VALUES(#{id},#{username},#{birthday},#{sex},#{address})<br></insert><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">* `order`</span><br><span class="line">	* 先要有uuid才能insert，所以order为`before`</span><br><span class="line"></span><br><span class="line"># 输入映射(参数)</span><br><span class="line">## 参数获取</span><br><span class="line">### #&#123;&#125;</span><br><span class="line">* 表示一个占位符</span><br><span class="line">* 如果该参数是普通类型，那么$&#123;&#125;里面的参数名称可以任意</span><br><span class="line">* 预编译，将参数设置到PreparedStatement</span><br><span class="line"></span><br><span class="line">#### 扩展</span><br><span class="line">* 规定参数的一些规则</span><br><span class="line">	* `javaType，jdbcType，mode(存储过程)，numericScale`</span><br><span class="line">	* `resultMap，typeHandler，jdbcTypeName...`</span><br><span class="line">* `jdbcType`</span><br><span class="line">	* 当数据为null时，mybatis默认映射的是原生jdbc的`OTHER`类型</span><br><span class="line">	* 有些数据库（如Oracle）可能不识别mybatis对null的默认处理</span><br><span class="line">		* 错误信息：`JdbcType OTHER: 无效的类型`</span><br><span class="line">	* 解决</span><br><span class="line">		1. 取值时可以指定jdbcType</span><br><span class="line">			* `#&#123;xxx, jdbcType=NULL&#125;`</span><br><span class="line">		2. 在全局配置中的`setting`的`jdbcTypeForNull`设置为`NULL`</span><br><span class="line"></span><br><span class="line">### $&#123;&#125;</span><br><span class="line">* 表示一个sql的连接符</span><br><span class="line">* 如果该参数是简单类型，那么$&#123;&#125;里面的参数名称必须是`_parameter`</span><br><span class="line">*  `$&#123;&#125;`将值直接拼接到sql语句上，存在sql注入</span><br><span class="line">*  使用场景</span><br><span class="line">	* 原生jdbc不支持占位符的地方，可以使用$&#123;&#125;取值</span><br><span class="line">		* 如表名，排序...原生jdbc不支持使用占位符</span><br><span class="line">	1. 分表，如按年份分表</span><br><span class="line">		* `select * from $&#123;year&#125;_salary where...`</span><br><span class="line">	2. 排序</span><br><span class="line">		* `select * from xx order by $&#123;columName&#125;`</span><br><span class="line"></span><br><span class="line">## 单个普通类型（基本/包装+String）参数</span><br><span class="line">* `#&#123;任意名&#125;`</span><br><span class="line">	* 单个参数mybatis不作任何特殊处理</span><br><span class="line">	* 参数名任意</span><br><span class="line"></span><br><span class="line">## 多个（普通类型+POJO）参数</span><br><span class="line">* `#&#123;key&#125;`</span><br><span class="line">	* 多个参数mybatis会封装成一个Map</span><br><span class="line">	* `key`</span><br><span class="line">		1. `param1,param2...paramn`</span><br><span class="line">		2. `0,1...n`</span><br><span class="line"></span><br><span class="line">### @param</span><br><span class="line">* `param1...`或者`0,1...`作为key不习惯，可以使用此注解指定封装map时的key</span><br><span class="line">* 使用在Mapper接口方法的参数上</span><br><span class="line">	* `insertUser(@param(&quot;id&quot;)Integer id, @param(&quot;name&quot;)String name)&#123;&#125;`</span><br><span class="line">* 注意</span><br><span class="line">	* 如果使用了此注解那么其实key有两个`自定义key/param1`</span><br><span class="line">	* 也就是即使你自定义了key，param的数字还是会增加的</span><br><span class="line"></span><br><span class="line">## POJO</span><br><span class="line">* `#&#123;POJO属性名&#125;`</span><br><span class="line"></span><br><span class="line">## Map</span><br><span class="line">* `#&#123;key&#125;`</span><br><span class="line">	* 类似POJO，适用于参数与POJO属性不完全匹配时</span><br><span class="line"></span><br><span class="line">## Collection/Array</span><br><span class="line">* Collection(List/Set) 或者 数组 类型的参数，mybatis会作特殊处理</span><br><span class="line">	* 把传入的集合/数组封装到map中</span><br><span class="line">	* key</span><br><span class="line">		* `Collection(List/Set)`</span><br><span class="line">			* `collection`</span><br><span class="line">		* `List`</span><br><span class="line">			* `list`</span><br><span class="line">		* `Array`</span><br><span class="line">			* `array`</span><br><span class="line"></span><br><span class="line">## POJO包装类</span><br><span class="line">* `#&#123;POJO包装类属性名.POJO属性名&#125;`</span><br><span class="line">	* 通过对象导航图获取值</span><br><span class="line">	* 如果查询条件对应的属性在不同的pojo类中需要定义一个包装pojo类，此类中的属性对应不同的pojo类</span><br><span class="line"></span><br><span class="line">## TO（Transfer Object数据传输对象）</span><br><span class="line">* `#&#123;TO属性名&#125;`</span><br><span class="line">	* 当某些参数没有POJO对应但需要经常使用时，为了方便，可以创建一个TO对象，包含这些参数</span><br><span class="line"></span><br><span class="line"># 输出映射(结果类型)</span><br><span class="line">## resultType</span><br><span class="line">* 结果集的封装类型</span><br><span class="line">	* 与返回类型无关，主要看数据库数据封装成了什么。</span><br><span class="line">* 使用resultType进行结果映射时需要查询出的列名与映射属性名一致</span><br><span class="line">* **注**</span><br><span class="line">	* 查询出的列名和映射的对象的属性名一致，才能映射成功</span><br><span class="line">	* 如果查询的列名和对象的属性名全部不一致，那么映射的对象为空。</span><br><span class="line">	* 如果查询的列名和对象的属性名部分一致，那么映射的对象不为空，但是只有映射正确的属性才有值。</span><br><span class="line">	* 如果查询的sql的列名有别名，那么这个别名就是和属性映射的列名</span><br><span class="line"></span><br><span class="line">### 基本类型</span><br><span class="line">* `resultType`</span><br><span class="line">	* 基本类型</span><br><span class="line">* 查询的列必须是一列，才能映射为基本类型</span><br><span class="line">* 如查询总数</span><br><span class="line">	</span><br><span class="line">### POJO</span><br><span class="line">* `resultType`</span><br><span class="line">	* POJO类型</span><br><span class="line"></span><br><span class="line">### Collection &amp; 数组</span><br><span class="line">* `resultType`</span><br><span class="line">	* 集合或数组的元素类型。</span><br><span class="line"></span><br><span class="line">### Map</span><br><span class="line">* `resultType`</span><br><span class="line">	1. `map/java.util.Map`</span><br><span class="line">		* 当Map中封装一条记录时，key为列名，value为列值</span><br><span class="line">		* `Map&lt;String, Object&gt;`</span><br><span class="line">	2. value的`元素类型`</span><br><span class="line">		* 当Map中封装多条记录时，key为自定义（如主键），value为POJO类型</span><br><span class="line">			* `Map&lt;自定义, POJO类型&gt;`</span><br><span class="line">		* `key`</span><br><span class="line">			* `@MapKey`</span><br><span class="line">				* 作用在方法上用来指定key</span><br><span class="line">		* `value`</span><br><span class="line">			* POJO</span><br><span class="line"></span><br><span class="line">## 自动映射</span><br><span class="line">* `autoMappingBehavior`</span><br><span class="line">	* `partial`</span><br><span class="line">		* 默认，开启自动映射</span><br><span class="line">		* 要求列名与javabean属性名一致</span><br><span class="line">	* `null`</span><br><span class="line">		* 关闭自动映射</span><br><span class="line"></span><br><span class="line">## resultMap（自定义映射）</span><br></pre></td></tr></table></figure></p>
<p><resultmap id="" type=""><br>    <id property="" column=""><br>    <result property="" column=""><br>    <association><br>    <collection><br></collection></association></result></id></resultmap><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* `&lt;resultMap&gt;`</span><br><span class="line">	* `type`</span><br><span class="line">		* 结果集封装的类型</span><br><span class="line">* `&lt;id&gt;`</span><br><span class="line">	* 完成主键列的映射</span><br><span class="line">	* `property`</span><br><span class="line">		* javabean中的属性名</span><br><span class="line">	* `column`</span><br><span class="line">		* 结果集的列名</span><br><span class="line">* `&lt;result&gt;`</span><br><span class="line">	1. 完成普通列的映射</span><br><span class="line">	2. 级联</span><br><span class="line">		* 在关联查询时除了`association`和`collection`，还可以用`&lt;result&gt;`通过对象导航方式进行高级结果映射</span><br><span class="line">		* `&lt;result colum=&quot;数据库部门的id&quot; property=&quot;department.id&quot;/&gt;`</span><br><span class="line"></span><br><span class="line">### `&lt;association&gt;`</span><br></pre></td></tr></table></figure></p>
<p><association property="" javatype="" fetchtype=""><br>    <!-- id标签：建议在关联查询时必须写上，不写不会报错，但是会影响性能 --><br>    <id column="" property=""><br>    <result column="" property=""><br></result></id></association><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* 完成一对一/多对一的映射，即联合属性是单个类型的</span><br><span class="line">* `property`</span><br><span class="line">	* 联合属性名</span><br><span class="line">* `javaType`</span><br><span class="line">	* 联合属性对应的类型</span><br><span class="line">* `fetchType`</span><br><span class="line">	* `lazy`</span><br><span class="line">		* 默认，本次查询使用延迟加载</span><br><span class="line">	* `eager`</span><br><span class="line">		* 本次查询不适用延迟加载</span><br><span class="line">		* 有个查询不想用延迟加载，可以设置这个属性，而不必关闭全局设置的懒加载。</span><br><span class="line"></span><br><span class="line">#### 分步查询</span><br><span class="line">* 例如查询员工信息，并查询员工对应部门信息</span><br><span class="line">	1. 先根据员工id查询员工信息</span><br><span class="line">	2. 根据外键（部门id）查询部门信息</span><br><span class="line">		* 需要一个部门的`&lt;select id=&quot;getById&gt;&quot;`</span><br></pre></td></tr></table></figure></p>
<p><association property="" select="" column=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	* `property`</span><br><span class="line">		* 联合属性名</span><br><span class="line">		* 会把select根据column查询的结果赋值给property</span><br><span class="line">	* `select`</span><br><span class="line">		* 部门的根据id查询对象Sql的`namespace.id`</span><br><span class="line">	* `column`</span><br><span class="line">		* 员工结果集中联合属性对应列名（即外键部门id）</span><br><span class="line">		* 如果分布查询，需要多个参数，需要封装为map</span><br><span class="line">			* `column=&quot;&#123;自定义key=列名, ...&#125;&quot;`</span><br><span class="line">			* 在select对应的查询语句中，获取参数需要使用这里的自定义key</span><br><span class="line">* 为何使用分布查询？</span><br><span class="line">	1. 通常每个实体都有对应的crud，所以既然有了就拿来用</span><br><span class="line">	2. 延迟加载/懒加载</span><br><span class="line"></span><br><span class="line">#### 懒加载</span><br><span class="line">* 使用时才查询联合属性</span><br><span class="line">* 全局配置</span><br><span class="line">	* `&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;`</span><br><span class="line">		* 是否开启懒加载</span><br><span class="line">		* `false`</span><br><span class="line">			* 默认，不开启</span><br><span class="line">	* `&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;`</span><br><span class="line">		* `true`</span><br><span class="line">			* 默认，全部加载</span><br><span class="line">			* 例如只想看部门名称，会查询所有部门信息</span><br><span class="line">		* `false`</span><br><span class="line">			* 按需加载</span><br><span class="line">			* 例如只想看部门名称，只会查询部门名称</span><br><span class="line"></span><br><span class="line">### `&lt;collection&gt;`</span><br></pre></td></tr></table></figure></association></p>
<p><collection property="" oftype=""><br>    <id column="" property=""><br>    <result column="" property=""><br></result></id></collection><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 完成一对多/多对多的映射，即联合属性是集合类型</span><br><span class="line">* `property`</span><br><span class="line">	* 联合属性名</span><br><span class="line">* `ofType`</span><br><span class="line">	* 联合属性中封装的类型（即集合泛型）</span><br><span class="line"></span><br><span class="line">#### 分布查询</span><br><span class="line">* 例如查询部门信息，并查询部门下所有员工信息</span><br><span class="line">	1. 先根据部门id查询部门信息</span><br><span class="line">	2. 根据部门id作为员工外键，查询所有员工信息</span><br></pre></td></tr></table></figure></p>
<p><collection property="" select="namespace.selectID" column=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 动态sql</span><br><span class="line">## sql片段</span><br></pre></td></tr></table></figure></collection></p>
<p><sql id="sqlID"><br>    code…<br></sql><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* sql片段内可以定义sql语句中的任何部分</span><br><span class="line">* sql片段内最好不要包含select where..关键字</span><br><span class="line">* 引入sql片段</span><br><span class="line">	* `&lt;include refid=&quot;sqlID&quot;/&gt;`</span><br><span class="line">	</span><br><span class="line">## if</span><br></pre></td></tr></table></figure></p>
<p><select id="findActiveBlogLike" resulttype="Blog"><br>    SELECT * FROM BLOG<br>    WHERE<br>    <if test="state != null"><br>        state = #{state}<br>    </if><br>    <if test="title != null"><br>        AND title like #{title}<br>    </if><br>    <if test="author != null and author.name != null"><br>        AND author_name like #{author.name}<br>    </if><br></select><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* `trim()`</span><br><span class="line">	* 去空格</span><br><span class="line">* 特殊符号</span><br><span class="line">	* `&amp;&amp;`要使用`&amp;amp;`</span><br><span class="line">	* ...</span><br><span class="line"></span><br><span class="line">## where</span><br><span class="line">* if标签的问题在于</span><br><span class="line">	* 如果这些条件没有一个能匹配上</span><br><span class="line">		* 则最终sql语句`SELECT * FROM BLOG WHERE`</span><br><span class="line">	* 如果仅仅第二个条件匹配</span><br><span class="line">		* 则最终sql语句`SELECT * FROM BLOG WHERE AND title like ‘someTitle’`</span><br></pre></td></tr></table></figure></p>
<p><select id="findActiveBlogLike" resulttype="Blog"><br>    SELECT * FROM BLOG<br>    <where><br>        <if test="state != null"><br>                 state = #{state}<br>        </if><br>        <if test="title != null"><br>                AND title like #{title}<br>        </if><br>        <if test="author != null and author.name != null"><br>                AND author_name like #{author.name}<br>        </if><br>    </where><br></select><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## trim</span><br></pre></td></tr></table></figure></p>
<p><trim prefix="where" prefixoverrides="" suffix="" suffixoverrides="and | or"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 可以在条件判断完的SQL语句前后 添加或者去掉指定的字符</span><br><span class="line">* `prefix`</span><br><span class="line">	* 添加一个前缀</span><br><span class="line">* `prefixOverrides`</span><br><span class="line">	* 覆盖/去掉一个前缀</span><br><span class="line">* `suffix`</span><br><span class="line">	* 添加一个后缀</span><br><span class="line">* `suffixOverrides`</span><br><span class="line">	* 覆盖/去掉一个后缀</span><br><span class="line"></span><br><span class="line">## set</span><br></pre></td></tr></table></figure></trim></p>
<p><update><br>    update…<br>    <set><br>        …<br>    </set><br></update><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 主要是用于解决修改操作中SQL语句中可能多出逗号的问题</span><br><span class="line"></span><br><span class="line">## choose（when/otherwise）</span><br><span class="line">* 主要是用于分支判断，类似于java中的switch case,只会满足所有分支中的一个</span><br><span class="line"></span><br><span class="line">## foreach</span><br><span class="line">* 主要用户循环迭代，通常是在构建 IN 条件语句的时候</span><br><span class="line">* 还可以用来完成批量操作</span><br></pre></td></tr></table></figure></p>
<p><select id="selectPostIn" resulttype="domain.blog.Post"><br>    SELECT *<br>    FROM POST P<br>    WHERE ID in<br>    <foreach item="item" index="index" collection="list" open="(" separator="," close=")"></foreach></select></p>
<pre><code>        #{item}
&lt;/foreach&gt;
</code></pre><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">* `collection`</span><br><span class="line">	* pojo类</span><br><span class="line">		* 类中数组/集合属性的属性名称</span><br><span class="line">	* 数组</span><br><span class="line">		* array</span><br><span class="line">	* 集合</span><br><span class="line">		* list</span><br><span class="line">	* 注</span><br><span class="line">		* 即如果参数是一个对像，则collection写的是对象中的字段名，如果参数是数组，则collection写的是array，集合写的是list</span><br><span class="line">		* 原因（安）</span><br><span class="line">			* mybatis在注入参数时，没有使用参数名称</span><br><span class="line">			* 而是使用一个map，存入参数</span><br><span class="line">			* pojo</span><br><span class="line">				* put(字段,值)</span><br><span class="line">			* 数组</span><br><span class="line">				* put(array,值)</span><br><span class="line">			* 集合</span><br><span class="line">				* put(list,值)</span><br><span class="line">* `item`</span><br><span class="line">	* 为遍历的结果声明一个变量名</span><br><span class="line">* `open`</span><br><span class="line">	* 遍历开始时需要拼接的字符串</span><br><span class="line">* `close`</span><br><span class="line">	* 遍历结束时需要拼接的字符串</span><br><span class="line">* `separator`</span><br><span class="line">	* 遍历中间需要拼接的连接符</span><br><span class="line">* `index`</span><br><span class="line">	* `List`</span><br><span class="line">		* 表示的当前元素的下标</span><br><span class="line">	* `Map`</span><br><span class="line">		* 表示的当前元素的key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 注解</span><br><span class="line">* `@Insert`</span><br><span class="line">* `@Update`</span><br><span class="line">* `@Delete`</span><br><span class="line">* `@Select`</span><br><span class="line">* `@Result`</span><br><span class="line">	* 结果集封装</span><br><span class="line">* `@Results`</span><br><span class="line">	* 封装多个结果集，可以和`@Result`一起用</span><br></pre></td></tr></table></figure></p>
<p>@Results(id=””, value={<br>            @Result(id=true, column=””, property=””),<br>            @Result(column=””, property=””)<br>    …<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* `@ResultMap`</span><br><span class="line">	* 引用`@Results`定义的封装</span><br></pre></td></tr></table></figure></p>
<p>@ResultMap(value={“@Results的id”})<br><code>`</code></p>
<ul>
<li><code>@One</code><ul>
<li>一对一结果集封装</li>
</ul>
</li>
<li><code>@Many</code><ul>
<li>一对多结果集封装</li>
</ul>
</li>
<li><code>@SelectProvider</code><ul>
<li>动态sql映射</li>
</ul>
</li>
<li><code>@CacheNamespace</code><ul>
<li>二级缓存 </li>
</ul>
</li>
</ul>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>缓存即存于内存中的临时数据，为了减少和数据库的交互次数，提高效率</li>
<li>适合缓存的数据<ul>
<li>经常使用且不经常改变的。</li>
<li>数据正确与否对最终结果影响不大的。<ul>
<li>商品库存，银行汇率，股市牌价…对结果影响大的不适合缓冲。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><ul>
<li>一级缓存指的就是SqlSession对象的缓存。</li>
<li>在SqlSession中有一个数据区域，是map结构，这个区域就是一级缓存区域。<ul>
<li>一级缓存中的key<ul>
<li>由sql语句、条件、statement等信息组成一个唯一值。</li>
</ul>
</li>
<li>一级缓存中的value<ul>
<li>就是查询出的结果对象</li>
</ul>
</li>
</ul>
</li>
<li>一级缓存是默认使用的</li>
</ul>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ul>
<li>第一次查询查询数据库并写入缓存区域</li>
<li>第二次查询读取缓存区域</li>
</ul>
<h3 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h3><ol>
<li>sqlsession关闭<code>close()</code></li>
<li><code>clearCache()</code><ul>
<li>清空缓存。</li>
</ul>
</li>
<li>增删改commit会清空缓存</li>
</ol>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><ul>
<li>二级缓存指的是mybatis中SqlSessionFactory对象的缓存</li>
<li>同一个SqlSessionFactory创建的SqlSession共享缓存数据。</li>
<li>二级缓存中存放的是数据而不是对象<ul>
<li>多次查询时对象不是同一个，数据相同。</li>
</ul>
</li>
<li>二级缓存需要手动开启。</li>
</ul>
<h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><ul>
<li><code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code><ul>
<li>二级缓存总开关</li>
</ul>
</li>
<li><code>&lt;cache type=&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;/&gt;</code><ul>
<li>在映射文件中开启二级缓存</li>
<li>默认使用PerpetualCache 可以省略type</li>
</ul>
</li>
</ul>
<h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h3><ul>
<li><code>&lt;select useCache=&quot;false&quot;&gt;</code><ul>
<li>在映射文件中select标签上</li>
<li>默认true</li>
</ul>
</li>
</ul>
<h3 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h3><ul>
<li><code>&lt;select flushCache=&quot;true&quot;&gt;</code><ul>
<li>在映射文件中select标签上</li>
<li>在select中默认false </li>
<li>增删改中默认 true</li>
<li>相当于将缓存失效。?</li>
</ul>
</li>
</ul>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><ul>
<li>第一个sqlSession执行xxxMapper查询写入xxxMapper的二级缓存区域<ul>
<li>sqlSession关闭时才会将数据写入二级缓存</li>
</ul>
</li>
<li>第二个sqlSession执行xxxMapper查询读取二级缓存区域</li>
<li>其它sqlSession执行xxxMapper（插入，更新，删除）会清除二级缓存</li>
</ul>
<h3 id="整合Ehcache"><a href="#整合Ehcache" class="headerlink" title="整合Ehcache"></a>整合Ehcache</h3><ul>
<li>Mybatis本身是一个持久层框架，它不是专门的缓存框架，所以它对缓存的实现不够好，不能支持分布式。</li>
<li>Ehcache是一个分布式的缓存框架</li>
</ul>
<h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><ul>
<li>系统为了提高性能，通常会对系统采用分布式部署（集群部署方式）</li>
</ul>
<h4 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h4><ul>
<li>Cache是一个接口，它的默认实现是mybatis的PerpetualCache。如果想整合mybatis的二级缓存，那么实现Cache接口即可</li>
</ul>
<h4 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h4><ol>
<li>jar包</li>
<li>设置映射文件中cache标签的type值为ehcache的实现类</li>
<li>添加ehcache的配置文件</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>对于访问响应速度要求高，但是实时性不高的查询，可以采用二级缓存技术。</li>
<li>注意<ul>
<li>在使用二级缓存的时候，要设置一下刷新间隔（cache标签中有一个flashInterval属性）来定时刷新二级缓存，这个刷新间隔根据具体需求来设置，比如设置30分钟、60分钟等，单位为毫秒。</li>
</ul>
</li>
</ul>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul>
<li>Mybatis二级缓存对细粒度的数据，缓存实现不好。</li>
<li>场景<ul>
<li>对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次查询都是最新的商品信息，此时如果使用二级缓存，就无法实现当一个商品发生变化只刷新该商品的缓存信息而不刷新其他商品缓存信息，因为二级缓存是mapper级别的，当一个商品的信息发送更新，所有的商品信息缓存数据都会清空。</li>
</ul>
</li>
<li>解决此类问题<ul>
<li>需要在业务层根据需要对数据有针对性的缓存。</li>
<li>比如可以对经常变化的 数据操作单独放到另一个namespace的mapper中</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-SpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-SpringMVC/" itemprop="url">
                  xd-SpringMVC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:40:23" itemprop="dateCreated datePublished" datetime="2018-12-11T00:40:23+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:45:53" itemprop="dateModified" datetime="2019-03-08T14:45:53+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>Springmvc是一个web层mvc框架</li>
<li>支持REST风格url请求</li>
<li>采用了松散耦合可插拔组建结构</li>
</ul>
<h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><p><img src="https://gitee.com/3noanswer/pics/raw/master/frame/springmvc工作流程.jpg" alt=""><br><img src="https://gitee.com/3noanswer/pics/raw/master/frame/springmvc流程.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1）用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获；</span><br><span class="line">2）DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）:</span><br><span class="line">判断请求URI对应的映射</span><br><span class="line">	① 不存在：</span><br><span class="line">		* 再判断是否配置了mvc:default-servlet-handler：</span><br><span class="line">			1 如果没配置，则控制台报映射查找不到，客户端展示404错误</span><br><span class="line">			2 如果有配置，则执行目标资源（一般为静态资源，如：JS,CSS,HTML）</span><br><span class="line">	② 存在：</span><br><span class="line">		* 执行下面流程</span><br><span class="line">3）根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</span><br><span class="line">4）DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</span><br><span class="line">5）如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法【正向】</span><br><span class="line">6）提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</span><br><span class="line">	① HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</span><br><span class="line">	② 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</span><br><span class="line">	③ 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</span><br><span class="line">	④ 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</span><br><span class="line">7）Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</span><br><span class="line">8）此时将开始执行拦截器的postHandle(...)方法【逆向】</span><br><span class="line">9）根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet，根据Model和View，来渲染视图</span><br><span class="line">10）在返回给客户端时需要执行拦截器的AfterCompletion方法【逆向】</span><br><span class="line">11）将渲染结果返回给客户端</span><br></pre></td></tr></table></figure></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置前端控制器：DispatcherServlet"><a href="#配置前端控制器：DispatcherServlet" class="headerlink" title="配置前端控制器：DispatcherServlet"></a>配置前端控制器：DispatcherServlet</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认加载<ul>
<li><code>WEB-INF/&lt;servlet-name&gt;标签的值-servlet.xml</code></li>
<li>上例中即默认加载<code>WEB-INF/springMVC-servlet.xml</code></li>
</ul>
</li>
<li><code>&lt;url-pattern&gt;</code><ul>
<li><code>/*</code>（不建议）<ul>
<li>拦截所有，包含<code>.jsp</code>，包含静态资源(.js .png .css…..)</li>
</ul>
</li>
<li><code>/</code>（建议）<ul>
<li>拦截所有，不包含<code>.jsp</code>，包含静态资源(.js .png .css…..)</li>
<li>多用在前台</li>
</ul>
</li>
<li><code>*.action/do</code><ul>
<li>拦截指定扩展名</li>
<li>多用在后台</li>
<li>对REST支持不好</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="请求的拦截"><a href="#请求的拦截" class="headerlink" title="请求的拦截"></a>请求的拦截</h3><ul>
<li><p><code>/</code>为何不拦截jsp？</p>
<ul>
<li><p>tomcat中除了<code>default</code>servlet，还有处理jsp的Servlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">	        &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">	        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;</span><br><span class="line">	        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;</span><br><span class="line">	        &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优先级</p>
<ul>
<li>tomcat的JspServlet的<code>.jsp/.jspx</code> &gt; DispatcherServlet的<code>/</code> &gt; tomcat的DefaultServlet的<code>/</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="lt-mvc-annotation-driven-gt"><a href="#lt-mvc-annotation-driven-gt" class="headerlink" title="&lt;mvc:annotation-driven/&gt;"></a><code>&lt;mvc:annotation-driven/&gt;</code></h2><ol>
<li>注册<code>RequestMappingHandlerMapping</code></li>
<li>注册<code>RequestMappingHandlerAdapter</code></li>
<li>注册<code>ExceptionHandlerExceptionResolver</code></li>
<li>支持<ol>
<li><code>ConversionService</code></li>
<li><code>@NumberFormat annotation 、@DateTimeFormat</code>完成数据类型格式化</li>
<li><code>@Valid</code>对JavaBean进行JSR303校验</li>
<li><code>@RequestBody 和 @ResponseBody</code></li>
</ol>
</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>启动一些新的组件对象替换原先旧的组件对象，从而实现一些新的，更强大的功能</li>
<li>为何配置了<code>1&lt;mvc:default-servlet-handler&gt;</code>还要配置<code>2&lt;mvc:annotation-driven&gt;</code>？<ul>
<li>DespatcherServlet中HandlerAdapters中的装配<ul>
<li>1/2都没有配置时:<ol>
<li>HttpRequestHandlerAdapter</li>
<li>SimpleControllerHandlerAdapter</li>
<li>AnnotationMethodHandlerAdapter（过时）</li>
</ol>
</li>
<li>1配置，2没有配置<ol>
<li>HttpRequestHandlerAdapter</li>
<li>SimpleControllerHandlerAdapter</li>
</ol>
</li>
<li>1/2都配置<ol>
<li>HttpRequestHandlerAdapter</li>
<li>SimpleControllerHandlerAdapter</li>
<li>RequestMappingHandlerAdapter</li>
</ol>
</li>
</ul>
</li>
<li>spring3.2之后，注解适配器用RequestMappingHandlerAdapter替换了AnnotationMethodHandlerAdapter</li>
</ul>
</li>
</ul>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>若将DispatcheServlet请求映射设置为/，则SpringMvc将捕获WEB容器的所有请求，包括静态资源的请求，SpringMvc会将它们当成一个普通的请求处理，那么将会出现因找不到对应的处理器将导致错误</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol>
<li><p>在springmvc核心配置文件中配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置静态资源访问 **表示的包含自身包和子包的所有文件--&gt;</span><br><span class="line">&lt;mvc:resources mapping=&quot;/statics/**&quot; location=&quot;/statics/&quot; &gt;&lt;/mvc:resources&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在springmvc核心配置文件配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:default-servlet-handler default-servlet-name=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;mvc:default-servlet-handler/&gt;</code>将在SpringMvc上下文中定义一个DefaultServletHttpRequestHandler，它会对进入DispatcheServlet的请求进行筛选，如果发现没有经过映射的请求，就将该请求交由WEB应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcheServlet处理。</li>
<li><code>default-servlet-name</code><ul>
<li>一般web应用服务器默认的Servlet名称都是default，如果不是，需要手动配置</li>
</ul>
</li>
<li>tomcat的默认Servlet<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	        &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">	        &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">			&lt;servelt-name&gt;default&lt;/servelt-name&gt;</span><br><span class="line">			&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="springmvc默认加载的组件"><a href="#springmvc默认加载的组件" class="headerlink" title="springmvc默认加载的组件"></a>springmvc默认加载的组件</h2><ul>
<li>在<code>DispatcherServlet.properties</code>中</li>
</ul>
<h2 id="前端控制器"><a href="#前端控制器" class="headerlink" title="前端控制器"></a>前端控制器</h2><ul>
<li><code>DispatcherServlet</code><ul>
<li>调度，指挥谁该干什么了</li>
</ul>
</li>
</ul>
<h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><ul>
<li><code>Handler</code><ul>
<li>干活的具体内容，干完会返回ModelAndView给处理器适配器</li>
<li>即业务内容，我们编写</li>
</ul>
</li>
</ul>
<h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><ul>
<li><code>HandlerMapping</code><ul>
<li>负责找到需要哪个Handler做事情</li>
</ul>
</li>
</ul>
<h3 id="编程式映射器"><a href="#编程式映射器" class="headerlink" title="编程式映射器"></a>编程式映射器</h3><h4 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h4><ul>
<li>根据请求url去匹配自定义Handler bean的name属性，从而获取Controller(Handler)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</span><br><span class="line">&lt;!-- 配置自定义Controler --&gt;</span><br><span class="line">&lt;bean name=&quot;/hello.do&quot; class=&quot;cn.an.controller.MyController&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="SimpleUrlHandlerMaping"><a href="#SimpleUrlHandlerMaping" class="headerlink" title="SimpleUrlHandlerMaping"></a>SimpleUrlHandlerMaping</h4><ul>
<li>根据请求url匹配key，key又根据value即Controller的id找到Controller<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;mappings&quot;&gt;</span><br><span class="line">	  &lt;props&gt;</span><br><span class="line">	    &lt;prop key=&quot;/abc.do&quot;&gt;myController&lt;/prop&gt;</span><br><span class="line">	    &lt;prop key=&quot;/ss.do&quot;&gt;xx&lt;/prop&gt;</span><br><span class="line">	    &lt;prop key=&quot;/mine.do&quot;&gt;yy&lt;/prop&gt;</span><br><span class="line">	  &lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 配置自定义Controler --&gt;</span><br><span class="line">&lt;bean id=&quot;myController&quot; class=&quot;cn.an.controller.MyController&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="注解式映射器"><a href="#注解式映射器" class="headerlink" title="注解式映射器"></a>注解式映射器</h3><h4 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h4><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><ul>
<li><code>HandlerAdapter</code><ul>
<li>负责执行Handler</li>
</ul>
</li>
</ul>
<h3 id="编程式适配器"><a href="#编程式适配器" class="headerlink" title="编程式适配器"></a>编程式适配器</h3><h4 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h4><ul>
<li>Handle必须实现<code>HttpRequesHandler</code>接口</li>
</ul>
<h4 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h4><ul>
<li>Handler必须实现<code>Controller</code>接口</li>
</ul>
<h3 id="注解式适配器"><a href="#注解式适配器" class="headerlink" title="注解式适配器"></a>注解式适配器</h3><h4 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h4><h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><ul>
<li><code>ViewResolver</code><ul>
<li>负责解析逻辑视图，返回Viwe对象</li>
</ul>
</li>
</ul>
<h3 id="InternalResourceViewResolver"><a href="#InternalResourceViewResolver" class="headerlink" title="InternalResourceViewResolver"></a>InternalResourceViewResolver</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果设置的是逻辑视图，则最终真正的物理视图=<code>前缀(prefix)+逻辑视图+后缀(suffix)</code></li>
<li>如果项目使用了jstl，则springmvc会自动把视图由<code>InternalResourceViewResolver</code>转为<code>JstlView</code></li>
<li>如果想要直接响应springmvc渲染的页面，可以使用<code>mvc:view-controller</code>实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:view-controller path=&quot;请求路径&quot; view-name=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="定义在类上"><a href="#定义在类上" class="headerlink" title="定义在类上"></a>定义在类上</h4><ul>
<li>第一级的访问目录</li>
<li><code>@RequestMapping(&quot;/user&quot;)</code><ul>
<li>是为了确定哪个controller的方法</li>
<li>请求路径为<code>/user/xxx</code></li>
</ul>
</li>
</ul>
<h4 id="定义在方法上"><a href="#定义在方法上" class="headerlink" title="定义在方法上"></a>定义在方法上</h4><ul>
<li>第二级的访问目录</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>String[] value</code><ul>
<li>与<code>path</code>通用，指定请求url</li>
<li>值并不是路径而是字符串，所以<code>/</code>可写可不写。</li>
</ul>
</li>
<li><code>String[] path</code></li>
<li><code>RequestMethod[] method</code><ul>
<li>确定请求方式，不写表示所有请求方式都有用</li>
<li><code>RequestMethod.POST/RequestMethod.GET</code></li>
</ul>
</li>
<li><code>String[] params</code><ul>
<li>用于指定限制请求参数的条件，支持简单的表达式。要求请求参数的key和value必须和配置的一样。</li>
<li><code>params={&quot;username&quot;}</code><ul>
<li>表示请求参数必须有username</li>
</ul>
</li>
<li><code>params={&quot;age=11&quot;}</code><ul>
<li>表示请求参数必须有age=11</li>
</ul>
</li>
<li><code>params={&quot;money!100&quot;}</code><ul>
<li>表示请求参数必须有money且值不为100</li>
</ul>
</li>
</ul>
</li>
<li><code>String[] headers</code><ul>
<li>发送的请求中必须包含的请求头</li>
<li><code>headers{&quot;Accept&quot;}</code><ul>
<li>表示请求头中必须有Accept</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@RequestParam(value=&quot;username&quot;,required=false)String name) &#123;</span><br><span class="line">	System.out.println(name);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>把请求中的指定名称的参数传递给控制器中的形参赋值</li>
</ul>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>请求参数中的名称</li>
</ul>
</li>
<li><code>required</code><ul>
<li>请求参数中是否必须提供此参数</li>
<li>默认true</li>
<li><code>false</code><ul>
<li>如果请求参数中没有此参数，则会赋值为null</li>
<li>如果是基本类型如int，null值是不能赋值的。可以指定默认值</li>
</ul>
</li>
</ul>
</li>
<li><code>defaultValue</code><ul>
<li>指定默认值来取代null</li>
</ul>
</li>
</ul>
<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@RequestBody String body) &#123;</span><br><span class="line">	System.out.println(body);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于获取请求体的内容（注意：get方法不可以）</li>
</ul>
<h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>required</code><ul>
<li>是否必须有请求体，默认值是true</li>
</ul>
</li>
</ul>
<h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello/&#123;id&#125;&quot;)</span><br><span class="line">public String sayHello(@PathVariable(value=&quot;id&quot;) String id) &#123;</span><br><span class="line">	System.out.println(id);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ul>
<li>拥有绑定url中的占位符的<ul>
<li><code>/delete/{id}</code><ul>
<li>{id}就是占位符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>指定url中的占位符名称</li>
</ul>
</li>
</ul>
<h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@RequestHeader(value=&quot;Accept&quot;) String header) &#123;</span><br><span class="line">	System.out.println(header);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><ul>
<li>获取指定请求头的值</li>
</ul>
<h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>请求头的名称</li>
</ul>
</li>
</ul>
<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@CookieValue(value=&quot;JSESSIONID&quot;) String cookieValue) &#123;</span><br><span class="line">	System.out.println(cookieValue);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于获取指定cookie的名称的值</li>
</ul>
<h3 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>cookie的名称</li>
</ul>
</li>
</ul>
<h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><h3 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h3><ul>
<li>方法上<ul>
<li>表示当前方法会在控制器方法执行前先执行</li>
</ul>
</li>
<li>参数上<ul>
<li>其value属性会有以下作用<ol>
<li>springmvc会使用value属性作为key在<code>implicitModel</code>查找数据，如果存在则会之间传入目标方法参数中</li>
<li>springmv会以value为key，pojo对象为value存入request中</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据</li>
<li>假如有一个实体类，表单中的属性可能不全，那么更新的时候，有的字段就会没有值，想要有值<ol>
<li>使用隐藏域（不安全，字段多麻烦）</li>
<li>更新前手动设置</li>
<li>不新建实体类，而是从数据库中获取，那么只更新需要更新的属性，不需要更新的属性还是原来数据库中的值。（店长推荐）</li>
</ol>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol>
<li>调用<code>@ModelAttribute</code>修饰的方法，实际上把<code>@ModelAttribute</code>方法Map中的数据放入了<code>implicitModel</code></li>
<li>解析请求处理器的目标参数，实际上该目标参数来自于<code>WebDataBinder</code>的<code>target</code>属性<ol>
<li>创建<code>WebDataBinder</code>，需要两个属性<code>objectName</code>和<code>target</code><ol>
<li><code>objectName</code><ul>
<li>目标方法的pojo参数是否使用<code>@modelAttribute(value=&quot;值&quot;)</code>修饰<ul>
<li>没有使用，则传入的<code>attrName=&quot;&quot;</code>，则objectName为类名第一个字母小写</li>
<li>使用了，则传入的<code>attrName=&quot;value的值&quot;</code>，则objectName为attrName的值</li>
</ul>
</li>
</ul>
</li>
<li><code>target</code><ul>
<li>在<code>implicitModel</code>中查找<code>attrName</code>对应的值<ul>
<li>若存在，则把数据赋给<code>target</code></li>
<li>若不存在，则查看当前Handler是否使用了<code>@SessionAttributes</code>修饰，如果使用了，则尝试从session中获取<code>attrName</code>对应的值，如果session中没有，则抛出异常。</li>
<li>如果Handler没有使用<code>@SessionAttributes</code>进行修饰，或者<code>@SessionAttributes</code>中没有与<code>attrName</code>相匹配的key，则通过反射创建POJO对象，然后赋值给target</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>springmvc把表单请求参数赋给了<code>WebDataBinder</code>的<code>target</code>对应的属性</li>
<li>springmvc把<code>WebDataBinder</code>的<code>attrName</code>和<code>target</code>给<code>implicitModel</code></li>
<li>把<code>WebDataBinder</code>的<code>target</code>作为参数传递给目标方法的pojo参数</li>
</ol>
</li>
</ol>
<ul>
<li>安<ol>
<li>在<code>@ModelAttribute</code>修饰的方法中从数据库查询数据，并放入map中（实际会放入<code>implicitModel</code>）<ul>
<li>如<code>map.put(&quot;user&quot;,user)</code></li>
<li>此时<code>implicitModel</code>中是数据库中的数据</li>
</ul>
</li>
<li>更新方法的参数<ol>
<li><code>User user</code><ul>
<li>则<code>WebDataBinder</code>的<code>objectName</code>为<code>User</code>首字母小写即<code>user</code>，以<code>user</code>作为key在<code>implicitModel</code>中查询，然后赋值给<code>WebDataBinder</code>的<code>target</code></li>
</ul>
</li>
<li><code>@ModelAttribute(&quot;aaa&quot;)User user</code><ul>
<li>则<code>WebDataBinder</code>的<code>objectName</code>为<code>aaa</code>，以<code>aaa</code>作为key在<code>implicitModel</code>中查询，然后赋值给<code>WebDataBinder</code>的<code>target</code></li>
</ul>
</li>
</ol>
<ul>
<li>如果最后没有找到，会通过反射新建一个对象赋值给<code>target</code></li>
<li>(关于<code>@SessionAttributes</code>见上边，这里避免不清晰)</li>
<li>此时<code>implicitModel</code>中是数据库中的数据，<code>WebDataBinder</code>中的<code>target</code>也是数据库中的数据</li>
</ul>
</li>
<li>表单请求参数赋值给<code>WebDataBinder</code>的<code>target</code>对应的属性<ul>
<li>此时<code>implicitModel</code>中是数据库中的数据，<code>WebDataBinder</code>中的<code>target</code>是更新后的数据</li>
</ul>
</li>
<li><code>WebDataBinder</code>赋给<code>implicitModel</code><ul>
<li>此时<code>implicitModel</code>中是更新后的数据，<code>WebDataBinder</code>中的<code>target</code>是更新后的数据</li>
</ul>
</li>
<li>把<code>WebDataBinder</code>的<code>target</code>赋值给更新方法的对应参数<ul>
<li>此时更新方法中的参数即为更新后的数据</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h2><ul>
<li>只能用在类上</li>
</ul>
<h3 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于多次执行控制器方法间的参数共享（即会把指定的属性存入session域中）</li>
</ul>
<h3 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>String[] value</code><ul>
<li>指定存入属性的名称</li>
</ul>
</li>
<li><code>Class[] type</code><ul>
<li>指定存入属性的类型</li>
</ul>
</li>
</ul>
<h2 id="InitBinder"><a href="#InitBinder" class="headerlink" title="@InitBinder"></a>@InitBinder</h2><ul>
<li>用在方法上</li>
</ul>
<h3 id="作用-8"><a href="#作用-8" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于忽略某个字段</li>
<li>比如添加用户时，页面提交的是角色的id集合，而用户中字段是角色类型，就需要手动赋值，此时就可以忽略角色字段。</li>
</ul>
<h1 id="请求参数绑定"><a href="#请求参数绑定" class="headerlink" title="请求参数绑定"></a>请求参数绑定</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Springmvc通过命令设计模式接受页面参数</li>
<li>springmvc是单例的没有成员变量，把需要传递的参数放入方法中，请求这个方法时，会自动封装参数</li>
</ul>
<h2 id="默认参数绑定"><a href="#默认参数绑定" class="headerlink" title="默认参数绑定"></a>默认参数绑定</h2><ul>
<li><code>Request</code></li>
<li><code>Response</code></li>
<li><code>Session</code></li>
<li><code>Model</code></li>
<li><code>ModelMap</code></li>
</ul>
<h2 id="基本类型-amp-String"><a href="#基本类型-amp-String" class="headerlink" title="基本类型 &amp; String"></a>基本类型 &amp; String</h2><ol>
<li>请求参数名与方法形参一致</li>
<li>不一致<ul>
<li><code>@RequestParam(value=&quot;id&quot;,required=false,defaultValue=&quot;1&quot;)</code><ul>
<li><code>@RequestParam</code><ul>
<li>用于处理简单类型的绑定</li>
</ul>
</li>
<li>value<ul>
<li>绑定指定名称的请求参数</li>
</ul>
</li>
<li>required<ul>
<li>true<ul>
<li>默认，表示请求中一定要有相应的参数，否则报错</li>
</ul>
</li>
</ul>
</li>
<li>defaultValue<ul>
<li>表示请求中如果没有同名参数时的默认值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h2><ul>
<li>方法形参名称没什么用</li>
<li>方法形参的POJO类型中的字段与页面的name属性相同</li>
</ul>
<h3 id="springmvc确定pojo参数的过程"><a href="#springmvc确定pojo参数的过程" class="headerlink" title="springmvc确定pojo参数的过程"></a>springmvc确定pojo参数的过程</h3><ol>
<li>确定key<ul>
<li>pojo参数没有使用<code>@ModelAttribute</code>修饰，则key为pojo参数类名的首字母小写</li>
<li>pojo参数使用<code>@ModelAttributes(value=&quot;&quot;)</code>修饰，则key为注解value值</li>
</ul>
</li>
<li>在<code>impliciModel</code>中查找key对应的对象，存在则赋值给pojo参数</li>
<li><code>implicitModel</code>中不存在key，查看当前Handler是否是否使用了<code>@SessionAttributes</code><ol>
<li>使用了，且<code>@SessionAttributes(value={key})</code>，则从session中查找key，找到则赋值给pojo参数，找不到抛异常</li>
<li>没有使用，或<code>@SessionAttributes</code>的value中没有key，则反射创建pojo参数对应的对象，并赋值给pojo参数</li>
</ol>
</li>
<li>springmvc会把key和对应的value保存到<code>impliciModel</code>中，进而会保存到request中</li>
</ol>
<h2 id="POJO包装类"><a href="#POJO包装类" class="headerlink" title="POJO包装类"></a>POJO包装类</h2><ul>
<li>类似POJO类，多了一步导航</li>
<li>对于包装类中的POJO，表单name使用对象导航图<ul>
<li><code>name=&quot;user.name&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="自定义参数类型"><a href="#自定义参数类型" class="headerlink" title="自定义参数类型"></a>自定义参数类型</h2><h3 id="转换日期"><a href="#转换日期" class="headerlink" title="转换日期"></a>转换日期</h3><ol>
<li>创建自定义转换器，实现<code>Convertor&lt;S,T&gt;</code></li>
<li><p><code>springmvc.xml</code>将自定义转换器加入到转换器工厂<code>FormattingConversionServiceFactoryBean</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;转换器工厂id&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;converters&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;bean class=&quot;自定义转换器全类名&quot;/&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于参数绑定在适配器中，所以转换工厂配置在适配器上</p>
<ul>
<li><code>&lt;mvc:annotation-driven conversion-service=&quot;转换器工厂id&quot;/&gt;</code></li>
</ul>
</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>请求参数名与形参名一致即可<ul>
<li>如请求参数为ids则形参<code>Integer[] ids</code></li>
</ul>
</li>
<li>使用POJO包装类，持有数组类型的同名成员变量即可<ul>
<li>如请求参数为ids则POJO包装类中<code>private Integer[] ids</code></li>
</ul>
</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>简单类型的集合参数绑定，可以使用数组或者List来接收</li>
<li>pojo类型的集合参数绑定时，方法中不能直接传递集合类型参数，可以使用pojo包装类<ul>
<li>页面中使用对象导航视图<ul>
<li><code>name=&quot;userList[0].username&quot;</code></li>
<li>索引使用循环标签的状态索引<code>varStatus=&quot;vs&quot;</code><ul>
<li><code>vs.index</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="数据类型转换-amp-数据格式化-amp-数据校验"><a href="#数据类型转换-amp-数据格式化-amp-数据校验" class="headerlink" title="数据类型转换 &amp; 数据格式化 &amp; 数据校验"></a>数据类型转换 &amp; 数据格式化 &amp; 数据校验</h1><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ul>
<li>Spring MVC 上下文中内建了很多转换器可完成大多数 Java 类型 转换工作</li>
</ul>
<h3 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h3><h4 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h4><ul>
<li>Spring 类型转换体核心接口</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>Spring 定义了 3 种类型 转换器接口，实现任意一种，然后注册到<code>ConversionServiceFactroyBean</code> 中</li>
</ul>
<ol>
<li><code>Converter&lt;S,T&gt;</code><ul>
<li>S类型转为T类型 </li>
</ul>
</li>
<li><code>ConverterFactory</code><ul>
<li>将一 种类型 转换为另一种类型及其子类</li>
</ul>
</li>
<li><code>GenericConverter</code></li>
</ol>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven conversion-service=“自定义转换器”/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><h3 id="FormattingConversionService"><a href="#FormattingConversionService" class="headerlink" title="FormattingConversionService"></a>FormattingConversionService</h3><ul>
<li>既具有 类 型 转换功能又具有格式化功能</li>
</ul>
<h3 id="FormattingConversionServiceFactroyBean"><a href="#FormattingConversionServiceFactroyBean" class="headerlink" title="FormattingConversionServiceFactroyBean"></a>FormattingConversionServiceFactroyBean</h3><ul>
<li><code>&lt;mvc:annotation-driven/&gt;</code>默认创建的ConversionService实例即为此工厂bean</li>
<li><code>@DateTiemFormat</code></li>
<li><code>@NumberFormat</code></li>
</ul>
<h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><h3 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h3><ul>
<li>java为bean数据合法校验提供的标准框架，包含在javaee6.0中</li>
<li>通过在字段上加注解</li>
<li><code>@Null</code></li>
<li><code>@NotNull</code></li>
<li><code>@Pattern(value)</code></li>
<li><code>...</code></li>
</ul>
<h3 id="使用Hibernate的校验框架"><a href="#使用Hibernate的校验框架" class="headerlink" title="使用Hibernate的校验框架"></a>使用Hibernate的校验框架</h3><ul>
<li><code>Hibernate Validator</code>是jsr303的一个实现，有一些扩展</li>
</ul>
<h3 id="Spring的校验"><a href="#Spring的校验" class="headerlink" title="Spring的校验"></a>Spring的校验</h3><ul>
<li>Spring有自己的校验框架，同时支持jsr303</li>
</ul>
<h4 id="LocalValidatorFactoryBean"><a href="#LocalValidatorFactoryBean" class="headerlink" title="LocalValidatorFactoryBean"></a>LocalValidatorFactoryBean</h4><ul>
<li>实现了spring的<code>Validator</code>接口，也实现了jsr303的<code>Validator</code>接口</li>
<li><code>&lt;mvc:annotation-driver/&gt;</code>默认会装配好一个此对象</li>
</ul>
<h1 id="数据回显"><a href="#数据回显" class="headerlink" title="数据回显"></a>数据回显</h1><ol>
<li>默认回显<ul>
<li>springmvc会把pojo参数放入request域中，默认key为首字母小写</li>
</ul>
</li>
<li>使用<code>ModelAttribute</code>完成回显<ol>
<li>作用在参数上，表示将该对象放入request域中</li>
<li>作用在方法上，表示该方法在其它方法前执行<ol>
<li>使用<code>Map/Model...</code>参数存数据，会存入request域中</li>
<li>返回值会被存入reqeust域中</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="post提交乱码"><a href="#post提交乱码" class="headerlink" title="post提交乱码"></a>post提交乱码</h1><ul>
<li>在<code>web.xml</code>中配置过滤器，<code>spring-web</code>中<code>CharacterEncodingFilter</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="获取Servlet原生API"><a href="#获取Servlet原生API" class="headerlink" title="获取Servlet原生API"></a>获取Servlet原生API</h1><ul>
<li>想获取谁直接在方法上添加相应的形参即可获取。</li>
</ul>
<h2 id="默认支持的类型"><a href="#默认支持的类型" class="headerlink" title="默认支持的类型"></a>默认支持的类型</h2><ul>
<li><code>HttpServletRequest</code></li>
<li><code>HttpServletResponse</code></li>
<li><code>HttpSession</code></li>
<li><code>java.security.Principal</code></li>
<li><code>Locale</code></li>
<li><code>InputStream</code></li>
<li><code>OutputStream</code></li>
<li><code>Reader</code></li>
<li><code>Writer</code></li>
</ul>
<h1 id="文件上传-amp-下载"><a href="#文件上传-amp-下载" class="headerlink" title="文件上传 &amp; 下载"></a>文件上传 &amp; 下载</h1><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><ul>
<li>其实也是一种参数绑定(安)</li>
<li>使用的是MultipartResolver接口，实现使用的是<code>commons-fileupload</code></li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ol>
<li>form表单post请求，<code>enctype=multipart/form-data</code></li>
<li>配置MultipartResolver接口实现类<code>CommonsMultipartResolver</code><ul>
<li>bean id 必须为<code>multipartResolver</code></li>
<li>依赖<code>commons-fileupload和commons-io</code></li>
</ul>
</li>
<li>上传方法中形参<code>MultipartFile file</code><ul>
<li><code>file</code>为表单上传name属性名</li>
</ul>
</li>
<li>使用<code>MultipartFile</code>可以获取文件名，输入流，保存文件等等</li>
</ol>
<h3 id="MultipartFile"><a href="#MultipartFile" class="headerlink" title="MultipartFile"></a>MultipartFile</h3><ul>
<li><code>getOriginalFilename()</code></li>
<li><code>getInputStream()</code></li>
<li><code>void transferTo(File file)</code></li>
<li><code>default void transferTo(Path path)</code></li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="基于ResponseEntity实现"><a href="#基于ResponseEntity实现" class="headerlink" title="基于ResponseEntity实现"></a>基于ResponseEntity实现</h3><ul>
<li>返回一个<code>ResponseEntity</code></li>
</ul>
<h3 id="Java通用下载实现"><a href="#Java通用下载实现" class="headerlink" title="Java通用下载实现"></a>Java通用下载实现</h3><ul>
<li>设置响应头告诉浏览器是下载文件<ul>
<li><code>response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+fileName);</code></li>
</ul>
</li>
<li>设置响应头说明是文件类型<ul>
<li><code>response.setHeader(&quot;content-type&quot;, &quot;image/jpeg&quot;);</code><ul>
<li>设置文件类型是图片</li>
</ul>
</li>
<li><code>response.setContentType(this.getServletContext().getMimeType(fileName))</code><ul>
<li>设置类型为根据文件名获取的类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="处理响应数据"><a href="#处理响应数据" class="headerlink" title="处理响应数据"></a>处理响应数据</h1><h2 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h2><ul>
<li>Springmvc会把数据放入request域中，然后转发到页面。</li>
</ul>
<h3 id="获取Map容器"><a href="#获取Map容器" class="headerlink" title="获取Map容器"></a>获取Map容器</h3><ul>
<li><code>Map&lt;String, Object&gt; getModelInternal()</code></li>
<li><code>ModelMap getModelMap()</code></li>
<li><code>Map&lt;String, Object&gt; getModel()</code><ul>
<li>三个方法用处一样</li>
</ul>
</li>
</ul>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul>
<li><code>ModelAndView addObject(String attributeName, Object attributeValue)</code></li>
<li><code>ModelAndView addAllObjects(Map&lt;String, ?&gt; modelMap)</code></li>
</ul>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul>
<li><code>void setViewName(String viewName)</code></li>
<li><code>void setView(View view)</code></li>
</ul>
<h2 id="Map-Model"><a href="#Map-Model" class="headerlink" title="Map/Model"></a>Map/Model</h2><ul>
<li>Springmvc不管返回值是什么，都会封装成一个ModelAndView返回，且把数据放入reqeust域中</li>
</ul>
<h3 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h3><ul>
<li><code>Map</code><ul>
<li><code>ModelMap</code><ul>
<li><code>ExtendedModelMap</code><ul>
<li>BindingAwareModelMap</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Model</code><ul>
<li><code>ExtendedModelMap</code><ul>
<li>BindingAwareModelMap</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>Springmvc为我们创建的Map类型为BindingAwareModelMap</li>
</ul>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul>
<li>Springmvc为我们创建的Model类型为BindingAwareModelMap</li>
<li><code>Model addAttribute(String attributeName, Object attributeValue)</code></li>
<li><code>Model addAllAttributes(Map&lt;String, ?&gt; attributes)</code></li>
</ul>
<h1 id="视图-1"><a href="#视图-1" class="headerlink" title="视图"></a>视图</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul>
<li>不论控制器返回<code>String/View/ModelAndView</code>，都会转换成<code>ModelAndView</code>对象</li>
<li>Springmvc借助视图解析器（ViewResolver）得到最终视图对象（View）<ul>
<li>最终的视图可以是<code>jsp/excel/jfreeChart/...</code></li>
</ul>
</li>
</ul>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ul>
<li>视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户,主要就是完成转发或者是重定向的操作</li>
<li>视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li><code>String getContentType()</code></li>
<li><code>void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</code></li>
</ul>
<h3 id="常用视图实现类"><a href="#常用视图实现类" class="headerlink" title="常用视图实现类"></a>常用视图实现类</h3><h4 id="InternalResourceView"><a href="#InternalResourceView" class="headerlink" title="InternalResourceView"></a>InternalResourceView</h4><h4 id="JstlView"><a href="#JstlView" class="headerlink" title="JstlView"></a>JstlView</h4><ul>
<li><code>JstlView extends InternalResourceView</code></li>
<li>若项目中使用了JSTL，则SpringMVC 会自动把视图由InternalResourceView转为 JstlView</li>
</ul>
<h4 id="AbstractExcelView"><a href="#AbstractExcelView" class="headerlink" title="AbstractExcelView"></a>AbstractExcelView</h4><h2 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><ul>
<li>SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring WEB 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类<ul>
<li><code>order</code><ul>
<li><code>&lt;property name=&quot;order&quot; value&quot;默认为int最大值&quot; /&gt;</code></li>
<li>值越小，优先级越高</li>
</ul>
</li>
</ul>
</li>
<li>视图解析器的作用：将逻辑视图解析为一个具体的视图对象。</li>
<li>所有的视图解析器都必须实现 ViewResolver 接口：</li>
</ul>
<h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><ul>
<li><code>View resolveViewName(String viewName, Locale locale)</code></li>
</ul>
<h3 id="常用视图解析器"><a href="#常用视图解析器" class="headerlink" title="常用视图解析器"></a>常用视图解析器</h3><ul>
<li><code>InternalResourceViewResolver</code></li>
<li><code>BeanNameViewResolver</code></li>
</ul>
<h2 id="lt-mvc-view-controller-gt"><a href="#lt-mvc-view-controller-gt" class="headerlink" title="&lt;mvc:view-controller&gt;"></a><code>&lt;mvc:view-controller&gt;</code></h2><ul>
<li><code>&lt;mvc:view-controller path=&quot;&quot; view-name=&quot;&quot;/&gt;</code><ul>
<li>直接响应通过 SpringMVC 渲染的页面：无需经过控制器来执行结果，直接跳转页面。</li>
<li><code>path</code><ul>
<li>请求路径</li>
</ul>
</li>
<li><code>view-name</code><ul>
<li>直接配置响应的页面</li>
</ul>
</li>
</ul>
</li>
<li>此配置会导致其它请求路径失效<ul>
<li><code>&lt;mvc:annotation-driven/&gt;</code>可以解决。</li>
</ul>
</li>
</ul>
<h2 id="控制器返回值"><a href="#控制器返回值" class="headerlink" title="控制器返回值"></a>控制器返回值</h2><h3 id="ModelAndView-1"><a href="#ModelAndView-1" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>返回逻辑视图名，通过视图解析器解析物理视图</li>
<li>转发<ul>
<li><code>forward:转发的路径</code></li>
</ul>
</li>
<li>重定向<ul>
<li><code>redirect:重定向的路径</code></li>
</ul>
</li>
</ul>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><ul>
<li>默认跳转页面为注解<code>@RequestMapping(value=&quot;&quot;)</code>value属性的值<code>.jsp</code>，会找不到页面<ol>
<li>使用Servlet的api在方法内转发或者重定向到指定页面</li>
<li>如果是异步请求，则直接使用流响应即可。</li>
</ol>
</li>
</ul>
<h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><h2 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h2><ol>
<li>dao，service，controller出现异常都往上抛，最后抛给DispatcherServlet</li>
<li>DispatcherServlet<ul>
<li>有异常处理器，则交给异常处理器</li>
<li>无异常处理器，则什么都不做直接响应到页面</li>
</ul>
</li>
</ol>
<h2 id="springmvc的异常处理"><a href="#springmvc的异常处理" class="headerlink" title="springmvc的异常处理"></a>springmvc的异常处理</h2><h3 id="HandlerException"><a href="#HandlerException" class="headerlink" title="HandlerException"></a>HandlerException</h3><ul>
<li>顶级接口，有内置实现类</li>
</ul>
<h4 id="ExceptionHandlerExcptionResolver"><a href="#ExceptionHandlerExcptionResolver" class="headerlink" title="ExceptionHandlerExcptionResolver"></a>ExceptionHandlerExcptionResolver</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(&#123;异常类.class数组&#125;)</span><br><span class="line">public ModelAndView test(Exception e)&#123;</span><br><span class="line">	ModelAndView mv = new ModelAndView();</span><br><span class="line">	mv.addObject(&quot;exception&quot;,e);</span><br><span class="line">	mv.setViewName(&quot;错误页面，如error);</span><br><span class="line">	return mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在handler中使用一个无关方法，在其上使用<code>@ExceptionHandler</code><ul>
<li>只对当前handler有效</li>
</ul>
</li>
<li><code>@ControllerAdvice</code><ul>
<li>定义在类上</li>
<li>如果某个handler中没有<code>@ExceptionHanler</code>，它还会找有<code>@ControllerAdvice</code>注解的类中的<code>@ExceptionHandler</code></li>
</ul>
</li>
<li>只能用ModelAndView将异常带到页面，如果方法返回String，使用<code>Map/Model</code>不能将异常带到页面</li>
</ul>
<h4 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h4><ul>
<li><code>@ResponseStatues</code><ul>
<li>定义在自定义异常类上 或 定义在方法上</li>
<li>属性<ul>
<li><code>value</code><ul>
<li>状态码</li>
</ul>
</li>
<li><code>reason</code><ul>
<li>错误信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h4><ul>
<li>对一些特定异常进行处理</li>
</ul>
<h4 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h4><ul>
<li>为每个异常指定特定页面，会自动将异常存入request域默认key为<code>exception</code>，也可以自定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;SimpleMappingExceptionResolver&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;exceptionAttribute&quot; value=&quot;自定义request域的key&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;exceptionMappings&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;java.lang.NullPointException&quot;&gt;error1&lt;/prop&gt;</span><br><span class="line">			&lt;prop key=&quot;java.lang.IndexOutOfBoundsException&quot;&gt;error2&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h3><ol>
<li>使用自定义异常类 或 已有异常类<ul>
<li>用于设置异常信息</li>
</ul>
</li>
<li>异常处理器<ol>
<li>使用内置异常处理器<ul>
<li>内置异常处理器有相应注解来实现携带异常信息跳到特定页面等</li>
</ul>
</li>
<li>自定义异常处理器<ol>
<li>实现<code>HandlerExceptionResoler</code><ul>
<li>在自定义处理器中携带异常信息跳到特定页面</li>
</ul>
</li>
<li>在<code>springmvc.xml</code>中配置异常处理器bean</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="拦截器-amp-过滤器"><a href="#拦截器-amp-过滤器" class="headerlink" title="拦截器 &amp; 过滤器"></a>拦截器 &amp; 过滤器</h2><ol>
<li>过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。</li>
<li>拦截器是SpringMVC框架独有的。</li>
<li>过滤器配置了/*，可以拦截任何资源。</li>
<li>拦截器只会对Controller中的方法进行拦截</li>
</ol>
<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><ol>
<li>实现<code>HandlerInterceptor</code> 或 继承<code>HandlerInterceptorAdapter</code></li>
<li>在springmvc.xml中配置拦截器类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置拦截器 如果配置多个，每个一个&lt;mvc:interceptor&gt;--&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">	&lt;!-- 注册拦截器对象（两种方式-） 对所有有效 -&gt;</span><br><span class="line">	1 &lt;bean class=&quot;自定义拦截器全类名&quot;/&gt; </span><br><span class="line">	2 &lt;ref bean=&quot;bean的id&quot;/&gt;</span><br><span class="line">	&lt;mvc:interceptor&gt;</span><br><span class="line">		&lt;!-- 哪些方法进行拦截 --&gt;</span><br><span class="line">		&lt;mvc:mapping path=&quot;/user/*&quot;/&gt;</span><br><span class="line">		&lt;!-- 哪些方法不进行拦截</span><br><span class="line">		&lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span><br><span class="line">		--&gt;</span><br><span class="line">		&lt;!-- 注册拦截器对象 只对当前有效 --&gt;</span><br><span class="line">		&lt;bean class=&quot;自定义拦截器全类名&quot;/&gt;</span><br><span class="line">	&lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h2><ul>
<li><code>preHandler()</code><ul>
<li>controller方法执行前执行</li>
<li>可以使用request或者response跳转到指定的页面</li>
<li>return true <ul>
<li>放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法</li>
</ul>
</li>
<li>return false<ul>
<li>不放行，不会执行controller中的方法</li>
</ul>
</li>
</ul>
</li>
<li><code>postHandler()</code><ul>
<li>controller方法执行后，渲染视图前执行</li>
<li>可以使用request或者response跳转到指定的页面</li>
<li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示</li>
</ul>
</li>
<li><code>afterCompletion</code><ol>
<li>渲染视图后执行</li>
<li>当某个拦截器<code>preHandle</code>返回false，也会执行之前已经返回true的拦截器的<code>afterCompletion</code></li>
<li>当DispatcherServlet的doDispath方法抛出异常，也可能执行。</li>
</ol>
</li>
</ul>
<h2 id="多个拦截器执行顺序"><a href="#多个拦截器执行顺序" class="headerlink" title="多个拦截器执行顺序"></a>多个拦截器执行顺序</h2><ul>
<li>按照配置顺序排序</li>
<li><code>pre1 pre2 pre3 handler post3 post2 post1 after3 after2 after1</code></li>
</ul>
<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">增: /user POST</span><br><span class="line">删: /user/1 DELETE</span><br><span class="line">改: /user/1 PUT</span><br><span class="line">查: /user/1 GET</span><br></pre></td></tr></table></figure>
<h2 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a>HiddenHttpMethodFilter</h2><ul>
<li>发送一个隐藏域<code>name=&quot;_method&quot; value=&quot;put/delete/...&quot;</code></li>
<li>可以将Post请求转换成<code>_method</code>指定的请求</li>
</ul>
<h1 id="SpringMvc的表单标签"><a href="#SpringMvc的表单标签" class="headerlink" title="SpringMvc的表单标签"></a>SpringMvc的表单标签</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><ul>
<li>通过 SpringMVC 的表单标签可以实现将模型数据中的属性和 HTML 表单元素相绑定，以实现表单数据更便捷编辑和表单值的回显</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><code>&lt;%@taglib uri=&quot;http://www.springframework.org/tags/form&quot;</code></li>
</ul>
<h2 id="lt-form-gt"><a href="#lt-form-gt" class="headerlink" title="&lt;form&gt;"></a><code>&lt;form&gt;</code></h2><ul>
<li>一般情况下，通过 GET 请求获取表单页面，而通过 POST 请求提交表单页面，因此获取表单页面和提交表单页面的 URL 是相同的。</li>
<li>只要满足该最佳条件的契约，<code>&lt;form:form&gt;</code> 标签就无需通过 action 属性指定表单提交的 URL</li>
<li><code>&lt;form:form action=&quot;&quot; method=&quot;&quot; modelAtribute=&quot;&quot;&gt;</code><ul>
<li><code>modelAtribute</code><ul>
<li>使用了springmvc的form表单标签，必须要进行数据回显</li>
<li>默认会使用<code>key=&quot;command&quot;</code>到request域中查找回显的数据，如果找不到，会抛出异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h2><ul>
<li><code>&lt;form:input path=&quot;&quot; htmlEscape=&quot;&quot; cssClass=&quot;&quot; cssErrorClass=&quot;&quot;&gt;</code><ul>
<li><code>path</code><ul>
<li>表单字段，对应 html 元素的 name 属性，支持级联属性</li>
</ul>
</li>
<li><code>htmlEscape</code><ul>
<li>是否对表单值的 HTML 特殊字符进行转换，默认值为 true</li>
</ul>
</li>
<li><code>cssClass</code><ul>
<li>表单组件对应的 CSS 样式类名</li>
</ul>
</li>
<li><code>cssErrorClass</code><ul>
<li>表单组件的数据存在错误时，采取的 CSS 样式</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;form:password&gt;</code></li>
<li><code>&lt;form:hidden&gt;</code></li>
<li><code>&lt;form:textarea&gt;</code></li>
<li><code>&lt;form:radiobutton&gt;</code><ul>
<li>一个单选框</li>
<li>当表单 bean 对应的属性值和 value 值相等时，单选框被选中</li>
</ul>
</li>
<li><code>&lt;form:radiobuttons items=&quot;&quot; itemValue=&quot;&quot; itemLabel=&quot;&quot; delimiter=&quot;&quot;&gt;</code><ul>
<li><code>items</code><ul>
<li>可以是一个 List、String[] 或 Map</li>
</ul>
</li>
<li><code>itemValue</code><ul>
<li>指定 radio 的 value 值。可以是集合中 bean 的一个属性值</li>
</ul>
</li>
<li><code>itemLabel</code><ul>
<li>指定 radio 的 label 值，显示值</li>
</ul>
</li>
<li><code>delimiter</code><ul>
<li>多个单选框可以通过 delimiter 指定分隔符</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;form:checkbox&gt;</code></li>
<li><code>&lt;form:checkboxs&gt;</code></li>
<li><code>&lt;form:select&gt;</code></li>
<li><code>&lt;form:option&gt;</code></li>
<li><code>form:errors path=&quot;&quot;&gt;</code><ul>
<li><code>path=&quot;*&quot;</code><ul>
<li>显示表单所有的错误</li>
</ul>
</li>
<li><code>path=&quot;user*&quot;</code><ul>
<li>显示所有以 user 为前缀的属性对应的错误</li>
</ul>
</li>
<li><code>path=&quot;username&quot;</code><ul>
<li>显示特定表单对象属性的错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><img src="https://gitee.com/3noanswer/pics/raw/master/frame/springmvc-json原理.png" alt=""></p>
<h3 id="HttpMessageConverter-lt-T-gt"><a href="#HttpMessageConverter-lt-T-gt" class="headerlink" title="HttpMessageConverter&lt;T&gt;"></a><code>HttpMessageConverter&lt;T&gt;</code></h3><ul>
<li>Spring3.0 新添加一个接口 </li>
<li>负责将请求信息转换为T类型 或 将T类型输出为响应信息</li>
<li>实现下载<ul>
<li><code>@ResponseEntiey</code></li>
<li><code>@ResponseBody</code></li>
<li><code>HttpEntity</code></li>
<li><code>ResponseEntity</code></li>
<li>将要下载的文件数据以及响应信息封装到<code>ResponseEntity</code>对象中，浏览器解析数据，即可下载。</li>
</ul>
</li>
</ul>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><ul>
<li>springmvc依赖jsckson实现</li>
<li><code>@ResponseBody</code><ul>
<li>将方法的返回值转换成json字符串，响应给浏览器</li>
</ul>
</li>
<li><p><code>@RequestBody</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;reqJson&quot;)</span><br><span class="line">public @ResponseBody User reqJson(@RequestBody User user) &#123;</span><br><span class="line">	System.out.println(user);</span><br><span class="line">return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@RequestBody接受前台json数据，把json数据自动封装javaBean</li>
<li>@ResponseBody把后台pojo转换json对象，返回到页面</li>
<li>这两个注解依赖Jackson的jar包<br><code>`</code></li>
</ul>
</li>
</ul>
<h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>在页面根据浏览器设置的语言，对文本，时间，数值进行本地化</li>
<li>在类中获取国际化资源文件Locale对应的信息</li>
<li>通过超链接切换Locale，而不再依赖浏览器语言设置</li>
</ol>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><ol>
<li>使用JSTL的<code>fmt</code>标签</li>
<li>在类中注入<code>ResourceBundleMessageSource</code>，使用<code>getMessage()</code>获取</li>
<li>配置<code>LocalResolver</code>和<code>LocaleChangeInterceptor</code></li>
</ol>
<h1 id="Springmvc的freemarker支持"><a href="#Springmvc的freemarker支持" class="headerlink" title="Springmvc的freemarker支持"></a>Springmvc的freemarker支持</h1><h1 id="Spring-amp-SpringMVC"><a href="#Spring-amp-SpringMVC" class="headerlink" title="Spring &amp; SpringMVC"></a>Spring &amp; SpringMVC</h1><h2 id="不整合"><a href="#不整合" class="headerlink" title="不整合"></a>不整合</h2><ul>
<li>都放在 SpringMVC 的配置文件中. 也可以分多个 Spring 的配置文件, 然后使用 import 节点导入其他的配置文件</li>
</ul>
<h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><ul>
<li>通常情况下, 类似于数据源, 事务, 整合其他框架，还有Service/dao…都是放在 Spring 的配置文件中(而不是放在 SpringMVC 的配置文件中).</li>
</ul>
<h1 id="SpringMVc与Struts2的区别"><a href="#SpringMVc与Struts2的区别" class="headerlink" title="SpringMVc与Struts2的区别"></a>SpringMVc与Struts2的区别</h1><ol>
<li><ul>
<li>sm入口是servlet</li>
<li>s2是filter</li>
</ul>
</li>
<li><ul>
<li>sm是基于方法开发（一个url对应一个方法），可以是单例也可以是多例（推荐单例）</li>
<li>s2是基于类开发，只能为多例<ul>
<li>单例是以方法为单位</li>
<li>多例是以类为单位</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>sm的参数是绑定在方法形参上</li>
<li>s2的参数绑定在成员变量上</li>
</ul>
</li>
<li><ul>
<li>sm通过参数解析器将request请求内容解析，绑定到方法形参后，将数据和视图封装成ModelAndView对象，最后将ModelAndView中的模型数据通过request域传输到页面</li>
<li>s2采用值栈存储请求和响应数据，通过OGNL存取数据</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Hibernate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Hibernate/" itemprop="url">
                  xd-Hibernate
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:39:59" itemprop="dateCreated datePublished" datetime="2018-12-11T00:39:59+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:45:39" itemprop="dateModified" datetime="2019-03-08T14:45:39+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Struts2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Struts2/" itemprop="url">
                  xd-Struts2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:39:49" itemprop="dateCreated datePublished" datetime="2018-12-11T00:39:49+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-08 14:45:19" itemprop="dateModified" datetime="2019-03-08T14:45:19+08:00">2019-03-08</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png"
                alt="安₃" />
            
              <p class="site-author-name" itemprop="name">安₃</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">62</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安₃</span>

  

  
</div>



<!--





-->





        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  


<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
