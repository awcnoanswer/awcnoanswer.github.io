<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="安₃">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="安₃">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安₃">






  <link rel="canonical" href="http://yoursite.com/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>安₃</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<!--github start-->
	<a href="https://github.com/awcnoanswer" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	<!--github end-->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安₃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/xd-Filter和Listener/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/xd-Filter和Listener/" itemprop="url">
                  xd-Filter和Listener
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-03 14:53:38 / 修改时间：15:22:13" itemprop="dateCreated datePublished" datetime="2019-01-03T14:53:38+08:00">2019-01-03</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="监听器-Listener"><a href="#监听器-Listener" class="headerlink" title="监听器(Listener)"></a>监听器(Listener)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>web的三大组件之一。</li>
<li>用于监听web常见对象的创建销毁,属性变化</li>
<li>监听域对象HttpRequest HttpSession ServletContext</li>
</ul>
<h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><ul>
<li>事件    ：一件事情</li>
<li>事件源 ：事件发生的地方</li>
<li>监听器 ：用于监听指定的事件的对象</li>
<li>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</li>
</ul>
<h2 id="常见监听器"><a href="#常见监听器" class="headerlink" title="常见监听器"></a>常见监听器</h2><h3 id="监听域对象的创建与销毁"><a href="#监听域对象的创建与销毁" class="headerlink" title="监听域对象的创建与销毁"></a>监听域对象的创建与销毁</h3><ul>
<li><code>HttpSessionListener</code><ul>
<li>监听HttpSession创建与销毁</li>
</ul>
</li>
<li><code>ServletRequestListener</code><ul>
<li>监听HttpServletRequest创建与销毁</li>
</ul>
</li>
<li><code>ServletContextListener</code><ul>
<li>监听ServletContext创建与销毁</li>
</ul>
</li>
</ul>
<h3 id="监听域对象的属性变化"><a href="#监听域对象的属性变化" class="headerlink" title="监听域对象的属性变化"></a>监听域对象的属性变化</h3><ul>
<li><code>HttpSessionAttributeListener</code><ul>
<li>监听HttpSession属性变化</li>
</ul>
</li>
<li><code>ServletRequestAttributeListener</code><ul>
<li>监听HttpServletRequest属性变化</li>
</ul>
</li>
<li><code>ServletContextAttributeListener</code><ul>
<li>监听ServletContext属性变化</li>
</ul>
</li>
</ul>
<h3 id="监听session绑定javaBean"><a href="#监听session绑定javaBean" class="headerlink" title="监听session绑定javaBean"></a>监听session绑定javaBean</h3><ul>
<li>此种监听器不用配置注册</li>
<li>要用对象实现此种监听器</li>
<li><code>HttpSessionBindingListener</code><ul>
<li>监听javaBean对象是否绑定到了session域</li>
<li>绑定<ul>
<li>一个对象放到session域中</li>
</ul>
</li>
<li>解绑<ul>
<li>对象从session域中移除</li>
</ul>
</li>
</ul>
</li>
<li><code>HttpSessionActivationListener</code><ul>
<li>监听javaBean对象的活化与钝化</li>
<li>钝化<ul>
<li>session内存中的对象持久化（序列化）到磁盘</li>
<li>服务器关闭了，session中的数据序列化一个文件。(安)</li>
</ul>
</li>
<li>活化<ul>
<li>将磁盘的对象再次恢复到session内存中</li>
<li>服务器开启，通过文件恢复session数据。(安)</li>
<li>注意钝化活化的对象要实现serializable接口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>void contextDestroyed(ServletContextEvent sce)</code> <ul>
<li>ServletContext对象被销毁之前会调用该方法</li>
</ul>
</li>
<li><code>void contextInitialized(ServletContextEvent sce)</code> <ul>
<li>ServletContext对象创建后会调用该方法</li>
</ul>
</li>
</ul>
<h4 id="获取被监听的对象"><a href="#获取被监听的对象" class="headerlink" title="获取被监听的对象"></a>获取被监听的对象</h4><ul>
<li>方法中的参数(ServletContextEvent sce)可以获取被监听的对象</li>
</ul>
<ol>
<li><code>ServletContext sc = sce.getServletContext()</code></li>
<li><code>Object obj = sce.getSource();</code><ul>
<li>这个是通用的获取被监听的对象的方法，可以强转</li>
<li><code>ServletContext sc = (ServletContext)sce.getSource();</code></li>
</ul>
</li>
</ol>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>初始化工作<ul>
<li>初始化对象，数据，加载数据库驱动，连接池的初始化</li>
</ul>
</li>
<li>加载初始化配置文件<ul>
<li>如spring的配置文件</li>
<li>spring的核心监听器就是实现了ServletContextListener</li>
</ul>
</li>
<li>任务调度<ul>
<li>定时器 Timer/TimerTask</li>
</ul>
</li>
</ul>
<h2 id="创建监听器"><a href="#创建监听器" class="headerlink" title="创建监听器"></a>创建监听器</h2><ul>
<li>创建类实现指定监听器接口</li>
<li>实现接口方法</li>
<li>配置<ol>
<li>在web.xml中对监听器进行注册<code>&lt;listener&gt;</code></li>
<li>注解<code>@WebListener</code></li>
</ol>
</li>
</ul>
<h1 id="过滤器-Filter"><a href="#过滤器-Filter" class="headerlink" title="过滤器(Filter)"></a>过滤器(Filter)</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>可以过滤所有访问web资源的请求或响应操作</li>
<li>作用<ul>
<li>一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…</li>
</ul>
</li>
</ul>
<h2 id="创建过滤器"><a href="#创建过滤器" class="headerlink" title="创建过滤器"></a>创建过滤器</h2><ul>
<li>创建类实现Filter接口</li>
<li>实现接口方法</li>
<li>配置<ol>
<li>在web.xml中配置<code>&lt;filter&gt;</code> <code>&lt;filter-mapping&gt;</code></li>
<li>注解<code>@WebFilter</code></li>
</ol>
</li>
</ul>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li><code>init(FilterConfig config)</code><ul>
<li>服务器启动，创建Filter对象，只调用一次</li>
</ul>
</li>
<li><code>doFilter(req,res,chain)</code><ul>
<li>每次访问调用2次</li>
<li>每次访问前后都会调用一次。</li>
</ul>
</li>
<li><code>destroy()</code><ul>
<li>服务器正常关闭，Filter对象被销毁，调用一次</li>
</ul>
</li>
</ul>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol>
<li>过滤器链正序执行，放行前的代码</li>
<li>放行<ul>
<li><code>chain.doFilter(req,res);</code></li>
</ul>
</li>
<li>过滤器链倒叙执行放行后的代码</li>
</ol>
<h3 id="过滤器链执行顺序"><a href="#过滤器链执行顺序" class="headerlink" title="过滤器链执行顺序"></a>过滤器链执行顺序</h3><ol>
<li><code>web.xml</code><ul>
<li>由<code>&lt;filter-mapping&gt;</code>顺序确定</li>
</ul>
</li>
<li>注解<ul>
<li>按照类名的字符串比较规则比较，值小的先执行</li>
</ul>
</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><code>web.xml</code></h4><h5 id="lt-url-pattern-gt"><a href="#lt-url-pattern-gt" class="headerlink" title="&lt;url-pattern&gt;"></a><code>&lt;url-pattern&gt;</code></h5><ul>
<li><code>/xxx</code></li>
<li><code>/xxx/*</code></li>
<li><code>/*</code></li>
<li><code>*.do</code></li>
</ul>
<h5 id="lt-dispatcher-gt"><a href="#lt-dispatcher-gt" class="headerlink" title="&lt;dispatcher&gt;"></a><code>&lt;dispatcher&gt;</code></h5><ul>
<li>拦截指定跳转方式</li>
<li>当以什么方式去访问web资源时，进行拦截操作.</li>
<li><code>REQUEST</code>  <ul>
<li>当是从浏览器直接访问资源，或是重定向到某个资源时进行拦截方式配置的 默认值</li>
</ul>
</li>
<li><code>FORWARD</code><ul>
<li>请求转发的拦截方式配置</li>
</ul>
</li>
<li><code>ERROR</code><ul>
<li>如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用</li>
</ul>
</li>
<li><code>INCLUDE</code><ul>
<li>如果目标资源是通过<code>RequestDispatcher的include()</code>方法访问时，那么该过滤器将被调用</li>
</ul>
</li>
<li><code>ASYNC</code><ul>
<li>异步访问资源</li>
</ul>
</li>
</ul>
<h3 id="FilterConfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h3><ul>
<li><code>String getFilterName()</code></li>
<li><code>String getInitParameter(String name)</code></li>
<li><code>Enumeration getInitParameterNames()</code>    </li>
<li><code>ServletContext getServletContext()</code><ul>
<li>获取ServletContext</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/xd-会话/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/xd-会话/" itemprop="url">
                  xd-会话
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-28 01:30:11 / 修改时间：16:10:15" itemprop="dateCreated datePublished" datetime="2018-12-28T01:30:11+08:00">2018-12-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><h2 id="一次会话"><a href="#一次会话" class="headerlink" title="一次会话"></a>一次会话</h2><ul>
<li>浏览器第一次给服务器发送请求，会话建立，直到有一方断开为止。</li>
<li>包含多次请求和响应</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>在一次会话范围共享数据</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><code>Cookie</code></li>
<li><code>Session</code> </li>
</ul>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>客户端技术<ul>
<li>Cookie是由客户端保存和携带的。</li>
<li>只能存储字符串</li>
</ul>
</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>基于响应头<code>set-cookie</code>和请求头<code>cookie</code>实现</li>
<li>程序把每个用户的数据以cookie形式响应给用户各自的浏览器，存在本地。当用户再次请求访问服务器的web资源时，就会带着各自的(cookie)去。如此，web资源处理的就是用户各自的数据。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>创建Cookie(在服务端)<ul>
<li><code>Cookie cookie=new Cookie(String name,String value,[String path])</code><ul>
<li><code>path</code><ul>
<li>默认是创建cookie的应用的虚拟目录。</li>
<li>可以指定<ol>
<li>构造时指定path</li>
<li><code>cookie.setPath()</code></li>
</ol>
</li>
<li>只有以cookie的path开头的访问路径才会携带cookie。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>响应Cookie到客户端<ul>
<li><code>response.addCookie(Cookie c)</code><ul>
<li>响应头<code>set-Cookie</code></li>
</ul>
</li>
</ul>
</li>
<li>再次请求时获取Cookie<ul>
<li><code>Cookie[] cs=request.getCookies()</code><ul>
<li>获取cookie列表。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="一次可不可以发送多个Cookie"><a href="#一次可不可以发送多个Cookie" class="headerlink" title="一次可不可以发送多个Cookie"></a>一次可不可以发送多个Cookie</h3><ul>
<li>可以</li>
<li>创建多个Cookie对象，使用response调用多次<code>addCookie()</code>即可</li>
</ul>
<h3 id="Cookie的存活时间"><a href="#Cookie的存活时间" class="headerlink" title="Cookie的存活时间"></a>Cookie的存活时间</h3><ul>
<li><code>void setMaxAge(int time)</code><ul>
<li><code>time</code><ul>
<li>负数<ul>
<li>默认</li>
<li>默认cookie是会话级别的，即浏览器一关闭就会消失</li>
</ul>
</li>
<li>正数<ul>
<li>持久化存储，存活时间</li>
</ul>
</li>
<li>0<ul>
<li>删除Cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Cookie能否存中文"><a href="#Cookie能否存中文" class="headerlink" title="Cookie能否存中文"></a>Cookie能否存中文</h3><ul>
<li>tomcat8之前<ul>
<li>不可以</li>
<li>需要将中文转码，一般采用URL编码(%16进制)</li>
</ul>
</li>
<li>tomcat8之后，Cookie支持中文<ul>
<li>但是不支持特殊字符，建议使用URL编解码<ul>
<li>URL编码后会变成<code>%E7</code>这种形式的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h4><ul>
<li><code>URLEncoder</code><ul>
<li><code>encode(String s, String character)</code><ul>
<li>编码</li>
</ul>
</li>
<li><code>decode(String s, String character)</code><ul>
<li>解码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Cookie共享问题"><a href="#Cookie共享问题" class="headerlink" title="Cookie共享问题"></a>Cookie共享问题</h3><ol>
<li>同一个服务器下的多个we项目<ul>
<li>因为默认path是创建cookie的项目的虚拟目录，其它web项目是访问不到的。</li>
<li>即默认不能共享</li>
<li>共享<ul>
<li><code>setPath(&quot;/&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li>不同服务器间的共享<ul>
<li><code>setDomain(String path)</code><ul>
<li>如果设置一级域名相同，那么多个服务区间的Cookie可以共享</li>
<li><code>setDomain(&quot;.baidu.com&quot;)</code><ul>
<li>则<code>tieba.baidu.com</code>和<code>news.baidu.com</code>…之间就可以共享</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>服务端技术，session依赖于cookie<ul>
<li>可以存储任意对象</li>
</ul>
</li>
<li>在一次会话的多次请求间共享数据，将数据保存在服务端的对象种</li>
</ul>
<h2 id="获取Session"><a href="#获取Session" class="headerlink" title="获取Session"></a>获取Session</h2><ul>
<li><code>HttpSession session = request.getSession()</code><ul>
<li>若session不存在则创建，存在则获取</li>
</ul>
</li>
</ul>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><ul>
<li>第一次访问会创建session并分配<code>JSessionID</code></li>
<li>响应到客户端,并以cookie形式存储</li>
<li>以后访问会带着这个cookie<ul>
<li>若有此cookie则可以获取session</li>
<li>若无此cookie则视为第一次访问，循环…。</li>
</ul>
</li>
</ul>
<h2 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h2><ul>
<li><code>String getId()</code><ul>
<li>获取session的JSessionID</li>
</ul>
</li>
<li><code>setMaxInactiveInterval(int interval)</code><ul>
<li>设置session存活时间，默认30分</li>
</ul>
</li>
<li><code>invalidate()</code><ul>
<li>销毁session </li>
</ul>
</li>
</ul>
<h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h2><h3 id="客户端关闭，服务器不关闭，两次获取的session是否是同一个"><a href="#客户端关闭，服务器不关闭，两次获取的session是否是同一个" class="headerlink" title="客户端关闭，服务器不关闭，两次获取的session是否是同一个"></a>客户端关闭，服务器不关闭，两次获取的session是否是同一个</h3><ul>
<li>默认情况下，不是<ul>
<li>因为虽然session默认存活30分钟，但是session是以cookie的形式保存在客户端的，而cookie默认客户端已关闭就会消失。</li>
</ul>
</li>
<li>若想获取同一个<ul>
<li>可以创建Cookie，键为<code>JSessionID</code>，并设置存活时间</li>
</ul>
</li>
</ul>
<h3 id="客户端不关闭，服务器关闭，两次获取的session是否是同一个"><a href="#客户端不关闭，服务器关闭，两次获取的session是否是同一个" class="headerlink" title="客户端不关闭，服务器关闭，两次获取的session是否是同一个"></a>客户端不关闭，服务器关闭，两次获取的session是否是同一个</h3><ul>
<li>不是<ul>
<li>因为对象的地址值是有随机性的，服务器重启会重新创建。两次创建很难一样。</li>
</ul>
</li>
<li>对象虽然不是同一个，但需要保证数据不丢失<ul>
<li>使用<strong>Session的钝化和活化</strong></li>
<li>在服务器关闭时将session钝化，服务器再次开启时将session活化</li>
<li>注<ul>
<li>dos命令下，正常关闭tomcat，tomcat会自动钝化session，在<code>work</code>目录下生成<code>Session.ser</code>文件，再次启动，会活化。</li>
<li>idea中，idea使用虚拟目录方式部署应用，在idea中关闭tomcat时，也会钝化，但是再次启动时，idea会先删除<code>work</code>目录，钝化的文件被删除了，也就无法活化了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Session的销毁"><a href="#Session的销毁" class="headerlink" title="Session的销毁"></a>Session的销毁</h3><ol>
<li>服务器关闭</li>
<li>调用<code>invalidate()</code></li>
<li>tomcat的<code>/conf/web.xml</code>中的默认配置<code>&lt;session-config&gt;</code><ul>
<li>默认是30分钟，可以自己修改</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/xd-工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/xd-工具/" itemprop="url">
                  xd-工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-28 00:44:53 / 修改时间：00:51:00" itemprop="dateCreated datePublished" datetime="2018-12-28T00:44:53+08:00">2018-12-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>在<code>commons-lang3.jar</code>中</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>boolean isEmpty(String s)</code><ul>
<li>判断字符串是否为空，不会去除字符串空格。</li>
<li><code>String s=null</code><ul>
<li>true</li>
</ul>
</li>
<li><code>String s=&quot;&quot;</code><ul>
<li>true</li>
</ul>
</li>
<li><code>String s=&quot; &quot;</code> <ul>
<li>false</li>
</ul>
</li>
</ul>
</li>
<li><code>boolean isBlank(String s)</code><ul>
<li>判断字符串是否为空，会去除字符串空格。    </li>
<li><code>String s=null</code><ul>
<li>true</li>
</ul>
</li>
<li><code>String s=&quot;&quot;</code><ul>
<li>true</li>
</ul>
</li>
<li><code>String s=&quot; &quot;</code> <ul>
<li>true</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>java编程中的数据库操作实用工具，小巧简单实用</li>
<li>封装了对JDBC的操作，简化了JDBC操作<ul>
<li>对于数据表的读操作，它可以把结果转换成List，Array，Set等等</li>
<li>对于数据表的写操作，只需写sql语句</li>
<li>可以使用数据源，使用JNDI，数据库连接池等技术来优化性能–重用已经构建好的数据库连接对象</li>
</ul>
</li>
<li>一个工具类,定义了关闭资源与事务处理的方法</li>
</ul>
<h2 id="QueryRunner"><a href="#QueryRunner" class="headerlink" title="QueryRunner"></a>QueryRunner</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>提供对sql语句操作的API.</li>
<li>构造和方法中<ul>
<li>有Connection参数可以自己控制事务</li>
<li>没有Connection参数自动事务</li>
</ul>
</li>
</ul>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul>
<li><code>QueryRunner([boolean pmdKnownBroken])</code></li>
<li><code>QueryRunner(DataSource ds,[boolean pmdKnownBroken])</code><ul>
<li>true<ul>
<li>Oracle使用</li>
</ul>
</li>
<li>false或空参<ul>
<li>mysql    </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>&lt;T&gt; T query(String sql,ResultSetHandler&lt;T&gt; rsh,[Object... params])</code><ul>
<li>查询select</li>
</ul>
</li>
<li><code>int update([Connection conn].String sql,[Object... params])</code><ul>
<li>增删改(insert delete update)</li>
<li>int 影响行数</li>
</ul>
</li>
<li><code>int[] batch([Connection conn],String sql,Object[][] params)</code><ul>
<li>批处理</li>
</ul>
</li>
</ul>
<h4 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><ul>
<li>用于定义select操作后，怎样封装结果集</li>
</ul>
<h5 id="结果处理器"><a href="#结果处理器" class="headerlink" title="结果处理器"></a>结果处理器</h5><ul>
<li><code>ArrayHandler</code><ul>
<li>适合取1条记录。把该条记录的每列值封装到一个数组中Object[]</li>
<li><code>Object[]</code></li>
</ul>
</li>
<li><code>ArrayListHandler</code><ul>
<li>适合取多条记录。把每条记录的每列值封装到一个数组中Object[]，把数组封装到一个List中</li>
<li><code>List&lt;Object[]&gt;</code></li>
</ul>
</li>
<li><code>ColumnListHandler</code><ul>
<li>取某一列的数据(sql语句中的某一列)。封装到List中</li>
<li><code>List&lt;Object&gt;</code></li>
</ul>
</li>
<li><code>KeyedHandler</code><ul>
<li>取多条记录，每一条记录封装到一个Map中，再把这个Map封装到另外一个Map中，key为指定的字段值。</li>
<li><code>Map&lt;自定义key,Map&lt;列名,列值&gt;&gt;</code></li>
</ul>
</li>
<li><code>MapHandler</code><ul>
<li>适合取1条记录。把当前记录的列名和列值放到一个Map中</li>
<li><code>Map&lt;列名,列值&gt;</code></li>
</ul>
</li>
<li><code>MapListHandler</code><ul>
<li>适合取多条记录。把每条记录封装到一个Map中，再把Map封装到List中</li>
<li><code>List&lt;Map&lt;列名,列值&gt;&gt;</code></li>
</ul>
</li>
<li><code>ScalarHandler</code><ul>
<li>适合取单行单列数据</li>
<li>如取<code>count(*)</code></li>
<li><code>Object</code></li>
</ul>
</li>
<li><code>BeanHandler</code><ul>
<li>取一个对象</li>
<li><code>Object</code></li>
</ul>
</li>
<li><code>BeanListHandler</code><ul>
<li><code>取对象的集合</code></li>
<li><code>List&lt;Object&gt;</code></li>
</ul>
</li>
</ul>
<h1 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul>
<li>spring 提供用于操作JDBC工具类，类似DBUtils</li>
<li>依赖 连接池DataSource （数据源）</li>
</ul>
<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>update(String sql, Object... obj)</code><ul>
<li>执行DML语句 （增删改）</li>
</ul>
</li>
<li><code>queryForMap(String sql, Object... obj)</code><ul>
<li>查询的结果集封装为map集合</li>
<li>此方法查询结果集长度只能是1<ul>
<li>列名为key，列值为value</li>
</ul>
</li>
</ul>
</li>
<li><code>queryForList(String sql, Object... obj)</code><ul>
<li>将每一条记录封装为map集合，然后将map集合封装到list集合中</li>
<li><code>List&lt;Map&lt;String, Object&gt;&gt;</code></li>
</ul>
</li>
<li><code>query(String sql, RowMapper&lt;Object obj&gt; rowMapper, Object... obj)</code><ul>
<li>查询结果封装为javabean对象，然后封装到list集合</li>
<li><code>List&lt;Object obj&gt;</code></li>
</ul>
</li>
<li><code>queryForObject(String sql, Class&lt;? extends Object&gt; type, Object... obj)</code><ul>
<li>查询结果封装为对象（通常是基本数据类型包装类）</li>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
</ul>
<h3 id="RowMapper"><a href="#RowMapper" class="headerlink" title="RowMapper"></a>RowMapper</h3><ul>
<li>类似于DBUtils的ResultSetHandler</li>
<li>可以自己实现，也可使用提供的</li>
</ul>
<h4 id="BeanPropertyRowMapper"><a href="#BeanPropertyRowMapper" class="headerlink" title="BeanPropertyRowMapper"></a>BeanPropertyRowMapper</h4><ul>
<li>将结果集封装为对象，然后存在list中</li>
</ul>
<h1 id="内省-Introspector"><a href="#内省-Introspector" class="headerlink" title="内省(Introspector)"></a>内省(Introspector)</h1><h2 id="Introspector"><a href="#Introspector" class="headerlink" title="Introspector"></a>Introspector</h2><ul>
<li>Introspector根据<code>JavaBean.class</code>构建一个BeanInfo对象。</li>
<li>BeanInfo封装了一个类的所有属性</li>
<li>由BeanInfo获取属性描述器<code>PropertyDescriptor</code><ul>
<li><code>Method getReadMethod()</code><ul>
<li>对应get</li>
</ul>
</li>
<li><code>Method getWriteMethod()</code><ul>
<li>对应set</li>
</ul>
</li>
</ul>
</li>
<li>开发框架时，经常使用java对象的属性来封装程序的数据，每次都使用反射来完成此类操作过于麻烦。</li>
</ul>
<h2 id="java-beans"><a href="#java-beans" class="headerlink" title="java.beans"></a>java.beans</h2><ul>
<li>sun公司开发的一套api专门用于操作java对象的属性。</li>
<li>上述操作太过繁琐，Apache组织开发了一套api以简化编写</li>
</ul>
<h2 id="Beanutils"><a href="#Beanutils" class="headerlink" title="Beanutils"></a>Beanutils</h2><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><ul>
<li><code>void setProperty(Object bean,String filedName,Object value)</code></li>
<li><code>String getProperty(Object bean,String filedName)</code></li>
<li><code>void populate(Object bean,Map map)</code><ul>
<li>map中存字段名和值的键值对。</li>
</ul>
</li>
</ul>
<h3 id="PropertyUtils"><a href="#PropertyUtils" class="headerlink" title="PropertyUtils"></a>PropertyUtils</h3><h3 id="ConvertUtils"><a href="#ConvertUtils" class="headerlink" title="ConvertUtils"></a>ConvertUtils</h3><ul>
<li><code>void register(Converter con,Class&lt;?&gt; clazz)</code><ul>
<li>注册转换器</li>
<li>Beanutils默认支持8种基本类型，自动转换。</li>
<li>对于如日期需要先注册转换器。</li>
<li>使用<ul>
<li>在上述<code>BeanUtils</code>赋值前，调用一下。</li>
<li>可以使用内部类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="发邮件"><a href="#发邮件" class="headerlink" title="发邮件"></a>发邮件</h1><ul>
<li><code>javaMail.jar</code></li>
<li>然后工具类指定一些配置即可。</li>
</ul>
<h1 id="JS-插件"><a href="#JS-插件" class="headerlink" title="JS 插件"></a>JS 插件</h1><h3 id="validate-js"><a href="#validate-js" class="headerlink" title="validate.js"></a>validate.js</h3><ul>
<li>校验插件</li>
<li><p>使用</p>
<ul>
<li><p><code>$(&quot;form表单&quot;).validate(json数据);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#myForm&quot;).validate(&#123;</span><br><span class="line">	rules:&#123;</span><br><span class="line">		&quot;username&quot;:&#123;</span><br><span class="line">			&quot;required&quot;:true</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;password&quot;:&#123;</span><br><span class="line">			&quot;rerquired&quot;:true</span><br><span class="line">			&quot;rangelength&quot;:[6,12]</span><br><span class="line">		&#125;,	</span><br><span class="line">		......</span><br><span class="line">	&#125;,</span><br><span class="line">	messages:&#123;</span><br><span class="line">		&quot;username&quot;:&#123;</span><br><span class="line">			&quot;required&quot;:&quot;用户名不能为空&quot;,			</span><br><span class="line">		&#125;，</span><br><span class="line">		&quot;password&quot;:&#123;</span><br><span class="line">			&quot;rerquired&quot;:true</span><br><span class="line">			&quot;rangelength&quot;:&quot;密码长度6-12&quot;</span><br><span class="line">		&#125;,	</span><br><span class="line">		.......		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个规则，一个信息</p>
</li>
<li>可自定义规则</li>
</ul>
</li>
</ul>
<h1 id="第三方支付"><a href="#第三方支付" class="headerlink" title="第三方支付"></a>第三方支付</h1><h2 id="国付宝"><a href="#国付宝" class="headerlink" title="国付宝"></a>国付宝</h2><h2 id="连连支付"><a href="#连连支付" class="headerlink" title="连连支付"></a>连连支付</h2><ul>
<li>拍拍贷</li>
<li>陆金所</li>
<li>温商贷</li>
<li>玖富</li>
<li>360金融</li>
<li>点融 </li>
</ul>
<h2 id="易宝"><a href="#易宝" class="headerlink" title="易宝"></a>易宝</h2><h1 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h1><h2 id="邮箱客户端"><a href="#邮箱客户端" class="headerlink" title="邮箱客户端"></a>邮箱客户端</h2><ul>
<li>客户端<ul>
<li>foxmail</li>
<li>outlook</li>
</ul>
</li>
<li>网页</li>
</ul>
<h2 id="邮箱服务端"><a href="#邮箱服务端" class="headerlink" title="邮箱服务端"></a>邮箱服务端</h2><ul>
<li>邮件的接收和推送</li>
</ul>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul>
<li>接收<ul>
<li>POP3</li>
<li>IMAP</li>
</ul>
</li>
<li>发送<ul>
<li>SMTP</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/xd-上传和下载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/xd-上传和下载/" itemprop="url">
                  xd-上传和下载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-28 00:43:09 / 修改时间：01:28:45" itemprop="dateCreated datePublished" datetime="2018-12-28T00:43:09+08:00">2018-12-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ol>
<li>提供form表单 method为post</li>
<li>enctype属性为<code>multipart/form-data</code></li>
<li>提供<code>&lt;input type=&quot;file&quot; name=&quot;mn&quot;&gt;</code>上传输入域</li>
</ol>
<h3 id="enctype"><a href="#enctype" class="headerlink" title="enctype"></a>enctype</h3><ul>
<li>告知服务器请求正文的MIME类型。（请求消息头：Content-Type作用是一致的）</li>
<li><p><code>application/x-www-form-urlencoded</code></p>
<ul>
<li>默认<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//请求信息</span><br><span class="line">//请求行</span><br><span class="line">//请求头</span><br><span class="line">...</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">...</span><br><span class="line">请求体</span><br><span class="line">name=an3&amp;mn(input中file的name)=文件名(mm.jpg)</span><br><span class="line">//服务器获取数据</span><br><span class="line">String name = request.getParameter(&quot;name&quot;)</span><br><span class="line">String name=request.getParameter(&quot;mm&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>multipart/form-data</code></p>
<ul>
<li>上传用</li>
<li>使用<code>request.getParameter(key)</code>取不到表单数据</li>
<li><p>获取数据要使用流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//请求信息</span><br><span class="line">//请求行</span><br><span class="line">//请求头</span><br><span class="line">...</span><br><span class="line">Content-Type:multipart/form-data; boundar=======7df24c3430fa2</span><br><span class="line">//请求体</span><br><span class="line"> boundar=======7df24c3430fa2</span><br><span class="line">Content-Disposition: form-data; name=&quot;name&quot;</span><br><span class="line">an3</span><br><span class="line"> boundar=======7df24c3430fa2</span><br><span class="line">Content-Disposition: form-data; name=&quot;mn&quot;; filename=&quot;mm.jpg&quot;</span><br><span class="line">Contenet-Type: image/pjpeg</span><br><span class="line">图片的二进制数据</span><br><span class="line">//服务器获取数据</span><br><span class="line">//用字节流获取请求体的所有内容</span><br><span class="line">request.getInputStream()</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明(安)</p>
<ul>
<li>可以看出enctype为<code>multipart/form-data</code>时<ul>
<li>请求体中包含了文件名，文件类型，文件具体内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件上传原理"><a href="#文件上传原理" class="headerlink" title="文件上传原理"></a>文件上传原理</h2><ul>
<li>解析请求体的每部分的内容</li>
</ul>
<h2 id="上传步骤-安"><a href="#上传步骤-安" class="headerlink" title="上传步骤(安)"></a>上传步骤(安)</h2><ul>
<li>获取上传的文件的输入流</li>
<li>确定服务器保存路径</li>
<li>确定服务器保存文件名</li>
<li>新建File对象(路径+文件名)</li>
<li>以新建的file对象创建输出流</li>
<li>然后读写操作。。</li>
</ul>
<h2 id="上传需要注意的问题-安"><a href="#上传需要注意的问题-安" class="headerlink" title="上传需要注意的问题(安)"></a>上传需要注意的问题(安)</h2><ul>
<li>文件路径<ul>
<li>存储在服务器端的路径</li>
</ul>
</li>
<li>文件名<ul>
<li>存储的文件名，避免重复</li>
<li>随机啊日期啊</li>
</ul>
</li>
</ul>
<h2 id="fileupload"><a href="#fileupload" class="headerlink" title="fileupload"></a>fileupload</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>第三方的上传组件用来解析上传文件，帮我们解析<code>request.getInputStream()</code></li>
</ul>
<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><ul>
<li><code>DiskFileItemFactory</code></li>
<li><code>ServletFileUpload</code></li>
<li><code>FileItem</code></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><code>DiskFileItemFactory factory = new DiskFileItemFactory()</code><ul>
<li>创建工厂类DiskFileItemFactory对象</li>
<li>创建工厂时还可以指定缓存文件的大小和临时文件的位置</li>
<li>或者先创建，然后set也行<ul>
<li><code>factory.setSizeThreshold(字节)</code></li>
<li><code>factory.setRepository(new File(path))</code></li>
</ul>
</li>
</ul>
</li>
<li><code>ServletFileUpload fileUpload = new ServletFileUpload(factory)</code><ul>
<li>使用工厂创建解析器对象ServletFileUpload</li>
</ul>
</li>
<li><code>fileUpload.isMultipartContent(request)</code><ul>
<li>判断表单<code>enctype</code>是否是上传.</li>
</ul>
</li>
<li><code>List&lt;FileItem&gt; list = fileUpload.parseRequest(request)</code><ul>
<li>使用解析器来解析request对象</li>
</ul>
</li>
</ul>
<h4 id="FileItem"><a href="#FileItem" class="headerlink" title="FileItem"></a>FileItem</h4><ul>
<li>对应一个表单项（表单字段）。可以是文件字段或普通字段</li>
<li><code>boolean isFormField()</code><ul>
<li>判断当前表单字段是否为普通文本字段，如果返回false，说明是文件字段</li>
</ul>
</li>
<li><code>String getFieldName()</code><ul>
<li>获取字段名称</li>
</ul>
</li>
<li><code>String getString()</code><ul>
<li>获取字段的内容</li>
<li>如果是文件字段(必须是文本文件)，那么获取的是文件内容。</li>
<li>可以传入编码参数<ul>
<li><code>getString(&quot;utf-8&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>String getName()</code><ul>
<li>获取文件字段的文件名称(如：mm.jpg)</li>
</ul>
</li>
<li><code>String getContentType()</code><ul>
<li>获取上传的文件的MIME类型，例如：text/plain。</li>
</ul>
</li>
<li><code>int getSize()</code><ul>
<li>获取上传文件的大小</li>
</ul>
</li>
<li><code>InputStream getInputStream()</code><ul>
<li>获取上传文件对应的输入流；</li>
</ul>
</li>
<li><code>void write(File)</code><ul>
<li>把上传的文件保存到指定文件中</li>
</ul>
</li>
<li><code>IOUtils.copey(in,out)</code><ul>
<li>工具类保存</li>
</ul>
</li>
<li><code>delete()</code><ul>
<li>清理临时文件</li>
</ul>
</li>
</ul>
<h3 id="上传要考虑的问题"><a href="#上传要考虑的问题" class="headerlink" title="上传要考虑的问题"></a>上传要考虑的问题</h3><ul>
<li>文件名问题<ul>
<li>上传的文件名是全路径，有的浏览器会自动处理，有的不会，最好处理一下。<ol>
<li>手动处理</li>
<li><code>FilenameUtils</code></li>
</ol>
</li>
</ul>
</li>
<li>保证服务器安全<ul>
<li>把保存上传文件的目录放在用户直接访问不到的地方(web-inf下)</li>
</ul>
</li>
<li>避免文件被覆盖<ul>
<li>文件名唯一</li>
</ul>
</li>
<li>避免同一个文件夹中的文件过多<ul>
<li>按照日期进行打散存储目录</li>
<li>用文件名的hashCode计算打散的存储目录：二级目录</li>
</ul>
</li>
<li>限制文件的大小：web方式不适合上传大的文件<ul>
<li>单个文件大小<ul>
<li><code>ServletFileUpload.setFileSizeMax(字节)</code></li>
</ul>
</li>
<li>总文件大小：（多文件上传）<ul>
<li><code>ServletFileUpload.setSizeMax(字节)</code></li>
</ul>
</li>
</ul>
</li>
<li>上传字段用户没有上传的问题<ul>
<li>通过判断文件名是否为空即可</li>
</ul>
</li>
<li>临时文件的问题<ul>
<li><code>DiskFileItemFactory</code><ul>
<li>内部有一个缓存，缓存大小默认是10Kb。如果上传的文件超过10Kb，用磁盘作为缓存。</li>
<li>存放缓存文件的目录默认是系统的临时目录。</li>
<li>可以自己设置缓存大小，和临时目录（见上边）</li>
</ul>
</li>
<li>上传后，会在临时目录产生一个临时文件。</li>
<li>如果自己用IO流实现的文件上传，要在流关闭后，清理临时文件。<ul>
<li><code>FileItem.delete();</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><code>Content-disposition</code><ul>
<li>响应头，服务器告诉客户端以什么格式打开响应体数据</li>
<li><code>in-line</code><ul>
<li>默认值</li>
<li>在当前页面内打开</li>
</ul>
</li>
<li><code>attachment;filename=</code><ul>
<li>以附件形式打开响应体</li>
<li>文件下载</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li>设置响应头告诉浏览器是下载文件<ul>
<li><code>response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+fileName);</code></li>
</ul>
</li>
<li>设置响应头告诉浏览器下载的文件类型<ol>
<li><code>response.setHeader(&quot;content-type&quot;, &quot;image/jpeg&quot;);</code><ul>
<li>手动设置文件类型是图片</li>
</ul>
</li>
<li><code>response.setContentType(this.getServletContext().getMimeType(fileName))</code><ul>
<li>设置类型为根据文件名获取的类型</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>根据请求参数获取文件名<ul>
<li><code>String filename = request.getParameter(String filename)</code></li>
</ul>
</li>
<li>根据文件名获取文件服务器路径<ul>
<li><code>String path=this.getServletContext.getRealPath(&quot;/filename&quot;);</code></li>
</ul>
</li>
<li>根据文件路径创建输入流</li>
<li>设置响应头<ol>
<li>下载文件</li>
<li>文件类型</li>
</ol>
</li>
<li>获取响应输出流，不断读写</li>
</ol>
<h3 id="下载文件名中文问题"><a href="#下载文件名中文问题" class="headerlink" title="下载文件名中文问题"></a>下载文件名中文问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// agent就是请求头User-Agent的值</span><br><span class="line">public class DownLoadUtils &#123;</span><br><span class="line">    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException &#123;</span><br><span class="line">        if (agent.contains(&quot;MSIE&quot;)) &#123;</span><br><span class="line">            // IE浏览器</span><br><span class="line">            filename = URLEncoder.encode(filename, &quot;utf-8&quot;);</span><br><span class="line">            filename = filename.replace(&quot;+&quot;, &quot; &quot;);</span><br><span class="line">        &#125; else if (agent.contains(&quot;Firefox&quot;)) &#123;</span><br><span class="line">            // 火狐浏览器</span><br><span class="line">            BASE64Encoder base64Encoder = new BASE64Encoder();</span><br><span class="line">            filename = &quot;=?utf-8?B?&quot; + base64Encoder.encode(filename.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其它浏览器</span><br><span class="line">            filename = URLEncoder.encode(filename, &quot;utf-8&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return filename;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/xd-WEB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/xd-WEB/" itemprop="url">
                  xd-WEB
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-25 22:57:57" itemprop="dateCreated datePublished" datetime="2018-12-25T22:57:57+08:00">2018-12-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-27 21:17:06" itemprop="dateModified" datetime="2018-12-27T21:17:06+08:00">2018-12-27</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Web容器"><a href="#Web容器" class="headerlink" title="Web容器"></a>Web容器</h1><ul>
<li>所有的程序运行都需要有一个必要的运行环境。这个环境可以是软件，也可以是硬件，或者是软件和硬件的结合。比如说Windows操作系统需要运行在硬件基础上；Office软件需要运行在操作系统上。并且程序与运行环境之间会有一定的数据交换，比如操作系统会将运行指令传递给硬件，硬件也会将指令运行结果传递给操作系统</li>
<li>Java Web程序也需要一个运行环境才能够执行。这种运行Java Web程序的环境被称为Web容器，Java Web程序与Web容器之间存在数据交互。</li>
</ul>
<h2 id="独立的Java-Web容器"><a href="#独立的Java-Web容器" class="headerlink" title="独立的Java Web容器"></a>独立的Java Web容器</h2><ul>
<li>在这种容器里面只能运行Web程序，这种容器一般也叫做Web服务器，如Tomcat</li>
</ul>
<h2 id="与其他Java-EE容器混合在一起的Web容器"><a href="#与其他Java-EE容器混合在一起的Web容器" class="headerlink" title="与其他Java EE容器混合在一起的Web容器"></a>与其他Java EE容器混合在一起的Web容器</h2><ul>
<li>Web容器负责运行Web程序，其他容器负责运行EJB等程序，如WebLogic</li>
</ul>
<h2 id="web容器与web应用间的数据交互"><a href="#web容器与web应用间的数据交互" class="headerlink" title="web容器与web应用间的数据交互"></a>web容器与web应用间的数据交互</h2><ul>
<li>web容器接收客户端请求封装<strong>HttpServletRequest</strong>对象，并传递给web应用</li>
<li>web应用处理请求</li>
<li>web容器将结果封装到<strong>HttpServletResponse</strong>对象，响应给客户端</li>
<li>注<ul>
<li>这两个对象仅存在于Web容器和Web应用当中，与浏览器没有关系</li>
</ul>
</li>
</ul>
<h2 id="tomcat和servlet的区别"><a href="#tomcat和servlet的区别" class="headerlink" title="tomcat和servlet的区别"></a>tomcat和servlet的区别</h2><ul>
<li>Tomcat 是Web应用服务器,是一个Servlet/JSP容器</li>
<li>servlet是一种运行在服务器端的Java应用程序</li>
</ul>
<h2 id="web应用服务器"><a href="#web应用服务器" class="headerlink" title="web应用服务器"></a>web应用服务器</h2><ul>
<li><code>tomcat</code><ul>
<li>支持servlet/jsp规范</li>
</ul>
</li>
<li><code>weblogic</code><ul>
<li>支持全部j2ee规范</li>
</ul>
</li>
<li><code>websphere</code><ul>
<li>支持全部j2ee规范</li>
</ul>
</li>
<li><code>jboss</code></li>
</ul>
<h1 id="标准JavaWeb应用目录结构"><a href="#标准JavaWeb应用目录结构" class="headerlink" title="标准JavaWeb应用目录结构"></a>标准JavaWeb应用目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyApp  				//项目名</span><br><span class="line">	html,css,js,img... //资源文件</span><br><span class="line">	WEB-INF</span><br><span class="line">		classes	    //.class文件，配置文件</span><br><span class="line">		lib			// jar包</span><br><span class="line">		web.xml		//web配置文件</span><br></pre></td></tr></table></figure>
<ul>
<li>说明<ul>
<li>ide中的src目录<ul>
<li>编译后会存在web-inf下的classes中。</li>
</ul>
</li>
<li>以下三个目录中的文件会直接存在应用下，与web-inf同级，相当于资源文件<ul>
<li>eclipse中的WebContent目录</li>
<li>Myeclipse中的WebRoot目录</li>
<li>intellij中的web目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul>
<li>Tomcat启动时，需要查找<code>CATALINA_HOME</code>这个环境变量<ul>
<li>判断<code>CATALINA_HOME</code>环境变量是否为空<ul>
<li>为空<ul>
<li>就将当前目录设为CATALINA_HOME的值，接着判断当前目录下是否存在<code>bin\catalina.bat</code>，如果文件不存在，将当前目录的父目录设为<code>CATALINA_HOM</code>E的值，循环，最后如果找不到<code>bin\catalina.bat</code>就报错。</li>
</ul>
</li>
<li>不为空<ul>
<li>通过这个环境变量调用<code>bin\catalina.bat</code>命令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>执行<code>startup.bat</code>命令，会自动去执行<code>catalina.bat start</code>命令</li>
</ul>
<p>##<code>CATALINA_HOME</code>和<code>CATALINA_BASE</code>区别</p>
<h3 id="CATALINA-HOME"><a href="#CATALINA-HOME" class="headerlink" title="CATALINA_HOME"></a>CATALINA_HOME</h3><ul>
<li>是Tomcat的安装目录</li>
<li>类似于<code>JAVA_HOME</code>环境变量</li>
<li>如果配置了就能在任意路径执行bin目录下的bat或者exe</li>
<li>通常不配置</li>
</ul>
<h3 id="CATALINA-BASE"><a href="#CATALINA-BASE" class="headerlink" title="CATALINA_BASE"></a>CATALINA_BASE</h3><ul>
<li>是Tomcat的工作目录</li>
<li>如果CATALINA_BASE没有值的话，它默认的值就是CATALINA_HOME</li>
</ul>
<h3 id="tomcat目录"><a href="#tomcat目录" class="headerlink" title="tomcat目录"></a>tomcat目录</h3><ul>
<li>其中只有 bin 和 lib 目录被多个tomcat示例公用</li>
<li>其它目录conf、logs、temp、webapps和work 每个Tomcat实例必须拥有其自己独立的备份</li>
<li>catalina.home(安装目录)：<ul>
<li>指向公用信息的位置，就是bin和lib的父目录</li>
</ul>
</li>
<li>catalina.base(工作目录)：<ul>
<li>指向每个Tomcat目录私有信息的位置，就是conf、logs、temp、webapps和work的父目录。</li>
</ul>
</li>
<li>仅运行一个Tomcat实例时，这两个属性指向的位置是相同的</li>
</ul>
<h3 id="网上自建startup-bat的内容"><a href="#网上自建startup-bat的内容" class="headerlink" title="网上自建startup.bat的内容"></a>网上自建<code>startup.bat</code>的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set &quot;CATALINA_BASE=%cd%&quot;  </span><br><span class="line">set &quot;CATALINA_HOME=D:/save/apache-tomcat-8.0.48&quot;  </span><br><span class="line">set &quot;EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat&quot;  </span><br><span class="line">call &quot;%EXECUTABLE%&quot; start</span><br></pre></td></tr></table></figure>
<ul>
<li><code>%cd%</code><ul>
<li>代表当前目录（不太确定）</li>
</ul>
</li>
<li><code>CATALINA_BASE</code>就代表一个tomcat的运行实例<ul>
<li>包含<code>conf</code>,logs,temp,webapps,work`的目录。</li>
</ul>
</li>
<li><code>CATALINA_HOME</code>代表了一个tomcat，需要tomcat的<code>bin,lib...</code></li>
<li>启动tomcat后，<code>CATALINA_BASE</code>指向哪个tomcat实例，就运行哪个。<ul>
<li>比如我有一个tomcat8080，然后再另一个文件夹复制了一个<code>conf</code>并设置端口号为7070</li>
<li><code>CATALINA_HOME</code>为tomcat8080安装目录，设置<code>CATALINA_BASE</code>为7070对应的目录，那么能访问的是7070而非8080,</li>
<li><strong>虚拟目录</strong>貌似就是这个原理。</li>
</ul>
</li>
</ul>
<h2 id="tomcat部署应用"><a href="#tomcat部署应用" class="headerlink" title="tomcat部署应用"></a>tomcat部署应用</h2><h3 id="部署形式"><a href="#部署形式" class="headerlink" title="部署形式"></a>部署形式</h3><ol>
<li>项目文件夹</li>
<li>war包<ul>
<li>tomcat会自动判断war包并解压。</li>
</ul>
</li>
</ol>
<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><h4 id="一-将项目复制到tomcat-webapps目录下。"><a href="#一-将项目复制到tomcat-webapps目录下。" class="headerlink" title="一 将项目复制到tomcat/webapps目录下。"></a>一 将项目复制到<code>tomcat/webapps</code>目录下。</h4><ul>
<li>Myeclipse就是这种方式。</li>
</ul>
<h4 id="二-虚拟目录"><a href="#二-虚拟目录" class="headerlink" title="二 虚拟目录"></a>二 虚拟目录</h4><ul>
<li>就是把项目放到其它位置通过一些配置也能一样访问。(安)</li>
</ul>
<h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h5><ul>
<li><p><code>tomcat/conf/server.xml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Host&gt;</span><br><span class="line">	&lt;Context docBase=&quot;应用的真实路径&quot; path=&quot;网络访问的虚拟目录名(自定义)&quot; /&gt;</span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Eclipse使用这种方式</p>
<ul>
<li><code>Catalina_Base</code><ul>
<li><code>workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps</code></li>
</ul>
</li>
</ul>
</li>
<li>不推荐，修改需要重启tomcat</li>
</ul>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><ul>
<li><p><code>tomcat/conf/catalina/localhost</code></p>
<ul>
<li>新建<code>虚拟目录名(自定义).xml</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context docBase=&quot;应用的真实路径&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Intellij使用这种方式</p>
<ul>
<li><code>Catalina_Base</code><ul>
<li><code>Intellij/system/tomcat/</code></li>
</ul>
</li>
</ul>
</li>
<li>支持热部署，修改不用重启tomcat</li>
<li>如果新建的<code>虚拟目录名</code>为<code>ROOT</code>，则访问时，可以不写<ul>
<li>Intellij就是这样做的</li>
</ul>
</li>
</ul>
<h2 id="tomcat的访问"><a href="#tomcat的访问" class="headerlink" title="tomcat的访问"></a>tomcat的访问</h2><ul>
<li><code>http://ip:端口/应用/资源</code></li>
</ul>
<h3 id="默认端口"><a href="#默认端口" class="headerlink" title="默认端口"></a>默认端口</h3><ul>
<li>http协议端口为80</li>
<li>把tomcat端口设为80就不用写端口了</li>
</ul>
<h3 id="默认应用"><a href="#默认应用" class="headerlink" title="默认应用"></a>默认应用</h3><ul>
<li>tomcat默认访问ROOT应用<br>  *（见上边虚拟目录）</li>
</ul>
<h3 id="默认主页"><a href="#默认主页" class="headerlink" title="默认主页"></a>默认主页</h3><ul>
<li><code>web.xml</code>中配置</li>
</ul>
<h2 id="idea中tomcat的部署"><a href="#idea中tomcat的部署" class="headerlink" title="idea中tomcat的部署"></a>idea中tomcat的部署</h2><h3 id="war"><a href="#war" class="headerlink" title="war"></a><code>war</code></h3><ul>
<li>将web工程以war包的形式上传到服务器</li>
<li>可以称之为是发布模式，看名字也知道，这是先打包war包，再发布</li>
<li><code>request.getServletContext().getRealPath(&quot;/&quot;)</code><ul>
<li><code>D:\save\apache-tomcat-8.0.48\webapps\ROOT\</code></li>
<li>结果是tomcat的webapps的Root目录</li>
<li>会把Root目录项目替换成此项目<ul>
<li>此种情况是配置tomcat时application context选择了<code>/</code></li>
<li>如果配置成别的如<code>/aaa</code><ul>
<li>则不会替换Root，而是在webapps下创建aaa</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="war-exploed"><a href="#war-exploed" class="headerlink" title="war exploed"></a><code>war exploed</code></h3><ul>
<li>将web工程以当前文件夹的位置关系上传到服务器</li>
<li>展开部署(相当于将资源文件进行展开后进行部署)</li>
<li>直接把文件夹，jsp页面，classes等等移到Tomcat部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。</li>
<li><code>request.getServletContext().getRealPath(&quot;/&quot;)</code><ul>
<li><code>D:\save\IntellijWP\project\HelloMaven\target\HelloMaven-1.0-SNAPSHOT\</code></li>
<li>可以看到是项目target下的目录</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/xd-BootStrap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/xd-BootStrap/" itemprop="url">
                  xd-BootStrap
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-25 13:38:34 / 修改时间：13:38:35" itemprop="dateCreated datePublished" datetime="2018-12-25T13:38:34+08:00">2018-12-25</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/xd-事务和连接池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/20/xd-事务和连接池/" itemprop="url">
                  xd-事务和连接池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-20 13:06:35" itemprop="dateCreated datePublished" datetime="2018-12-20T13:06:35+08:00">2018-12-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-24 14:45:19" itemprop="dateModified" datetime="2018-12-24T14:45:19+08:00">2018-12-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h1><h2 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h2><ul>
<li>一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
</ul>
<h2 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h2><ul>
<li>事务必须是使数据库从一个一致性状态变到另一个一致性状态。即事务操作的前后, 数据表中的数据没有变化</li>
<li>一致性与原子性是密切相关的。</li>
</ul>
<h2 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h2><ul>
<li>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
</ul>
<h2 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h2><ul>
<li>持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>
<h1 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h1><ul>
<li>事务开启之后, 所有的操作都会临时保存到事务日志, 事务日志只有在得到commit命令才会同步到数据表,其他任何情况都会清空(rollback, 断电, 断开连接)</li>
</ul>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><ul>
<li>在一个事务处理过程里读取了另一个事务未提交的数据。</li>
<li><strong>例</strong><ul>
<li>我开启查看工资的事务,老板给我发工资，本来是1万，老板不小心多打了个0，发了10万，但老板没提交事务，我看到发了10万，高兴坏了，然后老板发现后回滚了。</li>
<li>最后实际还是发了1万工资，可我确看到10万，这就是脏读。</li>
</ul>
</li>
</ul>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><ul>
<li>在一个事务内读取表中的某一行数据，多次读取结果不同。一个事务读取到了另一个事务提交后的数据。(update)</li>
<li><strong>例</strong><ul>
<li>我开启事务查看卡里有多少钱，发现还有1万，还个事务没提交，这时我媳妇用我的卡转了1万并提交了。然后我想确认一下，又查了一遍，发现没钱了，我就懵逼了。</li>
<li>在一个事务中，有另一个事务进行了update操作并提交，导致两次读取数据不一致，就是不可重复读.</li>
</ul>
</li>
</ul>
<h3 id="虚读-幻读"><a href="#虚读-幻读" class="headerlink" title="虚读(幻读)"></a>虚读(幻读)</h3><ul>
<li>是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。(insert)</li>
<li><strong>例</strong><ul>
<li>我开启事务查询班里多少人，发现有24个人，还没提交，然后老师又插入了一个人，我确认一下，又查了一遍，发现25个人了，我又懵逼了。</li>
<li>在一个事务中，有另一个事务进行了insert操作并提交，导致两次读取数据不一致，就是虚读(幻读).</li>
</ul>
</li>
</ul>
<h3 id="总"><a href="#总" class="headerlink" title="总"></a>总</h3><ul>
<li>读了未提交的事务的数据即<strong>脏读</strong></li>
<li>读了已提交的事务的数据(update)即<strong>不可重复读</strong></li>
<li>读了已提交的事务的数据(insert)即<strong>虚读(幻读)</strong></li>
</ul>
<h2 id="隔离级别解决问题"><a href="#隔离级别解决问题" class="headerlink" title="隔离级别解决问题"></a>隔离级别解决问题</h2><ul>
<li>设置隔离级别要在开启事务之前。</li>
</ul>
<h3 id="1-READ-UNCOMMITTED"><a href="#1-READ-UNCOMMITTED" class="headerlink" title="1 READ UNCOMMITTED"></a><code>1 READ UNCOMMITTED</code></h3><ul>
<li>读未提交<ul>
<li>就是一个事务可以读取另一个未提交事务的数据</li>
</ul>
</li>
<li>脏读，不可重复读，虚读（幻读）都可能发生</li>
</ul>
<h3 id="2-READ-COMMITTED"><a href="#2-READ-COMMITTED" class="headerlink" title="2 READ COMMITTED"></a><code>2 READ COMMITTED</code></h3><ul>
<li>读已提交<ul>
<li>就是一个事务要等另一个事务提交后才能读取数据</li>
</ul>
</li>
<li>可避免脏读的发生</li>
<li>不可重复度，虚读(幻读)有可能发生.</li>
<li>Sql Server,oracle默认</li>
</ul>
<h3 id="4-REPEATABLE-READ"><a href="#4-REPEATABLE-READ" class="headerlink" title="4 REPEATABLE READ"></a><code>4 REPEATABLE READ</code></h3><ul>
<li>可重复读<ul>
<li>开始读取数据(事务开启)时，不允许别的事务进行update操作,但可以进行inser操作。</li>
</ul>
</li>
<li>可避免脏读、不可重复读的发生</li>
<li>虚读(幻读)有可能发生</li>
<li>mysql默认</li>
</ul>
<h3 id="8-SERIALIZABLE"><a href="#8-SERIALIZABLE" class="headerlink" title="8 SERIALIZABLE"></a><code>8 SERIALIZABLE</code></h3><ul>
<li>串行化</li>
<li>最高级别，都可以避免。</li>
<li>级别越高，性能越低，数据越安全</li>
</ul>
<h1 id="jdbc的事务"><a href="#jdbc的事务" class="headerlink" title="jdbc的事务"></a>jdbc的事务</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>自动提交事务（默认）<ul>
<li>每条单独的语句都是一个事务。每个语句后都隐含一个commit。 </li>
</ul>
</li>
<li><code>Connection.setAutoCommit(false)</code><ul>
<li>将自动提交设置为false即视为开启事务。</li>
</ul>
</li>
<li><code>Connection.commit()</code></li>
<li><code>Connection.rollback()</code></li>
</ul>
<h2 id="隔离级别-1"><a href="#隔离级别-1" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul>
<li><code>Connection.setTransactionIsolation(int level)</code><ul>
<li>设置隔离级别(必须在开启事务之前)<ul>
<li>level 常量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="mysql的事务"><a href="#mysql的事务" class="headerlink" title="mysql的事务"></a>mysql的事务</h1><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><ul>
<li>在mysql命令行下，默认事务都是自动提交的<ul>
<li><code>set autocommit=0/off</code><ul>
<li>关闭自动提交</li>
</ul>
</li>
</ul>
</li>
<li><code>begin</code> | <code>start transction</code> | <code>set autocommit=0/off</code><ul>
<li>开启事务</li>
</ul>
</li>
<li><code>commit</code></li>
<li><code>rollback</code></li>
</ul>
<h2 id="隔离级别-2"><a href="#隔离级别-2" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul>
<li><code>SELECT @@TX_ISOLATION;</code><ul>
<li>查看隔离级别</li>
</ul>
</li>
<li><code>SET TRANSACTION ISOLATION LEVEL 四个级别之一</code><ul>
<li>设置隔离级别</li>
<li>必须在开启事务之前</li>
</ul>
</li>
</ul>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><h2 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h2><ul>
<li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>解决建立数据库连接耗费资源和时间很多的问题，提高性能</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</li>
</ul>
<h2 id="javax-sql-DataSorce"><a href="#javax-sql-DataSorce" class="headerlink" title="javax.sql.DataSorce"></a><code>javax.sql.DataSorce</code></h2><ul>
<li>sun官方标准的连接池接口</li>
<li>自定义连接池实现此接口，数据库厂商自己实现。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>Connection getConnection()</code></li>
<li><code>Connection getConnection(String username, String password)</code></li>
</ul>
<h2 id="常用连接池"><a href="#常用连接池" class="headerlink" title="常用连接池"></a>常用连接池</h2><h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h3><ul>
<li><code>Database Connection Pool</code></li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>导包</li>
<li>配置文件</li>
<li>获取数据源<ul>
<li><code>BasicDataSourceFactory</code><ul>
<li><code>static DataSource createDataSource(properties prop)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = new Properties();</span><br><span class="line">prop.load(DBCPUtils.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;));</span><br><span class="line">DataSource ds = BasicDataSourceFactory.createDataSource(prop);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul>
<li>导包</li>
<li>配置文件<ul>
<li><code>c3p0-config.xml</code></li>
<li>名称必须为c3p0-config.xml，否则找不到</li>
</ul>
</li>
<li>获取数据源<ul>
<li><code>ComboPooledDataSource</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ComboPooledDataSource ds=new ComboPooledDataSource();</span><br><span class="line">ds.setDriver()</span><br><span class="line">ds.setJdbcUrl()</span><br><span class="line">ds.setUser()</span><br><span class="line">ds.setPassword;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><ul>
<li><code>com.alibaba.druid.pool.DruidDataSource</code></li>
<li>阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池(据说是目前最好的连接池）</li>
</ul>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><ul>
<li>导包</li>
<li>配置文件<ul>
<li>任意位置，任意名称<code>.properties</code></li>
</ul>
</li>
<li>获取数据源<ul>
<li><code>DruidDataSourceFactory</code><ul>
<li><code>DataSource createDataSource(Properties prop)</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用JavaWeb服务器管理数据源"><a href="#用JavaWeb服务器管理数据源" class="headerlink" title="用JavaWeb服务器管理数据源"></a>用JavaWeb服务器管理数据源</h2><h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li>拷贝数据库连接的jar(mysql-Connector)到tomcat的lib目录下</li>
<li><p>配置数据源XML文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context&gt;</span><br><span class="line">	&lt;Resource name=&quot;jdbc/TestDB&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot;</span><br><span class="line">           maxTotal=&quot;100&quot; maxIdle=&quot;30&quot; maxWaitMillis=&quot;10000&quot;</span><br><span class="line">           username=&quot;root&quot; password=&quot;root&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">           url=&quot;jdbc:mysql://localhost:3306/javatest&quot;/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是在当前应用的META-INF中创建<code>context.xml</code>, 编写配置信息，那么只有当前应用可以使用。</li>
<li>如果把配置信息写在tomcat下的conf目录的<code>context.xml</code>中，那么所有应用都能使用此数据源。<ul>
<li>可以多个Resource如mysql，Oracle，sqlserver…</li>
<li>多个就构成了<strong>JNDI</strong>(安)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Context initContext = new InitialContext();</span><br><span class="line"></span><br><span class="line">//Context envContext  = (Context)initContext.lookup(&quot;java:/comp/env&quot;);</span><br><span class="line">//DataSource ds = (DataSource)envContext.lookup(&quot;jdbc/TestDB&quot;);</span><br><span class="line"></span><br><span class="line">//上面两句可以合写成下面这一句</span><br><span class="line">DataSource ds = (DataSource)=initContext.lookup(&quot;java:/comp/env/jdbc/TestDB&quot;);</span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>java:/comp/env</code><ul>
<li>是固定写法</li>
</ul>
</li>
<li><code>jdbc/TestDB</code><ul>
<li>是Resource的name，自定义。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-MyBatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-MyBatis/" itemprop="url">
                  xd-MyBatis
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:40:45" itemprop="dateCreated datePublished" datetime="2018-12-11T00:40:45+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-22 00:59:32" itemprop="dateModified" datetime="2019-01-22T00:59:32+08:00">2019-01-22</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>mybatis就是一个封装来jdbc的持久层框架，它和hibernate都属于ORM框架</li>
<li>hibernate是一个完全的orm框架，而mybatis是一个不完全的orm框架</li>
<li>Mybatis让程序员只关注sql本身，而不需要去关注如连接的创建、statement的创建等操作</li>
<li>mybatis通过 xml 或注解的方式将要执行的各种statement配置起来，并通过java对象和statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并<br>返回</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="原生jdbc的问题"><a href="#原生jdbc的问题" class="headerlink" title="原生jdbc的问题"></a>原生jdbc的问题</h2><ul>
<li>在创建连接时，存在硬编码<ul>
<li>解决：配置文件（全局配置文件）</li>
</ul>
</li>
<li>在执行statement时存在硬编码<ul>
<li>解决：配置文件（映射文件）</li>
</ul>
</li>
<li>频繁的开启和关闭数据库连接，会造成数据库性能下降<ul>
<li>解决：数据库连接池（全局配置文件）</li>
</ul>
</li>
</ul>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><ul>
<li>MyBatis应用程序根据XML配置文件创建SqlSessionFactory，SqlSessionFactory在根据配置，配置来源于两个地方，一处是配置文件，一处是Java代码的注解，获取一个SqlSession。SqlSession包含了执行sql所需要的所有方法，可以通过SqlSession实例直接运行映射的sql语句，完成对数据的增删改查和事务提交等，用完之后关闭SqlSession</li>
</ul>
<h1 id="maven加载映射文件"><a href="#maven加载映射文件" class="headerlink" title="maven加载映射文件"></a>maven加载映射文件</h1><ul>
<li>由于maven不会编译<code>src/main/java</code>下的<code>xml,properties...</code>等文件，所以加载不到</li>
</ul>
<ol>
<li><p>配置加载<code>src/main/java</code>下的资源文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">     &lt;resources&gt;</span><br><span class="line">         &lt;resource&gt;</span><br><span class="line">             &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">             &lt;includes&gt;</span><br><span class="line">                 &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">             &lt;/includes&gt;</span><br><span class="line">         &lt;/resource&gt;</span><br><span class="line">     &lt;/resources&gt;</span><br><span class="line"> &lt;/build&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源文件放到<code>src/main/resources</code>下，并建立与mapper接口相同的目录结构</p>
<ul>
<li>注<ul>
<li>由于在resources下不能建package，只能建directory，所以需要一级一级的建。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h2><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><ul>
<li>方法作用域（也就是局部方法变量）</li>
<li>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</li>
</ul>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><ul>
<li>应用作用域</li>
<li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</li>
</ul>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><ul>
<li>请求作用域</li>
<li>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</li>
<li>下面的示例就是一个确保 SqlSession 关闭的标准模式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">  	// do work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="映射器实例（Mapper-Instances）"><a href="#映射器实例（Mapper-Instances）" class="headerlink" title="映射器实例（Mapper Instances）"></a>映射器实例（Mapper Instances）</h3><ul>
<li>方法作用域</li>
<li>映射器是创建用来绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，映射器实例的最大作用域是和 SqlSession 相同的，因为它们都是从 SqlSession 里被请求的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求作用域（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域（method scope）内。下面的示例就展示了这个实践：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line"> 	 BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  	// do work</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="加载核心配置并获取SqlSessionFactory"><a href="#加载核心配置并获取SqlSessionFactory" class="headerlink" title="加载核心配置并获取SqlSessionFactory"></a>加载核心配置并获取SqlSessionFactory</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String resource = &quot;SqlMapConfig.xml的路径&quot;</span><br><span class="line">InputStream in = Resources.getResourceAsStream(resource)</span><br><span class="line">SqlSessionFactory sf = new SqlSessionFactoryBuilder().build(in)</span><br></pre></td></tr></table></figure>
<h2 id="获取SqlSession"><a href="#获取SqlSession" class="headerlink" title="获取SqlSession"></a>获取SqlSession</h2><ul>
<li><code>SqlSession sqlSession = sf.openSession();</code></li>
</ul>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><ul>
<li><code>insert(String insertId, Object o)</code><ul>
<li><code>xxxId</code>皆为<code>namespace.id</code></li>
<li>其它方法同</li>
</ul>
</li>
</ul>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><ul>
<li><code>delete(String deleteId, Object o)</code></li>
</ul>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><ul>
<li><code>update(String updateId, Object o)</code></li>
</ul>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><ul>
<li><code>selectOne(String selectID, Object o)</code></li>
<li><code>selectList(String selectID, Object o</code></li>
</ul>
<h2 id="获取Mapper"><a href="#获取Mapper" class="headerlink" title="获取Mapper"></a>获取Mapper</h2><ul>
<li><code>getMapper(Class clazz)</code></li>
</ul>
<h1 id="mybatis开发dao的方式"><a href="#mybatis开发dao的方式" class="headerlink" title="mybatis开发dao的方式"></a>mybatis开发dao的方式</h1><h2 id="原始dao-接口-实现类"><a href="#原始dao-接口-实现类" class="headerlink" title="原始dao(接口+实现类)"></a>原始dao(接口+实现类)</h2><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>有大量的重复的模板代码</li>
<li>存在硬编码</li>
</ul>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ul>
<li>我们使用实现类直接调用curd的方法</li>
<li><code>selectOne()/selectList() → ... → query()</code><ul>
<li>查询经过一系列过程，最后是jdbc</li>
<li>query()中<code>PreparedStatement.execute()</code></li>
</ul>
</li>
<li><code>insert()/delete()/update() → ... → update()</code><ul>
<li>增删改经过一系列过程，最后是jdbc</li>
<li>update()中<code>PreparedStatement.execute()</code></li>
</ul>
</li>
</ul>
<h2 id="Mapper代理"><a href="#Mapper代理" class="headerlink" title="Mapper代理"></a>Mapper代理</h2><ul>
<li>mapper接口（相当于dao接口）<ul>
<li>Mapper代理使用的是jdk的代理策略</li>
</ul>
</li>
</ul>
<h3 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h3><ul>
<li>我们调用<code>getMapper()</code>方法</li>
<li><code>getMapper()  → ... → selectOne()/selectList()/insert()/delete()/update()  → ... → ...</code><ul>
<li>经过一系列过程，mybatis判断后调用curd对应的方法，后边过程就和直接使用实现类一致。</li>
</ul>
</li>
</ul>
<h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><ul>
<li>mapper接口的全限定名要和mapper映射文件的namespace值一致</li>
<li>mapper接口的方法名称要和mapper映射文件的statement的id一致</li>
<li>mapper接口的方法参数类型要和mapper映射文件的statement的parameterType的值一致，而且它的参数是一个</li>
<li>mapper接口的方法返回值类型要和mapper映射文件的statement的resultType的值一致</li>
</ul>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="全局xml配置详解"><a href="#全局xml配置详解" class="headerlink" title="全局xml配置详解"></a>全局xml配置详解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	* properties 属性</span><br><span class="line">	* settings 设置</span><br><span class="line">	* typeAliases 类型别名</span><br><span class="line">	* typeHandlers 类型处理器</span><br><span class="line">	* objectFactory 对象工厂</span><br><span class="line">	* plugins 插件</span><br><span class="line">	* environments 环境</span><br><span class="line">		* environment 环境变量</span><br><span class="line">		* transactionManager 事务管理器</span><br><span class="line">		* dataSource 数据源</span><br><span class="line">	* databaseIdProvider 数据库厂商标识</span><br><span class="line">	* mappers 映射器</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><ul>
<li><code>resource</code><ul>
<li>用于指定配置文件位置，是按照类路径的写法来写，资源必须在类路径下</li>
</ul>
</li>
<li><code>url</code><ul>
<li>是按照url的写法来写<ul>
<li><code>协议 主机 端口 uri</code></li>
</ul>
</li>
</ul>
</li>
<li><p>替换动态配置的属性值有三种方法</p>
<ol>
<li>引入外部properties文件<ul>
<li><code>&lt;properties resource=&quot;jdbc.properties&quot;&gt;</code></li>
</ul>
</li>
<li><p><code>properties</code>标签中也可添加属性配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">	 &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;</span><br><span class="line">	 &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SqlSessionFactoryBuilder.build()</code>方法中传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);</span><br><span class="line">// ... or ...</span><br><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>注<ul>
<li>如果属性在不只一个地方进行了配置，加载顺序<ul>
<li>2-1-3</li>
</ul>
</li>
<li>后加载的会覆盖先加载的，所以优先级<ul>
<li>方法传递属性&gt;外部properties文件&gt;内部<code>properties</code>标签</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><ul>
<li>影响mybatis的运行行为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">	&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><ul>
<li>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余</li>
<li>如果配置了别名，就不区分大小写</li>
<li>mybatis中有很多默认的别名，也就是帮我们写好了的，例如<ul>
<li>基本类型，别名为在前边加一个<code>_</code><ul>
<li><code>_byte _int ...</code></li>
</ul>
</li>
<li>基本类型包装类，别名为其基本类型<ul>
<li><code>byte int ...</code></li>
</ul>
</li>
<li>字符串和集合，别名为其首字母小写<ul>
<li><code>string map list ...</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="单个自定义"><a href="#单个自定义" class="headerlink" title="单个自定义"></a>单个自定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;</span><br><span class="line">	&lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>
<h4 id="批量自定义"><a href="#批量自定义" class="headerlink" title="批量自定义"></a>批量自定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;package name=&quot;domain.blog&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解<code>@Alias(&quot;xxx&quot;)</code>，则别名为其注解值</li>
</ul>
<h3 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h3><ul>
<li>尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">	&lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">		&lt;transactionManager type=&quot;JDBC&quot;&gt;</span><br><span class="line">			&lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;</span><br><span class="line">		&lt;/transactionManager&gt;</span><br><span class="line">		&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">			&lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">		&lt;/dataSource&gt;</span><br><span class="line">	&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;	</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">#### environments</span><br><span class="line">* `default`</span><br><span class="line">	* 可以配置多个`environment`，通过`default=id`指定使用哪一个</span><br><span class="line"></span><br><span class="line">#### transactionManager</span><br><span class="line">* 如果使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖此配置</span><br><span class="line">* `type`</span><br><span class="line">	* `JDBC`</span><br><span class="line">		* 直接使用了 JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域</span><br><span class="line">	* `MANAGED`</span><br><span class="line">		* 几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。例如: </span><br><span class="line">			* `&lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;`</span><br><span class="line"></span><br><span class="line">#### dataSource</span><br><span class="line">* mybatis的连接池配置</span><br><span class="line">* `type`</span><br><span class="line">	* `UNPOOLED`</span><br><span class="line">		* 采用传统的获取连接的方式，虽然也实现了`javax.sql.DataSource`接口，但并没有使用池的思想</span><br><span class="line">	* `POOLED`</span><br><span class="line">		* 采用传统的`javax.sql.DataSource`规范中的连接池，mybatis中有规范的实现</span><br><span class="line">	* `JNDI`</span><br><span class="line">		* 采用服务器提供的JNDI技术实现，来获取`DataSource`对象，不同的服务器所能拿到的`DataSource`是不同的</span><br><span class="line">		* 注意：如果不上web或者maven的war工程，不能使用。</span><br><span class="line">		* tomcat服务器，采用的是dbcp连接池。</span><br><span class="line"></span><br><span class="line">### mappers</span><br><span class="line">* 告诉 MyBatis 到哪里去找映射文件</span><br><span class="line">1. 相对于类路径的资源引用</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><mappers><br>    <mapper resource="org/mybatis/builder/AuthorMapper.xml"><br>    <mapper resource="org/mybatis/builder/BlogMapper.xml"><br>    <mapper resource="org/mybatis/builder/PostMapper.xml"><br></mapper></mapper></mapper></mappers><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 使用完全限定资源定位符（包括 file:/// 的 URL）</span><br></pre></td></tr></table></figure></p>
<p><mappers><br>    <mapper url="file:///D:/config/User.xml"><br></mapper></mappers><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3. 使用映射器接口的全限定名</span><br><span class="line">	* 要求mapper接口和mapper映射文件要名称相同，且放到同一个目录下</span><br></pre></td></tr></table></figure></p>
<p><mappers><br>    <mapper class="org.mybatis.builder.AuthorMapper"><br>    <mapper class="org.mybatis.builder.BlogMapper"><br>    <mapper class="org.mybatis.builder.PostMapper"><br></mapper></mapper></mapper></mappers><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4. 包名（推荐）</span><br><span class="line">	* 将包内的映射器接口实现全部注册为映射器</span><br><span class="line">	* 要求mapper接口和mapper映射文件要名称相同，且放到同一个目录下</span><br></pre></td></tr></table></figure></p>
<p><mappers><br>    <package name="org.mybatis.builder"><br></package></mappers><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 映射xml配置</span><br></pre></td></tr></table></figure></p>
<p><mapper></mapper></p>
<pre><code>* cache – 给定命名空间的缓存配置。
* cache-ref – 其他命名空间缓存配置的引用。
* resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。
* sql – 可被其他语句引用的可重用语句块。
* insert – 映射插入语句
* update – 映射更新语句
* delete – 映射删除语句
* select – 映射查询语句
</code></pre><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### sql语句书写</span><br><span class="line">* `#&#123;&#125;`</span><br><span class="line">	* 表示一个占位符</span><br><span class="line">	* 如果该参数是简单类型，那么#&#123;&#125;里面的参数名称可以任意</span><br><span class="line">	* 默认情况下,使用 #&#123;&#125; 格式的语法会导致 MyBatis 创建 PreparedStatement 参数并安全地设置参数（就像使用 ? 一样，预编译)</span><br><span class="line">* `$&#123;&#125;`</span><br><span class="line">	* 表示一个sql的连接符</span><br><span class="line">	* 如果该参数是简单类型，那么$&#123;&#125;里面的参数名称必须是value</span><br><span class="line">	*  `$&#123;&#125;`这种写法存在sql注入的风险，所以要慎用！！</span><br><span class="line">	*  有时你就是想直接在 SQL 语句中插入一个不转义的字符串。比如，像 ORDER BY，$&#123;&#125;会原样输出</span><br><span class="line">		*  `order by $(columName)`</span><br><span class="line"></span><br><span class="line">### select</span><br><span class="line">* `id`</span><br><span class="line">	* 在命名空间中唯一的标识符，可以被用来引用这条语句</span><br><span class="line">* `parameterType`</span><br><span class="line">	* 将会传入这条语句的参数类的完全限定名或别名</span><br><span class="line">* `resultType`</span><br><span class="line">	* 从这条语句中返回的期望类型的类的完全限定名或别名。注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。（即集合泛型）</span><br><span class="line">	* 使用 resultType 或 resultMap，但不能同时使用。</span><br><span class="line">* `resultMap`</span><br><span class="line">	* 外部 resultMap 的命名引用</span><br><span class="line"></span><br><span class="line">### insert update delete</span><br><span class="line">#### 添加并查询自增主键</span><br></pre></td></tr></table></figure></p>
<p><insert id="insertUser" parametertype="cn.an.domain.User"><br>    <selectkey keyproperty="id" resulttype="int" order="AFTER"><br>        SELECT LAST_INSERT_ID()<br>    </selectkey><br>    INSERT INTO USER(username,birthday,sex,address)<br>    VALUES(#{username},#{birthday},#{sex},#{address})<br></insert><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* `selectKey`</span><br><span class="line">	* 查询主键，在标签内需要输入查询主键的sql</span><br><span class="line">* `keyProperty`</span><br><span class="line">	* pojo类的主键字段名</span><br><span class="line">* `order`</span><br><span class="line">	* 指定查询主键的sql和insert语句的执行顺序，相当于insert语句来说</span><br><span class="line">	* `BEFORE`</span><br><span class="line">		* 会首先选择主键，设置 keyProperty 然后执行插入语句</span><br><span class="line">	* `AFTER`</span><br><span class="line">		* 先执行插入语句，然后是 selectKey 元素</span><br><span class="line">* `LAST_INSERT_ID`</span><br><span class="line">	* 该函数是mysql的函数，获取自增主键的ID，它必须配合insert语句一起使用</span><br><span class="line"></span><br><span class="line">#### 添加并查询自增主键之uuid</span><br></pre></td></tr></table></figure></p>
<p><insert id="insertUser2" parametertype="cn.an.domain.User"><br>    <selectkey keyproperty="id" resulttype="string" order="BEFORE"><br>        SELECT UUID()<br>    </selectkey><br>    INSERT INTO USER(id,username,birthday,sex,address)<br>    VALUES(#{id},#{username},#{birthday},#{sex},#{address})<br></insert><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* `order`</span><br><span class="line">	* 先要有uuid才能insert，所以order为`before`</span><br><span class="line"></span><br><span class="line">### sql</span><br><span class="line">* 这个元素可以被用来定义可重用的 SQL 代码段，可以包含在其他语句中。它可以被静态地(在加载参数) 参数化. 不同的属性值通过包含的实例变化</span><br><span class="line"></span><br><span class="line">### resultMap</span><br></pre></td></tr></table></figure></p>
<p><resultmap id="userResultMap" type="User"><br>    <id property="id" column="user_id"><br>    <result property="username" column="user_name"><br>    <result property="password" column="hashed_password"><br></result></result></id></resultmap><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 输入映射(参数类型)</span><br><span class="line">## 基本类型</span><br><span class="line">## pojo类</span><br><span class="line">## pojo包装类</span><br><span class="line">* 如果查询条件对应的属性在不同的pojo类中需要定义一个包装pojo类，此类中的属性对应不同的pojo类</span><br><span class="line">* 通过对象导航图来使用。</span><br><span class="line"></span><br><span class="line">## Map</span><br><span class="line">* 同传递POJO对象一样，map的key相当于pojo的属性</span><br><span class="line"></span><br><span class="line"># 输出映射(结果类型)</span><br><span class="line">## resultType</span><br><span class="line">* 使用resultType进行结果映射时需要查询出的列名与映射属性名一致</span><br><span class="line">* **注**</span><br><span class="line">	* 查询出的列名和映射的对象的属性名一致，才能映射成功</span><br><span class="line">	* 如果查询的列名和对象的属性名全部不一致，那么映射的对象为空。</span><br><span class="line">	* 如果查询的列名和对象的属性名有一个一致，那么映射的对象不为空，但是只有映射正确那一个属性才有值。</span><br><span class="line">	* 如果查询的sql的列名有别名，那么这个别名就是和属性映射的列名</span><br><span class="line"></span><br><span class="line">### 基本类型</span><br><span class="line">* 查询的列必须是一列，才能映射为简单类型</span><br><span class="line">* 如查询总数</span><br><span class="line">	</span><br><span class="line">### pojo类型</span><br><span class="line">### pojo列表</span><br><span class="line"></span><br><span class="line">## resultMap</span><br><span class="line">* 使用resultMap进行结果映射时，不需要查询的列名和映射的属性名必须一致。但是需要声明一个resultMap，来对列名和属性名进行映射</span><br><span class="line">* extends：可以继承一个已有的resultMap</span><br><span class="line">	* 继承时，只能继承type类型是一样的resultMap</span><br><span class="line"></span><br><span class="line"># 动态sql</span><br><span class="line">## if</span><br></pre></td></tr></table></figure></p>
<p><select id="findActiveBlogLike" resulttype="Blog"><br>    SELECT * FROM BLOG<br>    WHERE<br>    <if test="state != null"><br>        state = #{state}<br>    </if><br>    <if test="title != null"><br>        AND title like #{title}<br>    </if><br>    <if test="author != null and author.name != null"><br>        AND author_name like #{author.name}<br>    </if><br></select><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## where</span><br><span class="line">* if标签的问题在于</span><br><span class="line">	* 如果这些条件没有一个能匹配上</span><br><span class="line">		* 则最终sql语句`SELECT * FROM BLOG WHERE`</span><br><span class="line">	* 如果仅仅第二个条件匹配</span><br><span class="line">		* 则最终sql语句`SELECT * FROM BLOG WHERE AND title like ‘someTitle’`</span><br><span class="line">	* 都是错误的</span><br><span class="line">* where标签可以解决</span><br></pre></td></tr></table></figure></p>
<p><select id="findActiveBlogLike" resulttype="Blog"><br>    SELECT * FROM BLOG<br>    <where><br>        <if test="state != null"><br>                 state = #{state}<br>        </if><br>        <if test="title != null"><br>                AND title like #{title}<br>        </if><br>        <if test="author != null and author.name != null"><br>                AND author_name like #{author.name}<br>        </if><br>    </where><br></select><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	* where标签只有在有一个或一个以上的if有值的情况下才去插入“WHERE”子句，并且若最后的内容是“AND”或“OR”开头的，where 元素也知道如何将他们去除</span><br><span class="line">	* 即where可以自动判断去掉前and/or</span><br><span class="line"></span><br><span class="line">## sql片段(使用`&lt;sql&gt;`标签)</span><br></pre></td></tr></table></figure></p>
<p><sql id="sqlID"><br>    code…<br></sql><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* sql片段内可以定义sql语句中的任何部分</span><br><span class="line">* sql片段内最好不要包含select where..关键字</span><br><span class="line">* 引入sql片段</span><br><span class="line">	* `&lt;include refid=&quot;sqlID&quot;/&gt;`</span><br><span class="line"></span><br><span class="line">## foreach</span><br><span class="line">* 可以循环传入参数值</span><br><span class="line">* 需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候</span><br></pre></td></tr></table></figure></p>
<p><select id="selectPostIn" resulttype="domain.blog.Post"><br>    SELECT *<br>    FROM POST P<br>    WHERE ID in<br>    <foreach item="item" index="index" collection="list" open="(" separator="," close=")"></foreach></select></p>
<pre><code>        #{item}
&lt;/foreach&gt;
</code></pre><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	* `collection`</span><br><span class="line">		* pojo类</span><br><span class="line">			* 类中数组/集合属性的属性名称</span><br><span class="line">		* 数组</span><br><span class="line">			* array</span><br><span class="line">		* 集合</span><br><span class="line">			* list</span><br><span class="line">		* 注</span><br><span class="line">			* 即如果参数是一个对像，则collection写的是对象中的字段名，如果参数是数组，则collection写的是array，集合写的是list</span><br><span class="line">			* 原因（安）</span><br><span class="line">				* mybatis在注入参数时，没有使用参数名称</span><br><span class="line">				* 而是使用一个map，存入参数</span><br><span class="line">				* pojo</span><br><span class="line">					* put(字段,值)</span><br><span class="line">				* 数组</span><br><span class="line">					* put(array,值)</span><br><span class="line">				* 集合</span><br><span class="line">					* put(list,值)</span><br><span class="line">	* `item`</span><br><span class="line">		* 为遍历的结果声明一个变量名</span><br><span class="line">	* `open`</span><br><span class="line">		* 遍历开始时需要拼接的字符串</span><br><span class="line">	* `close`</span><br><span class="line">		* 遍历结束时需要拼接的字符串</span><br><span class="line">	* `separator`</span><br><span class="line">		* 遍历中间需要拼接的连接符</span><br><span class="line">	</span><br><span class="line"># 高级结果映射</span><br><span class="line">## 一对一</span><br><span class="line">### resultType</span><br><span class="line">* 在主pojo类中（或者扩展类(继承主pojo类)）添加缺少的另一个pojo类查询列的字段。这样就形成了查询列与属性的一一对应</span><br><span class="line"></span><br><span class="line">### resultMap</span><br><span class="line">* 在主pojo类中（或者扩展类(继承主pojo类)）添加另一个pojo类的引用</span><br></pre></td></tr></table></figure></p>
<p><resultmap id="" type="主pojo类的全类名"><br>    <id property="" column=""><br>    <result property="" column=""><br>    <result property="" column=""><br>    <association property="主pojo类中表示引用关联pojo类的字段" column="根据id查询时所需要的参数的值，可以省略" javatype="关联pojo类的全类名"><br>        <!-- id标签：建议在关联查询时必须写上，不写不会报错，但是会影响性能 --><br>        <id column="" property=""><br>        <result column="" property=""><br>        <result column="" property=""><br>    </result></result></id></association><br></result></result></id></resultmap><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	* `association`</span><br><span class="line">		* 一对一关联映射 </span><br><span class="line">	* `property`</span><br><span class="line">		* 类的字段</span><br><span class="line">	* `column`</span><br><span class="line">		* 查询结果的类名（即查询语句中查询的列名，有别名为别名。）</span><br><span class="line"></span><br><span class="line">## 多对一</span><br><span class="line">* mybatis中多对一可以看作是一对一</span><br><span class="line"></span><br><span class="line">##  一对多</span><br><span class="line">### resultMap</span><br><span class="line">* 在一方中添加多方的引用（集合）</span><br></pre></td></tr></table></figure></p>
<p><resultmap id="" type="一方类的全类名"><br>    <id property="" column=""><br>    <result property="" column=""><br>    <result property="" column=""><br>    <collection property="一方类中表示多方引用的集合字段" oftype="集合字段的泛型（即多方的全类名）"><br>        <id column="" property=""><br>        <result column="" property=""><br>        <result column="" property=""><br>    </result></result></id></collection><br></result></result></id></resultmap><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	* `collection`</span><br><span class="line">		* 映射一对多关系</span><br><span class="line"></span><br><span class="line">## 多对多</span><br><span class="line">* 多对多映射是一对多映射的特例</span><br><span class="line">* 需要一张中间表</span><br><span class="line"></span><br><span class="line">### resultMap</span><br><span class="line">* 每一方都持有对方的引用（集合）</span><br></pre></td></tr></table></figure></p>
<p><resultmap id="" type="主pojo类的全类名"><br>    <id property="" column=""><br>    <result property="" column=""><br>    <result property="" column=""><br>    <collection property="主pojo类中表示多方引用的集合字段" oftype="集合字段的泛型（即多方的全类名）"><br>        <id column="" property=""><br>        <result column="" property=""><br>        <result column="" property=""><br>    </result></result></id></collection><br></result></result></id></resultmap><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 注解</span><br><span class="line">## 常用注解</span><br><span class="line">* `@Insert`</span><br><span class="line">* `@Update`</span><br><span class="line">* `@Delete`</span><br><span class="line">* `@Select`</span><br><span class="line">* `@Result`</span><br><span class="line">	* 结果集封装</span><br><span class="line">* `@Results`</span><br><span class="line">	* 封装多个结果集，可以和`@Result`一起用</span><br></pre></td></tr></table></figure></p>
<p>@Results(id=””, value={<br>            @Result(id=true, column=””, property=””),<br>            @Result(column=””, property=””)<br>    …<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* `@ResultMap`</span><br><span class="line">	* 引用`@Results`定义的封装</span><br></pre></td></tr></table></figure></p>
<p>@ResultMap(value={“@Results的id”})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">* `@One`</span><br><span class="line">	* 一对一结果集封装</span><br><span class="line">* `@Many`</span><br><span class="line">	* 一对多结果集封装</span><br><span class="line">* `@SelectProvider`</span><br><span class="line">	* 动态sql映射</span><br><span class="line">* `@CacheNamespace`</span><br><span class="line">	* 二级缓存 </span><br><span class="line"></span><br><span class="line"># 延迟加载(懒加载)</span><br><span class="line">* 通常一对一，多对一需要立即加载，一对多，多对多需要延迟加载</span><br><span class="line"></span><br><span class="line">## 配置延迟加载</span><br><span class="line">* 全局xml配置文件的setting</span><br><span class="line">	* `&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;`</span><br><span class="line">		* 开启延迟加载，默认为true</span><br><span class="line">	* `&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;`</span><br><span class="line">		* 设置积极的懒加载，默认true</span><br><span class="line"></span><br><span class="line">## 一对一/多对一</span><br><span class="line">* `&lt;association property=&quot;&quot; select=&quot;namespace.selectID&quot; column=&quot;延迟加载时必须写&quot; javaType=&quot;&quot;&gt;&lt;/association&gt;`</span><br><span class="line"></span><br><span class="line">## 一对多/多对多</span><br><span class="line">* `&lt;collection property=&quot;&quot; select=&quot;namespace.selectID&quot; column=&quot;&quot; ofType=&quot;&quot;&gt;`</span><br><span class="line"></span><br><span class="line"># 缓存</span><br><span class="line">## 概述</span><br><span class="line">* 缓存即存于内存中的临时数据，为了减少和数据库的交互次数，提高效率</span><br><span class="line">* 适合缓存的数据</span><br><span class="line">	* 经常使用且不经常改变的。</span><br><span class="line">	* 数据正确与否对最终结果影响不大的。</span><br><span class="line">		* 商品库存，银行汇率，股市牌价...对结果影响大的不适合缓冲。</span><br><span class="line"></span><br><span class="line">## 一级缓存</span><br><span class="line">* 一级缓存指的就是SqlSession对象的缓存。</span><br><span class="line">* 在SqlSession中有一个数据区域，是map结构，这个区域就是一级缓存区域。</span><br><span class="line">	* 一级缓存中的key</span><br><span class="line">		* 由sql语句、条件、statement等信息组成一个唯一值。</span><br><span class="line">	* 一级缓存中的value</span><br><span class="line">		* 就是查询出的结果对象</span><br><span class="line">* 一级缓存是默认使用的</span><br><span class="line"></span><br><span class="line">### 原理</span><br><span class="line">* 第一次查询查询数据库并写入缓存区域</span><br><span class="line">* 第二次查询读取缓存区域</span><br><span class="line"></span><br><span class="line">### 清空缓存</span><br><span class="line">1. sqlsession关闭`close()`</span><br><span class="line">2. `clearCache()`</span><br><span class="line">	* 清空缓存。</span><br><span class="line">3. 增删改commit会清空缓存</span><br><span class="line"></span><br><span class="line">## 二级缓存</span><br><span class="line">* 二级缓存指的是mybatis中SqlSessionFactory对象的缓存</span><br><span class="line">* 同一个SqlSessionFactory创建的SqlSession共享缓存数据。</span><br><span class="line">* 二级缓存中存放的是数据而不是对象</span><br><span class="line">	* 多次查询时对象不是同一个，数据相同。</span><br><span class="line">* 二级缓存需要手动开启。</span><br><span class="line"></span><br><span class="line">### 开启</span><br><span class="line">* `&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;`</span><br><span class="line">	* 二级缓存总开关</span><br><span class="line">* `&lt;cache type=&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;/&gt;`</span><br><span class="line">	* 在映射文件中开启二级缓存</span><br><span class="line">	* 默认使用PerpetualCache 可以省略type</span><br><span class="line"></span><br><span class="line">### 禁用</span><br><span class="line">* `&lt;select useCache=&quot;false&quot;&gt;`</span><br><span class="line">	* 在映射文件中select标签上</span><br><span class="line">	* 默认true</span><br><span class="line"></span><br><span class="line">### 刷新缓存</span><br><span class="line">* `&lt;select flushCache=&quot;true&quot;&gt;`</span><br><span class="line">	* 在映射文件中select标签上</span><br><span class="line">	* 在select中默认false </span><br><span class="line">	* 增删改中默认 true</span><br><span class="line">	* 相当于将缓存失效。?</span><br><span class="line"></span><br><span class="line">### 原理</span><br><span class="line">* 第一个sqlSession执行xxxMapper查询写入xxxMapper的二级缓存区域</span><br><span class="line">	* sqlSession关闭时才会将数据写入二级缓存</span><br><span class="line">* 第二个sqlSession执行xxxMapper查询读取二级缓存区域</span><br><span class="line">* 其它sqlSession执行xxxMapper（插入，更新，删除）会清除二级缓存</span><br><span class="line"></span><br><span class="line">### 整合Ehcache</span><br><span class="line">* Mybatis本身是一个持久层框架，它不是专门的缓存框架，所以它对缓存的实现不够好，不能支持分布式。</span><br><span class="line">* Ehcache是一个分布式的缓存框架</span><br><span class="line"></span><br><span class="line">#### 分布式</span><br><span class="line">* 系统为了提高性能，通常会对系统采用分布式部署（集群部署方式）</span><br><span class="line"></span><br><span class="line">#### 整合思路</span><br><span class="line">* Cache是一个接口，它的默认实现是mybatis的PerpetualCache。如果想整合mybatis的二级缓存，那么实现Cache接口即可</span><br><span class="line"></span><br><span class="line">#### 整合步骤</span><br><span class="line">1. jar包</span><br><span class="line">2. 设置映射文件中cache标签的type值为ehcache的实现类</span><br><span class="line">3. 添加ehcache的配置文件</span><br><span class="line">	</span><br><span class="line">#### 应用场景</span><br><span class="line">* 对于访问响应速度要求高，但是实时性不高的查询，可以采用二级缓存技术。</span><br><span class="line">* 注意</span><br><span class="line">	* 在使用二级缓存的时候，要设置一下刷新间隔（cache标签中有一个flashInterval属性）来定时刷新二级缓存，这个刷新间隔根据具体需求来设置，比如设置30分钟、60分钟等，单位为毫秒。</span><br><span class="line"></span><br><span class="line">#### 局限性</span><br><span class="line">* Mybatis二级缓存对细粒度的数据，缓存实现不好。</span><br><span class="line">* 场景</span><br><span class="line">	* 对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次查询都是最新的商品信息，此时如果使用二级缓存，就无法实现当一个商品发生变化只刷新该商品的缓存信息而不刷新其他商品缓存信息，因为二级缓存是mapper级别的，当一个商品的信息发送更新，所有的商品信息缓存数据都会清空。</span><br><span class="line">* 解决此类问题</span><br><span class="line">	* 需要在业务层根据需要对数据有针对性的缓存。</span><br><span class="line">	* 比如可以对经常变化的 数据操作单独放到另一个namespace的mapper中</span><br><span class="line"></span><br><span class="line"># 整合spring</span><br><span class="line">## 思路</span><br><span class="line">* 数据源信息交给spring管理</span><br><span class="line">* SqlSessionFactory交给spring进行单例管理</span><br><span class="line">* 由spring来管理原始dao的实现类或者mapper代理的代理类</span><br><span class="line">	* 接口类名与映射文件同名</span><br><span class="line">	* 接口类名与映射文件同一目录</span><br><span class="line">	* 映射文件namespace是接口的全限定名</span><br><span class="line">	* 接口方法名与映射statement的id一致</span><br><span class="line"></span><br><span class="line">## jar包</span><br><span class="line">* Mysql的驱动包</span><br><span class="line">* Mybatis的核心包和依赖包</span><br><span class="line">* Mybatis和spring的整合包</span><br><span class="line">* Spring的包</span><br><span class="line">* dbcp数据库连接池包</span><br><span class="line"></span><br><span class="line">## 配置applicationContext.xml</span><br></pre></td></tr></table></figure></p>
<!-- 引用java配置文件 -->
<p>&lt;context:property-placeholder location=”db.properties” /&gt;</p>
<!-- 配置数据源 -->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"><br>    <property name="driverClassName" value="${db.driver}"><br>    <property name="url" value="${db.url}"><br>    <property name="username" value="${db.username}"><br>    <property name="password" value="${db.password}"><br>    <property name="maxActive" value="10"><br>    <property name="maxIdle" value="5"><br></property></property></property></property></property></property></bean>

<!-- 配置SqlSessionFactory -->
<p><bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"><br>    <!-- 指定mybatis的全局配置文件的路径 --><br>    <property name="configLocation" value="SqlMapConfig.xml"></property><br>    <!-- 数据源 --><br>    <property name="dataSource" ref="dataSource"></property><br></bean><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## 原始dao</span><br><span class="line">* daoImpl继承`SqlSessionDaoSupport`</span><br><span class="line">	* 我觉得类似于`JdbcDaoSupport`和`HibernateDaoSupport`</span><br><span class="line">* dao中可以获取`SqlSession`</span><br><span class="line">	* `this.getSqlSession()`</span><br><span class="line">* 在配置中配置dao`bean`并注入`SqlSessionFactory`</span><br><span class="line">	* SqlSessionDaoSupport中有set方法</span><br><span class="line"></span><br><span class="line">## Mapper</span><br><span class="line">### 配置xxxMapper代理类</span><br></pre></td></tr></table></figure></p>
<p><bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"><br>    <!-- 设置代理类的接口 --><br>    <property name="mapperInterface" value="com.itheima.ms.mapper.UserMapper"></property><br>    <!-- 依赖注入SqlSessionFactory --><br>    <property name="sqlSessionFactory" ref="sqlSessionFactory"></property><br></bean><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 批量配置代理类</span><br></pre></td></tr></table></figure></p>
<!--默认代理类 id为类名首字母小写-->
<p><bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"><br>    <!-- 配置扫描的包 --><br>    <property name="basePackage" value="com.itheima.ms.mapper"></property></bean></p>
<pre><code>&lt;!-- 默认不需要配置SqlSessionFactory（只有一个SqlSessionFactory时），单独配置也可以 --&gt;
&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
</code></pre><p><br><code>`</code></p>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-SpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-SpringMVC/" itemprop="url">
                  xd-SpringMVC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:40:23" itemprop="dateCreated datePublished" datetime="2018-12-11T00:40:23+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-29 01:36:39" itemprop="dateModified" datetime="2019-01-29T01:36:39+08:00">2019-01-29</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>Springmvc是一个web层mvc框架，类似struts2</li>
</ul>
<h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><p><img src="https://gitee.com/3noanswer/pics/raw/master/springmvc流程图.png" alt=""></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置前端控制器：DispatcherServlet"><a href="#配置前端控制器：DispatcherServlet" class="headerlink" title="配置前端控制器：DispatcherServlet"></a>配置前端控制器：DispatcherServlet</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认加载<ul>
<li><code>WEB-INF/&lt;servlet-name&gt;标签的值-servlet.xml</code></li>
<li>上例中即默认加载<code>WEB-INF/springMVC-servlet.xml</code></li>
</ul>
</li>
<li><code>&lt;url-pattern&gt;</code><ul>
<li><code>/*</code>（不建议）<ul>
<li>拦截所有，包含<code>.jsp</code>，包含(.js .png .css…..)</li>
</ul>
</li>
<li><code>/</code>（建议）<ul>
<li>拦截所有，不包含<code>.jsp</code>，包含(.js .png .css…..)</li>
<li>多用在前台</li>
</ul>
</li>
<li><code>*.action/do</code><ul>
<li>拦截指定扩展名</li>
<li>多用在后台</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="配置注解映射器和适配器"><a href="#配置注解映射器和适配器" class="headerlink" title="配置注解映射器和适配器"></a>配置注解映射器和适配器</h2><ul>
<li><code>&lt;mvc:annotation-driven/&gt;</code><ul>
<li>相当于配置了<code>RequestMappingHandlerMapping</code>和<code>RequestMappingHandlerAdapter</code></li>
</ul>
</li>
</ul>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="springmvc默认加载的组件"><a href="#springmvc默认加载的组件" class="headerlink" title="springmvc默认加载的组件"></a>springmvc默认加载的组件</h2><ul>
<li>在<code>DispatcherServlet.properties</code>中</li>
</ul>
<h2 id="前端控制器"><a href="#前端控制器" class="headerlink" title="前端控制器"></a>前端控制器</h2><ul>
<li><code>DispatcherServlet</code><ul>
<li>调度，指挥谁该干什么了</li>
</ul>
</li>
</ul>
<h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><ul>
<li><code>Handler</code><ul>
<li>干活的具体内容，干完会返回ModelAndView给处理器适配器</li>
<li>即业务内容，我们编写</li>
</ul>
</li>
</ul>
<h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><ul>
<li><code>HandlerMapping</code><ul>
<li>负责找到需要哪个Handler做事情</li>
</ul>
</li>
</ul>
<h3 id="编程式映射器"><a href="#编程式映射器" class="headerlink" title="编程式映射器"></a>编程式映射器</h3><h4 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h4><ul>
<li>根据请求url去匹配自定义Handler bean的name属性，从而获取Controller(Handler)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</span><br><span class="line">&lt;!-- 配置自定义Controler --&gt;</span><br><span class="line">&lt;bean name=&quot;/hello.do&quot; class=&quot;cn.an.controller.MyController&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="SimpleUrlHandlerMaping"><a href="#SimpleUrlHandlerMaping" class="headerlink" title="SimpleUrlHandlerMaping"></a>SimpleUrlHandlerMaping</h4><ul>
<li>根据请求url匹配key，key又根据value即Controller的id找到Controller<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;mappings&quot;&gt;</span><br><span class="line">	  &lt;props&gt;</span><br><span class="line">	    &lt;prop key=&quot;/abc.do&quot;&gt;myController&lt;/prop&gt;</span><br><span class="line">	    &lt;prop key=&quot;/ss.do&quot;&gt;xx&lt;/prop&gt;</span><br><span class="line">	    &lt;prop key=&quot;/mine.do&quot;&gt;yy&lt;/prop&gt;</span><br><span class="line">	  &lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 配置自定义Controler --&gt;</span><br><span class="line">&lt;bean id=&quot;myController&quot; class=&quot;cn.an.controller.MyController&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="注解式映射器"><a href="#注解式映射器" class="headerlink" title="注解式映射器"></a>注解式映射器</h3><h4 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h4><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><ul>
<li><code>HandlerAdapter</code><ul>
<li>负责执行Handler</li>
</ul>
</li>
</ul>
<h3 id="编程式适配器"><a href="#编程式适配器" class="headerlink" title="编程式适配器"></a>编程式适配器</h3><h4 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h4><ul>
<li>Handle必须实现<code>HttpRequesHandler</code>接口</li>
</ul>
<h4 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h4><ul>
<li>Handler必须实现<code>Controller</code>接口</li>
</ul>
<h3 id="注解式适配器"><a href="#注解式适配器" class="headerlink" title="注解式适配器"></a>注解式适配器</h3><h4 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h4><h2 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h2><ul>
<li><code>ViewResolver</code><ul>
<li>负责解析逻辑视图，返回Viwe对象</li>
</ul>
</li>
</ul>
<h3 id="InternalResourceViewResolver"><a href="#InternalResourceViewResolver" class="headerlink" title="InternalResourceViewResolver"></a>InternalResourceViewResolver</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果设置的是逻辑视图，则最终真正的物理视图=<code>前缀(prefix)+逻辑视图+后缀(suffix)</code></li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="定义在类上"><a href="#定义在类上" class="headerlink" title="定义在类上"></a>定义在类上</h4><ul>
<li>第一级的访问目录</li>
<li><code>@RequestMapping(&quot;/user&quot;)</code><ul>
<li>是为了确定哪个controller的方法</li>
<li>请求路径为<code>/user/xxx</code></li>
</ul>
</li>
</ul>
<h4 id="定义在方法上"><a href="#定义在方法上" class="headerlink" title="定义在方法上"></a>定义在方法上</h4><ul>
<li>第二级的访问目录</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>String[] value</code><ul>
<li>与<code>path</code>通用，指定请求url</li>
</ul>
</li>
<li><code>String[] path</code></li>
<li><code>RequestMethod[] method</code><ul>
<li>确定请求方式，不写表示所有请求方式都有用</li>
<li><code>RequestMethod.POST/RequestMethod.GET</code></li>
</ul>
</li>
<li><code>String[] params</code><ul>
<li>用于指定限制请求参数的条件，支持简单的表达式。要求请求参数的key和value必须和配置的一样。</li>
<li><code>params={&quot;username&quot;}</code><ul>
<li>表示请求参数必须有username</li>
</ul>
</li>
<li><code>params={&quot;age=11&quot;}</code><ul>
<li>表示请求参数必须有age=11</li>
</ul>
</li>
<li><code>params={&quot;money!100&quot;}</code><ul>
<li>表示请求参数必须有money且值不为100</li>
</ul>
</li>
</ul>
</li>
<li><code>String[] headers</code><ul>
<li>发送的请求中必须包含的请求头</li>
<li><code>headers{&quot;Accept&quot;}</code><ul>
<li>表示请求头中必须有Accept</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@RequestParam(value=&quot;username&quot;,required=false)String name) &#123;</span><br><span class="line">	System.out.println(name);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>把请求中的指定名称的参数传递给控制器中的形参赋值</li>
</ul>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>请求参数中的名称</li>
</ul>
</li>
<li><code>required</code><ul>
<li>请求参数中是否必须提供此参数</li>
<li>默认true，必须提供</li>
</ul>
</li>
</ul>
<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@RequestBody String body) &#123;</span><br><span class="line">	System.out.println(body);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于获取请求体的内容（注意：get方法不可以）</li>
</ul>
<h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>required</code><ul>
<li>是否必须有请求体，默认值是true</li>
</ul>
</li>
</ul>
<h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello/&#123;id&#125;&quot;)</span><br><span class="line">public String sayHello(@PathVariable(value=&quot;id&quot;) String id) &#123;</span><br><span class="line">	System.out.println(id);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ul>
<li>拥有绑定url中的占位符的<ul>
<li><code>/delete/{id}</code><ul>
<li>{id}就是占位符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>指定url中的占位符名称</li>
</ul>
</li>
</ul>
<h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@RequestHeader(value=&quot;Accept&quot;) String header) &#123;</span><br><span class="line">	System.out.println(header);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><ul>
<li>获取指定请求头的值</li>
</ul>
<h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>请求头的名称</li>
</ul>
</li>
</ul>
<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@CookieValue(value=&quot;JSESSIONID&quot;) String cookieValue) &#123;</span><br><span class="line">	System.out.println(cookieValue);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于获取指定cookie的名称的值</li>
</ul>
<h3 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>cookie的名称</li>
</ul>
</li>
</ul>
<h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><h3 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h3><ul>
<li>方法上<ul>
<li>表示当前方法会在控制器方法执行前先执行</li>
</ul>
</li>
<li>参数上<ul>
<li>获取指定的数据给参数赋值</li>
</ul>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据</li>
</ul>
<h2 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h2><h3 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于多次执行控制器方法间的参数共享</li>
</ul>
<h3 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>指定存入属性的名称</li>
</ul>
</li>
</ul>
<h1 id="请求参数绑定"><a href="#请求参数绑定" class="headerlink" title="请求参数绑定"></a>请求参数绑定</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Springmvc通过命令设计模式接受页面参数</li>
<li>springmvc是单例的没有成员变量，把需要传递的参数放入方法中，请求这个方法时，会自动封装参数</li>
</ul>
<h2 id="默认参数绑定"><a href="#默认参数绑定" class="headerlink" title="默认参数绑定"></a>默认参数绑定</h2><ul>
<li><code>Request</code></li>
<li><code>Response</code></li>
<li><code>Session</code></li>
<li><code>Model</code></li>
<li><code>ModelMap</code></li>
</ul>
<h2 id="基本类型-amp-String"><a href="#基本类型-amp-String" class="headerlink" title="基本类型 &amp; String"></a>基本类型 &amp; String</h2><ol>
<li>请求参数名与方法形参一致</li>
<li>不一致<ul>
<li><code>@RequestParam(value=&quot;id&quot;,required=false,defaultValue=&quot;1&quot;)</code><ul>
<li><code>@RequestParam</code><ul>
<li>用于处理简单类型的绑定</li>
</ul>
</li>
<li>value<ul>
<li>绑定指定名称的请求参数</li>
</ul>
</li>
<li>required<ul>
<li>true<ul>
<li>默认，表示请求中一定要有相应的参数，否则报错</li>
</ul>
</li>
</ul>
</li>
<li>defaultValue<ul>
<li>表示请求中如果没有同名参数时的默认值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h2><ul>
<li>方法形参名称没什么用</li>
<li>方法形参的POJO类型中的字段与页面的name属性相同</li>
</ul>
<h2 id="POJO包装类"><a href="#POJO包装类" class="headerlink" title="POJO包装类"></a>POJO包装类</h2><ul>
<li>类似POJO类，多了一步导航</li>
<li>对于包装类中的POJO，表单name使用对象导航图<ul>
<li><code>name=&quot;user.name&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="自定义参数类型"><a href="#自定义参数类型" class="headerlink" title="自定义参数类型"></a>自定义参数类型</h2><h3 id="转换日期"><a href="#转换日期" class="headerlink" title="转换日期"></a>转换日期</h3><ol>
<li>创建自定义转换器，实现<code>Convertor&lt;S,T&gt;</code></li>
<li><p><code>springmvc.xml</code>将自定义转换器加入到转换器工厂<code>FormattingConversionServiceFactoryBean</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;转换器工厂id&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;converters&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;bean class=&quot;自定义转换器全类名&quot;/&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于参数绑定在适配器中，所以转换工厂配置在适配器上</p>
<ul>
<li><code>&lt;mvc:annotation-driven conversion-service=&quot;转换器工厂id&quot;/&gt;</code></li>
</ul>
</li>
</ol>
<h3 id="对传递参数去空格"><a href="#对传递参数去空格" class="headerlink" title="对传递参数去空格"></a>对传递参数去空格</h3><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>请求参数名与形参名一致即可<ul>
<li>如请求参数为ids则形参<code>Integer[] ids</code></li>
</ul>
</li>
<li>使用POJO包装类，持有数组类型的同名成员变量即可<ul>
<li>如请求参数为ids则POJO包装类中<code>private Integer[] ids</code></li>
</ul>
</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>方法中不能直接传递集合类型参数，可以使用pojo包装类<ul>
<li>页面中使用对象导航视图<ul>
<li><code>name=&quot;userList[0].username&quot;</code></li>
<li>索引使用循环标签的状态索引<code>varStatus=&quot;vs&quot;</code><ul>
<li><code>vs.index</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="post提交乱码"><a href="#post提交乱码" class="headerlink" title="post提交乱码"></a>post提交乱码</h1><ul>
<li>在<code>web.xml</code>中配置过滤器，<code>spring-web</code>中<code>CharacterEncodingFilter</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="获取Servlet原生API"><a href="#获取Servlet原生API" class="headerlink" title="获取Servlet原生API"></a>获取Servlet原生API</h1><ul>
<li>想获取谁直接在方法上添加相应的形参即可获取。</li>
</ul>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><ul>
<li>其实也是一种参数绑定(安)</li>
<li>方法中形参<ul>
<li><code>MultipartResolver picFile</code><ul>
<li><code>picFile</code>为表单上传name属性名</li>
</ul>
</li>
</ul>
</li>
<li>配置文件上传解析器(MultipartResolver接口实现类)<ul>
<li><code>CommonsMultipartResolver</code><ul>
<li>bean id 必须为<code>multipartResolver</code></li>
<li>可以通过属性设置控制上传大小。。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Controller返回值"><a href="#Controller返回值" class="headerlink" title="Controller返回值"></a>Controller返回值</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ol>
<li>指定逻辑视图的名称，根据视图解析器为物理视图的地址</li>
<li>SpringMVC框架提供的转发和重定向（不会走视图解析器，所以jsp写全路径）<ul>
<li>转发<ul>
<li><code>forward:转发的jsp路径</code></li>
</ul>
</li>
<li>重定向<ul>
<li><code>redirect:重定向的jsp路径</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><ul>
<li>方法形参<code>Model model</code><ul>
<li><code>model.addAttribute()</code></li>
</ul>
</li>
</ul>
<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><ul>
<li>默认跳转页面为注解<code>@RequestMapping(value=&quot;&quot;)</code>value属性的值<code>.jsp</code>，会找不到页面</li>
</ul>
<h3 id="视图-1"><a href="#视图-1" class="headerlink" title="视图"></a>视图</h3><ol>
<li>使用Servlet的api在方法内转发或者重定向到指定页面</li>
<li>如果是异步请求，则直接使用流响应即可。</li>
</ol>
<h3 id="数据-1"><a href="#数据-1" class="headerlink" title="数据"></a>数据</h3><ul>
<li>方法形参<code>Model model</code><ul>
<li><code>model.addAttribute()</code></li>
</ul>
</li>
</ul>
<h2 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h2><h3 id="视图-2"><a href="#视图-2" class="headerlink" title="视图"></a>视图</h3><ul>
<li><code>mv.setViewName()</code></li>
</ul>
<h3 id="数据-2"><a href="#数据-2" class="headerlink" title="数据"></a>数据</h3><ul>
<li><code>mv.addObject()</code></li>
</ul>
<h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><h2 id="异常处理思路"><a href="#异常处理思路" class="headerlink" title="异常处理思路"></a>异常处理思路</h2><ol>
<li>dao，service，controller出现异常都往上抛，最后抛给DispatcherServlet</li>
<li>DispatcherServlet<ul>
<li>有异常处理器，则交给异常处理器</li>
<li>无异常处理器，则什么都不做直接响应到页面</li>
</ul>
</li>
</ol>
<h2 id="springmvc的异常处理"><a href="#springmvc的异常处理" class="headerlink" title="springmvc的异常处理"></a>springmvc的异常处理</h2><ol>
<li>自定义异常类<ul>
<li>用于设置异常信息</li>
</ul>
</li>
<li><p>自定义异常处理器</p>
<ul>
<li>实现<code>HandlerExceptionResoler</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123;</span><br><span class="line">			// 自定义异常类</span><br><span class="line">			SysException e = null;</span><br><span class="line">			// 获取到异常对象</span><br><span class="line">			if(ex instanceof SysException) &#123;</span><br><span class="line">				e = (SysException) ex;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				e = new SysException(&quot;请联系管理员&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			ModelAndView mv = new ModelAndView();</span><br><span class="line">			// 存入错误的提示信息</span><br><span class="line">			mv.addObject(&quot;message&quot;, e.getMessage());</span><br><span class="line">			// 跳转的Jsp页面</span><br><span class="line">			mv.setViewName(&quot;error&quot;);</span><br><span class="line">			return mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在<code>springmvc.xml</code>中配置异常处理器bean</p>
</li>
</ol>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="拦截器-amp-过滤器"><a href="#拦截器-amp-过滤器" class="headerlink" title="拦截器 &amp; 过滤器"></a>拦截器 &amp; 过滤器</h2><ol>
<li>过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。</li>
<li>拦截器是SpringMVC框架独有的。</li>
<li>过滤器配置了/*，可以拦截任何资源。</li>
<li>拦截器只会对Controller中的方法进行拦截</li>
</ol>
<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><ol>
<li>实现<code>HandlerInterceptor</code></li>
<li>在springmvc.xml中配置拦截器类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置拦截器 如果配置多个，每个一个&lt;mvc:interceptor&gt;--&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">	&lt;mvc:interceptor&gt;</span><br><span class="line">		&lt;!-- 哪些方法进行拦截 --&gt;</span><br><span class="line">		&lt;mvc:mapping path=&quot;/user/*&quot;/&gt;</span><br><span class="line">		&lt;!-- 哪些方法不进行拦截</span><br><span class="line">		&lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span><br><span class="line">		--&gt;</span><br><span class="line">		&lt;!-- 注册拦截器对象 --&gt;</span><br><span class="line">		&lt;bean class=&quot;自定义拦截器全类名&quot;/&gt;</span><br><span class="line">	&lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h2><ul>
<li><code>preHandler()</code><ul>
<li>controller方法执行前执行</li>
<li>可以使用request或者response跳转到指定的页面</li>
<li>return true <ul>
<li>放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法</li>
</ul>
</li>
<li>return false<ul>
<li>不放行，不会执行controller中的方法</li>
</ul>
</li>
</ul>
</li>
<li><code>postHandler()</code><ul>
<li>controller方法执行后，在JSP视图执行前，执行</li>
<li>可以使用request或者response跳转到指定的页面</li>
<li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示</li>
</ul>
</li>
<li><code>afterCompletion</code><ul>
<li>JSP视图执行后，执行</li>
<li>request或者response不能再跳转页面了</li>
</ul>
</li>
</ul>
<h1 id="url模板映射"><a href="#url模板映射" class="headerlink" title="url模板映射"></a>url模板映射</h1><ul>
<li>url模板映射可以实现restfull软件架构</li>
</ul>
<h2 id="restfull"><a href="#restfull" class="headerlink" title="restfull"></a>restfull</h2><ul>
<li>请求地址没有<code>?参数</code>,<code>扩展名</code>等等</li>
<li>请求更简洁，更安全，更方便于搜索引擎收录</li>
</ul>
<h2 id="实现restfull"><a href="#实现restfull" class="headerlink" title="实现restfull"></a>实现restfull</h2><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><ul>
<li>将请求参数使用<code>{}</code>加入到请求地址中<ul>
<li><code>@RequestMapping(&quot;update/{id}&quot;)</code></li>
</ul>
</li>
<li>通过注解<code>@PathVariable</code>表明传递参数<ul>
<li><code>@PathVariable Integer id</code></li>
</ul>
</li>
<li>请求url不再使用<code>?</code><ul>
<li><code>/user/update?user.id.do</code>（原）</li>
<li><code>/user/update/${user.id}.do</code>（restfull）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;update/&#123;id&#125;&quot;)</span><br><span class="line">public String update(@PathVariable Integer id)&#123;</span><br><span class="line">code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="扩展名"><a href="#扩展名" class="headerlink" title="扩展名"></a>扩展名</h3><ul>
<li>通过约定修改web.xml的servlet拦截地址</li>
<li><code>&lt;url-pattern&gt;/xxx/*&lt;/url-pattern&gt;</code></li>
</ul>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><ul>
<li><code>&lt;mvc:annotation-driven/&gt;</code><ul>
<li>默认自动创建注解处理器映射器，注解处理器适配器。提供json格式支持</li>
</ul>
</li>
<li><p><code>@ResponseBody</code> &amp; <code>@RequestBody</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;reqJson&quot;)</span><br><span class="line">public @ResponseBody User reqJson(@RequestBody User user) &#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@RequestBody接受前台json数据，把json数据自动封装javaBean</li>
<li>@ResponseBody把后台pojo转换json对象，返回到页面</li>
<li>这两个注解依赖Jackson的jar包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置注解适配器--&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;</span><br><span class="line">    &lt;!--配置json数据格式的支持--&gt;</span><br><span class="line">    &lt;property name=&quot;messageConverters&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="多视图"><a href="#多视图" class="headerlink" title="多视图"></a>多视图</h1><ul>
<li>xml格式支持需要的jar包<code>spring-oxm.jar</code></li>
<li><p>配置springmvc支持多视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置多视图支持--&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class="line">    &lt;!-- 配置支持媒体类型 --&gt;</span><br><span class="line">    &lt;property name=&quot;contentNegotiationManager&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;mediaTypes&quot;&gt;</span><br><span class="line">                &lt;map&gt;</span><br><span class="line">                    &lt;entry key=&quot;json&quot; value=&quot;application/json&quot;/&gt;</span><br><span class="line">                    &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot;/&gt;</span><br><span class="line">                &lt;/map&gt;</span><br><span class="line">            &lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 指定默认视图 --&gt;</span><br><span class="line">    &lt;property name=&quot;defaultViews&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;!--对josn格式视图支持--&gt;</span><br><span class="line">            &lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJacksonJsonView&quot;&gt;&lt;/bean&gt;</span><br><span class="line">            &lt;!-- xml格式视图支持 --&gt;</span><br><span class="line">            &lt;bean class=&quot;org.springframework.web.servlet.view.xml.MarshallingView&quot;&gt;</span><br><span class="line">                &lt;constructor-arg&gt;</span><br><span class="line">                    &lt;bean class=&quot;org.springframework.oxm.jaxb.Jaxb2Marshaller&quot;&gt;</span><br><span class="line">                        &lt;property name=&quot;classesToBeBound&quot;&gt;</span><br><span class="line">                            &lt;list&gt;</span><br><span class="line">                                &lt;value&gt;an.sm3.domain.User&lt;/value&gt;</span><br><span class="line">                            &lt;/list&gt;</span><br><span class="line">                        &lt;/property&gt;</span><br><span class="line">                    &lt;/bean&gt;</span><br><span class="line">                &lt;/constructor-arg&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过以上配置还要在需要使用的POJO类上配置注解<code>@XmlRootElement</code></p>
<pre>
@XmlRootElement
public class User {}
</pre></li>
<li>然后请求地址后缀名为<ul>
<li><code>.json</code>则返回json视图</li>
<li><code>.xml</code>则返回xml视图</li>
</ul>
</li>
</ul>
<h1 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h1><ul>
<li>使用oscache</li>
<li>原理<ul>
<li>缓存数据结构：map<ul>
<li>key：存储浏览器访问url</li>
<li>Value：缓存页面数据</li>
</ul>
</li>
</ul>
</li>
<li>存储范围<ul>
<li>缓存默认存储在application域当中</li>
</ul>
</li>
<li>修改范围<ul>
<li><code>&lt;oscache:cache scope=&quot;session&quot;&gt;&lt;/oscache:cache&gt;</code></li>
</ul>
</li>
<li>固定缓存key<ul>
<li><code>&lt;oscache:cache key=&quot;&quot;&gt;&lt;/oscache:cache&gt;</code></li>
</ul>
</li>
<li>每隔固定时间(如3秒)同步一次<ul>
<li><code>&lt;oscache:cache time=&quot;3&quot;&gt;&lt;/oscache:cache&gt;</code></li>
</ul>
</li>
<li>缓存持久化<ul>
<li><code>oscache.properties</code>放在classpath下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.memory=false</span><br><span class="line">cache.persistence.class=com.opensymphony.oscache.plugins.diskpersistence.DiskPersistenceListener</span><br><span class="line">cache.path=F:\\cache</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="Springmvc的freemarker支持"><a href="#Springmvc的freemarker支持" class="headerlink" title="Springmvc的freemarker支持"></a>Springmvc的freemarker支持</h1><h1 id="SpringMVc与Struts2的区别"><a href="#SpringMVc与Struts2的区别" class="headerlink" title="SpringMVc与Struts2的区别"></a>SpringMVc与Struts2的区别</h1><ol>
<li><ul>
<li>sm入口是servlet</li>
<li>s2是filter</li>
</ul>
</li>
<li><ul>
<li>sm是基于方法开发（一个url对应一个方法），可以是单例也可以是多例（推荐单例）</li>
<li>s2是基于类开发，只能为多例<ul>
<li>单例是以方法为单位</li>
<li>多例是以类为单位</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>sm的参数是绑定在方法形参上</li>
<li>s2的参数绑定在成员变量上</li>
</ul>
</li>
<li><ul>
<li>sm通过参数解析器将request请求内容解析，绑定到方法形参后，将数据和视图封装成ModelAndView对象，最后将ModelAndView中的模型数据通过request域传输到页面</li>
<li>s2采用值栈存储请求和响应数据，通过OGNL存取数据</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/11/xd-Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/11/xd-Spring/" itemprop="url">
                  xd-Spring
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-11 00:40:07" itemprop="dateCreated datePublished" datetime="2018-12-11T00:40:07+08:00">2018-12-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-27 00:34:04" itemprop="dateModified" datetime="2019-01-27T00:34:04+08:00">2019-01-27</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Frame/" itemprop="url" rel="index"><span itemprop="name">Frame</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架<ul>
<li><strong>分层</strong><ul>
<li>web层：struts，spring-MVC</li>
<li>service层：spring</li>
<li>dao层：hibernate，mybatis ， jdbcTemplate  –&gt; spring-data</li>
</ul>
</li>
<li><strong>一站式</strong><ul>
<li>每一个层都提供的解决方案</li>
</ul>
</li>
<li><strong>轻量级</strong><ul>
<li>与EJB对比，依赖资源少，销毁的资源少</li>
</ul>
</li>
</ul>
</li>
<li>Spring的核心是<strong>控制反转（IOC）</strong>和<strong>面向切面（AOP）</strong></li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li><code>https://repo.spring.io/webapp/#/home</code><ul>
<li><code>artifacts</code>→<code>libs-release-loacl</code>→<code>springframework</code>→<code>spring</code></li>
</ul>
</li>
</ul>
<h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><ul>
<li>解耦和<ul>
<li>不直接new对象，通过反射创建对象，编译时就不依赖对象类了。</li>
<li>通过工厂，读取配置文件的方式。配置文件中<code>key=对象全类名</code></li>
</ul>
</li>
<li>单例<ul>
<li>每次都是用反射创建对象，是多例的，</li>
<li>而service和dao中通常没有成员变量，不存在线程安全问题，所以单例比较好。</li>
<li>在反射创建对象后，将对象存在一个容器中（如map），获取对象时从容器中获得，就是同一个对象了。</li>
</ul>
</li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li><code>Expert One-to-One J2EE Design and Development</code></li>
<li><code>Expert One-to-One J2EE Development without EJB</code></li>
</ul>
<h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><p><img src="https://gitee.com/3noanswer/pics/raw/master/spring-overview.png" alt=""></p>
<h2 id="Core-Container-核心容器"><a href="#Core-Container-核心容器" class="headerlink" title="Core Container(核心容器)"></a>Core Container(核心容器)</h2><h3 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a><code>Beans</code></h3><ul>
<li>管理bean    </li>
</ul>
<h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a><code>Core</code></h3><ul>
<li>核心</li>
</ul>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a><code>Context</code></h3><ul>
<li>上下文(配置文件…)</li>
</ul>
<h3 id="Expression-Language"><a href="#Expression-Language" class="headerlink" title="Expression Language"></a><code>Expression Language</code></h3><ul>
<li>SpEL(springEl表达式…)</li>
</ul>
<h3 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a><code>Messaging</code></h3><h2 id="Aop-Aspect-Oriented-Programming"><a href="#Aop-Aspect-Oriented-Programming" class="headerlink" title="Aop(Aspect Oriented Programming)"></a>Aop(Aspect Oriented Programming)</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><code>AOP</code></h3><ul>
<li>面向切面编程</li>
</ul>
<h3 id="Aspects"><a href="#Aspects" class="headerlink" title="Aspects"></a><code>Aspects</code></h3><ul>
<li>AOP框架</li>
</ul>
<h3 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a><code>Instrumentation</code></h3><h2 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access/Integration"></a>Data Access/Integration</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><code>JDBC</code></h3><ul>
<li>jdbc的支持 JdbcTemplate</li>
</ul>
<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a><code>ORM</code></h3><ul>
<li>对象关系映射</li>
</ul>
<h3 id="OXM"><a href="#OXM" class="headerlink" title="OXM"></a><code>OXM</code></h3><ul>
<li>对象xml映射，集成orm框架</li>
</ul>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a><code>JMS</code></h3><ul>
<li>java消息服务</li>
</ul>
<h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a><code>Transactions</code></h3><ul>
<li>事务控制</li>
</ul>
<h2 id="Web-MVC-Remoting"><a href="#Web-MVC-Remoting" class="headerlink" title="Web(MVC/Remoting)"></a>Web(MVC/Remoting)</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a><code>Web</code></h3><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a><code>Servlet</code></h3><h3 id="Portlet"><a href="#Portlet" class="headerlink" title="Portlet"></a><code>Portlet</code></h3><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><code>WebSocket</code></h3><h3 id="struts"><a href="#struts" class="headerlink" title="struts"></a><code>struts</code></h3><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><ul>
<li>……</li>
</ul>
<h1 id="Jar包"><a href="#Jar包" class="headerlink" title="Jar包"></a>Jar包</h1><h2 id="Core-1"><a href="#Core-1" class="headerlink" title="Core"></a>Core</h2><ul>
<li><code>spring-core.jar</code><ul>
<li>IoC与DI的最基本实现</li>
<li>依赖<code>commons-logging.jar</code></li>
<li>其他模块都依赖了<code>spring-core.jar</code>，所以整个spring框架都依赖了<code>commons-logging.jar</code></li>
<li>如果有自己的日志实现如log4j，可以排除对<code>commons-logging</code>的依赖</li>
</ul>
</li>
<li><code>spring-jcl.jar</code><ul>
<li>spring集成了<code>commons-logging.jar</code></li>
</ul>
</li>
<li><code>spring-beans.jar</code><ul>
<li>Bean工厂与bean的装配</li>
</ul>
</li>
<li><code>spring-context.jar</code><ul>
<li>spring的上下文即IoC容器</li>
</ul>
</li>
<li><code>spring-expression.jar</code><ul>
<li>spring表达式语言</li>
</ul>
</li>
</ul>
<h2 id="Aop"><a href="#Aop" class="headerlink" title="Aop"></a>Aop</h2><ul>
<li><code>spring-aop.jar</code><ul>
<li>aop实现</li>
<li>依赖<code>aopalliance.jar</code><ul>
<li>aop联盟的包</li>
</ul>
</li>
</ul>
</li>
<li><code>spring-aspects.jar</code><ul>
<li>集成AspectJ</li>
<li>依赖<code>aspectjweaver.jar</code><ul>
<li>aspect规范</li>
</ul>
</li>
</ul>
</li>
<li><code>spring-instrument.jar</code><ul>
<li>提供一些类级的工具支持和ClassLoader级的实现，用于服务器</li>
</ul>
</li>
<li><code>spring-instrument-tomcat.jar</code><ul>
<li>针对tomcat的instrument实现</li>
</ul>
</li>
</ul>
<h2 id="data-access"><a href="#data-access" class="headerlink" title="data access"></a>data access</h2><ul>
<li><code>spring-jdbc.jar</code><ul>
<li>jdbc的支持</li>
</ul>
</li>
<li><code>spring-tx.jar</code><ul>
<li>事务控制</li>
</ul>
</li>
<li><code>spring-orm.jar</code><ul>
<li>对象关系映射，集成orm框架</li>
</ul>
</li>
<li><code>spring-oxm.jar</code><ul>
<li>对象xml映射</li>
</ul>
</li>
<li><code>spring-jms.jar</code><ul>
<li>java消息服务</li>
</ul>
</li>
</ul>
<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><ul>
<li><code>spring-web.jar</code><ul>
<li>基础web功能，如文件上传</li>
</ul>
</li>
<li><code>spring-webmvc.jar</code><ul>
<li>mvc实现</li>
</ul>
</li>
<li><code>spring-webmvc-portlet.jar</code><ul>
<li>基于portlet的mvc实现</li>
</ul>
</li>
<li><code>spring-struts.jar</code><ul>
<li>与struts的集成，不推荐，spring4不再提供</li>
</ul>
</li>
</ul>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><ul>
<li><code>spring-test.jar</code><ul>
<li>spring测试，提供junit与mock测试功能</li>
</ul>
</li>
</ul>
<h2 id="support"><a href="#support" class="headerlink" title="support"></a>support</h2><ul>
<li><code>spring-context-support.jar</code><ul>
<li>spring额外支持包，比如邮件服务、视图解析等</li>
</ul>
</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="核心监听器"><a href="#核心监听器" class="headerlink" title="核心监听器"></a>核心监听器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>
<h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 扫描注解 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;&quot;/&gt;</span><br><span class="line">&lt;!-- 配置properties --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:包名xxx.properties&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h1 id="核心API-了解"><a href="#核心API-了解" class="headerlink" title="核心API(了解)"></a>核心API(了解)</h1><h2 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h2><p><img src="https://gitee.com/3noanswer/pics/raw/master/springAPI体系.png" alt=""></p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><ul>
<li>spring原始接口，针对原始接口的实现类功能较为单一</li>
<li>特点<ul>
<li>此接口实现类的容器，每次获取对象时才会创建对象。</li>
<li><strong>延迟加载，第一次获取对象（getBean()）时才实例化Bean</strong></li>
</ul>
</li>
</ul>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><ul>
<li>BeanFactory子接口，功能更强大。<ul>
<li>国际化，事件传递，bean自动装配….</li>
</ul>
</li>
<li>特点<ul>
<li><strong>立即加载，配置文件一加载就会实例化配置的所有Bean</strong></li>
</ul>
</li>
</ul>
<h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><ul>
<li>ApplicationContext实现类</li>
<li>用于加载类路径下的xml</li>
</ul>
<h2 id="FileSystemXmlApplicaitonContext"><a href="#FileSystemXmlApplicaitonContext" class="headerlink" title="FileSystemXmlApplicaitonContext"></a>FileSystemXmlApplicaitonContext</h2><ul>
<li>ApplicationContext实现类</li>
<li>用于加载磁盘任意路径下的xml</li>
</ul>
<h2 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h2><ul>
<li>ApplicationContext实现类</li>
<li>用于读取注解创建容器</li>
</ul>
<h1 id="IOC（Inversion-of-Control）"><a href="#IOC（Inversion-of-Control）" class="headerlink" title="IOC（Inversion of Control）"></a>IOC（<code>Inversion of Control</code>）</h1><ul>
<li>控制反转</li>
<li>把创建对象的权力交给Spring。</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>降低耦合。</p>
<h2 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h2><ul>
<li>DI（<code>Dependency Injection</code>）依赖注入</li>
<li>DL（<code>Dependency Lookup</code>）依赖查找</li>
</ul>
<h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><ul>
<li>依赖<ul>
<li>一个对象需要使用另一个对象</li>
<li>is a ：是一个，继承。</li>
<li>has a：有一个，成员变量，依赖</li>
</ul>
</li>
<li>注入<ul>
<li>注入方式<ul>
<li>set</li>
<li>构造</li>
<li>字段</li>
</ul>
</li>
<li>注入类型<ul>
<li>值类型</li>
<li>引用类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Bean基于xml"><a href="#Bean基于xml" class="headerlink" title="Bean基于xml"></a>Bean基于xml</h1><h2 id="Bean实例化方式"><a href="#Bean实例化方式" class="headerlink" title="Bean实例化方式"></a>Bean实例化方式</h2><h3 id="默认构造"><a href="#默认构造" class="headerlink" title="默认构造"></a>默认构造</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;bean全类名&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须提供默认构造</li>
</ul>
<h3 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot;  class=&quot;静态工厂全类名&quot;  factory-method=&quot;静态工厂中获取bean的静态方法&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>常用于    spring整合其他框架（工具）</li>
</ul>
<h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;工厂id&quot; class=&quot;工厂全限定类名&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;&quot; factory-bean=&quot;工厂id&quot; factory-method=&quot;工厂中获取bean的方法&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须先有工厂实例对象，通过工厂实例对象创建对象。</li>
</ul>
<h2 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h2><ul>
<li><code>&lt;bean id=&quot;&quot; class=&quot;&quot;  scope=&quot;&quot;&gt;</code></li>
</ul>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><ul>
<li><code>singleton</code><ul>
<li>单例 默认</li>
<li>加载配置文件就会创建bean</li>
</ul>
</li>
<li><code>prototype</code><ul>
<li>多例 每执行一次getBean将获得一个实例</li>
<li>启动容器并不会创建对象，获得 bean 的时候才会创建对象</li>
</ul>
</li>
<li><code>request</code><ul>
<li>作用于web应用的请求范围</li>
<li>每次http请求会创建一个新的bean</li>
</ul>
</li>
<li><code>session</code><ul>
<li>作用于web应用的会话范围</li>
<li>同一个HTTP session共享一个bean</li>
</ul>
</li>
<li><code>globalSession</code><ul>
<li>作用于集群环境的会话范围（全局会话范围）</li>
<li>若不是集群，就是<code>session</code></li>
</ul>
</li>
</ul>
<h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><p><img src="https://gitee.com/3noanswer/pics/raw/master/Bean实例化过程.png" alt=""></p>
<ol>
<li>instantiate bean<ul>
<li>对象实例化</li>
</ul>
</li>
<li>populate properties<ul>
<li>属性注入</li>
</ul>
</li>
<li>BeanNameAware <ul>
<li>如果Bean实现了BeanNameAware接口，执行 <code>setBeanName()</code>传入Bean的id</li>
</ul>
</li>
<li>BeanFactoryAware<ul>
<li>如果Bean实现了BeanFactoryAware接口，执行<code>setBeanFactory()</code>传入BeanFactory实例</li>
</ul>
</li>
<li>ApplicationContextAware <ul>
<li>如果Bean实现了ApplicationContextAware接口，执行<code>setApplicationContext()</code>传入ApplicationContext实例</li>
</ul>
</li>
<li><strong>BeanPostProcessor（后处理Bean）</strong><ul>
<li>如果Bean实现了BeanPostProcessor接口，执行<code>postProcessBeforeInitialization()</code>（前置处理）</li>
</ul>
</li>
<li>InitializingBean<ul>
<li>如果Bean实现了InitializingBean接口，执行<code>afterPropertiesSet()</code></li>
</ul>
</li>
<li><strong>Bean定义文件中的 init-method</strong><ul>
<li><code>&lt;bean init-method=&quot;初始化方法&quot;&gt;</code></li>
<li>若配置则执行此指定初始化方法</li>
</ul>
</li>
<li><strong>BeanPostProcessor（后处理Bean）</strong><ul>
<li>如果Bean实现了BeanPostProcessor接口，执行<code>postProcessAfterInitialization()</code>（后置处理）</li>
<li>此时，Bean已经可以被应用系统使用，并且将保留在BeanFactory中直到它不在被使用。</li>
</ul>
</li>
<li>执行业务处理</li>
<li>DisposableBean <ul>
<li>如果Bean实现了DisposableBean接口，执行 <code>destroy()</code></li>
</ul>
</li>
<li><strong>Bean定义文件中的 destroy-method</strong><ul>
<li><code>&lt;bean destroy-method=&quot;销毁方法&quot;&gt;</code></li>
<li>若配置则执行此指定销毁方法</li>
<li>销毁方法要执行<ul>
<li>必须关闭容器。(ApplicationContext)</li>
<li>必须是单例</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="单例Bean"><a href="#单例Bean" class="headerlink" title="单例Bean"></a>单例Bean</h3><ul>
<li>创建<ul>
<li>容器创建，bean就会创建</li>
</ul>
</li>
<li>存活<ul>
<li>容器存在，bean就存在</li>
</ul>
</li>
<li>销毁<ul>
<li>容器销毁，bean就销毁</li>
</ul>
</li>
</ul>
<h3 id="多例Bean"><a href="#多例Bean" class="headerlink" title="多例Bean"></a>多例Bean</h3><ul>
<li>创建<ul>
<li>第一次使用bean对象时，bean创建</li>
</ul>
</li>
<li>存活<ul>
<li>对象使用过程中，存活</li>
</ul>
</li>
<li>销毁<ul>
<li>当对象长时间不用，且没有别的对象引用时，由java垃圾回收器回收。</li>
</ul>
</li>
</ul>
<h3 id="BeanPostProcessor-后处理Bean"><a href="#BeanPostProcessor-后处理Bean" class="headerlink" title="BeanPostProcessor (后处理Bean)"></a>BeanPostProcessor (后处理Bean)</h3><ul>
<li>spring提供的工厂勾子，用于修改实例对象，如可以生成代理对象，是AOP底层</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>spring提供的一种机制，只要实现此接口，并将实现类提供给spring容器，spring容器将自动<ul>
<li>在初始化方法前<ul>
<li>执行<code>postProcessBeforeInitialization(Object bean,String beanName)</code><ul>
<li><code>bean</code><ul>
<li>就是spring创建的要初始化的目标类</li>
</ul>
</li>
<li>返回值<ol>
<li>spring创建的目标对象</li>
<li>目标对象的代理对象</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>在初始化方法后<ul>
<li>执行<code>postProcessAfterInitialization(Object bean,String beanName)</code> <ul>
<li>返回值<ol>
<li>spring创建的目标对象</li>
<li>目标对象的代理对象</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>写一个类实现BeanPostProcessor接口</li>
<li>配置<code>&lt;bean class=&quot;&quot;&gt;</code><ul>
<li>后处理bean会对所有目标类有效     </li>
<li>如何针对某一个目标类？<ul>
<li>利用实现类中<code>postProcessBeforeInitialization()</code>/<code>postProcessAfterInitialization()</code>方法的第二个参数beanName来进行判断</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="类A的创建初始化→目标方法→销毁过程"><a href="#类A的创建初始化→目标方法→销毁过程" class="headerlink" title="类A的创建初始化→目标方法→销毁过程"></a>类A的创建初始化→目标方法→销毁过程</h4><ol>
<li><p>一般过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a=new A()</span><br><span class="line">a.init()</span><br><span class="line">a.add()</span><br><span class="line">a.destroy()</span><br></pre></td></tr></table></figure>
</li>
<li><p>现有一类B实现了BeanPostProcessor接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A a=new A()</span><br><span class="line">a/aProxy=B.postProcessBeforeInitialization(a)</span><br><span class="line">a.init()</span><br><span class="line">a/aproxy=B.postProcessAfterInitialization(a)</span><br><span class="line">a.add()</span><br><span class="line">a.destroy()</span><br></pre></td></tr></table></figure>
<ul>
<li>如上在初始化方法前后都可以获取代理对象。代理对象又可以在目标方法前后做一些事，如事务…<ul>
<li>注意在初始化方法前获取代理对象，则初始化方法使用的就是代理对象。而可能指定的初始化方法只有实现类中有，接口中可能没有，</li>
</ul>
</li>
<li>对于jdk代理，使用的是接口。<ul>
<li>前获取代理对象<ul>
<li>指定的初始化方法接口中必须有。</li>
</ul>
</li>
<li>后获取代理对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="Bean基于注解"><a href="#Bean基于注解" class="headerlink" title="Bean基于注解"></a>Bean基于注解</h1><ul>
<li><code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code><ul>
<li>配置注解扫描</li>
</ul>
</li>
</ul>
<h2 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>取代的是<code>&lt;bean class=&quot;&quot;&gt;</code></li>
<li>默认bean id为 类名首字母小写</li>
</ul>
<h3 id="实例化注解"><a href="#实例化注解" class="headerlink" title="实例化注解"></a>实例化注解</h3><ul>
<li><code>@Component</code></li>
<li><code>@Controller</code><ul>
<li>web层</li>
</ul>
</li>
<li><code>@Service</code><ul>
<li>service层</li>
</ul>
</li>
<li><code>@Repository</code><ul>
<li>dao层</li>
</ul>
</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><code>@Scope</code><ul>
<li><code>@Scope(&quot;prototype&quot;)</code>多例</li>
</ul>
</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><code>@PostConstruct</code><ul>
<li>初始化</li>
</ul>
</li>
<li><code>@PreDestroy</code><ul>
<li>销毁</li>
</ul>
</li>
</ul>
<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h2 id="注入的数据类型"><a href="#注入的数据类型" class="headerlink" title="注入的数据类型"></a>注入的数据类型</h2><ol>
<li>基本类型和String</li>
<li>其它Bean（xml或注解配置过的Bean）</li>
<li>复杂类型/数组集合</li>
</ol>
<h3 id="数组-集合的注入"><a href="#数组-集合的注入" class="headerlink" title="数组/集合的注入"></a>数组/集合的注入</h3><ul>
<li>使用set方法注入(其它构造 p spel也可以)</li>
<li>分为两种结构，同一种结构的标签可以通用<ul>
<li>list<ul>
<li>数组，list，set</li>
</ul>
</li>
<li>map<ul>
<li>map，properties</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;数组属性名&quot;&gt;</span><br><span class="line">		&lt;array&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">		&lt;/array&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;List属性名&quot;&gt;</span><br><span class="line">		&lt;list&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">		&lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;Set属性名&quot;&gt;</span><br><span class="line">		&lt;set&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">			&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">		&lt;/set&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;Map属性名&quot;&gt;</span><br><span class="line">		&lt;map&gt;</span><br><span class="line">			&lt;entry key=&quot;键&quot; value=&quot;值&quot; /&gt;</span><br><span class="line">			&lt;entry key=&quot;键&quot;&gt;</span><br><span class="line">				&lt;value&gt;值&lt;/value&gt;</span><br><span class="line">			&lt;/entry&gt;</span><br><span class="line">		&lt;/map&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;Properties属性名&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;键&quot;&gt;值&lt;/prop&gt;</span><br><span class="line">			&lt;prop key=&quot;键&quot;&gt;值&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><h3 id="基于xml注入"><a href="#基于xml注入" class="headerlink" title="基于xml注入"></a>基于xml注入</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;an.s1.domain.User&quot;&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;name&quot; value=&quot;小强&quot;/&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;age&quot; value=&quot;24&quot;/&gt;</span><br><span class="line">	&lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;xx&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建bean时默认使用的是空参构造，可以指定使用哪个构造方法，这样即可为属性注入值。<ul>
<li><code>&lt;constructor-arg&gt;</code><ul>
<li>配置给谁赋值<ul>
<li><code>name</code><ul>
<li>属性名</li>
</ul>
</li>
<li><code>index</code><ul>
<li>构造参数的索引 从0开始。</li>
<li>若只有索引，匹配到多个构造方法时，使用第一个匹配的。配合type使用。</li>
</ul>
</li>
<li><code>type</code><ul>
<li>参数类型</li>
</ul>
</li>
</ul>
</li>
<li>配置值<ul>
<li><code>value</code><ul>
<li>为普通属性数据赋值</li>
</ul>
</li>
<li><code>ref</code><ul>
<li>为引用属性数据赋值</li>
<li>一般是另一个bean 的id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;an.s1.domain.User&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;id&quot; value=&quot;3&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;旺财&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;property&gt;</code><ul>
<li><code>name</code><ul>
<li>bean中set方法中的属性名</li>
</ul>
</li>
<li><code>value</code><ul>
<li>为普通属性数据赋值</li>
</ul>
</li>
<li><code>ref</code><ul>
<li>为引用属性数据赋值</li>
<li>一般是另一个bean 的id</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="P命名空间-了解"><a href="#P命名空间-了解" class="headerlink" title="P命名空间(了解)"></a>P命名空间(了解)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;属性名&quot; value=&quot;普通值&quot; ref=&quot;引用值&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean p:属性名=&quot;普通值&quot; p:属性名-ref=&quot;引用值&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>对set方法注入进行简化，去掉了标签体中的<code>&lt;property&gt;</code>标签，用属性代替<ul>
<li><code>&lt;property name=&quot;key&quot; value=&quot;value&quot;/&gt;</code>替换成<code>p:key=&quot;value&quot;</code></li>
</ul>
</li>
</ul>
<h4 id="SpEL-了解"><a href="#SpEL-了解" class="headerlink" title="SpEL(了解)"></a>SpEL(了解)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;&quot; value=&quot;#&#123;spEL表达式&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>spEL表达式<ul>
<li><code>#{123}</code><ul>
<li>数字</li>
</ul>
</li>
<li><code>#{&#39;an&#39;}</code><ul>
<li>字符串</li>
</ul>
</li>
<li><code>#{beanId}</code><ul>
<li>另一个bean引用</li>
</ul>
</li>
<li><code>#{beanId.propName}</code><ul>
<li>操作属性数据</li>
</ul>
</li>
<li><code>#{beanId.toString()}</code><ul>
<li>执行方法</li>
</ul>
</li>
<li><code>#{xx?.method()}</code><ul>
<li>如果xx为空则不调用方法,不为空调用</li>
</ul>
</li>
<li><code>#{T(类).字段|方法}</code><ul>
<li>静态方法或字段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于注解注入"><a href="#基于注解注入" class="headerlink" title="基于注解注入"></a>基于注解注入</h3><h4 id="Value-value-”值-spEL”"><a href="#Value-value-”值-spEL”" class="headerlink" title="@Value(value=”值/spEL”)"></a>@Value(value=”值/spEL”)</h4><ul>
<li>注入基本数据类型和String</li>
<li>spEL在类文件中格式为<code>${}</code>，在xml中为<code>#{}</code></li>
</ul>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ul>
<li>按照类型注入<ul>
<li>如果容器没有此类型匹配项<ul>
<li>注入失败</li>
</ul>
</li>
<li>如果容器有一个此类型匹配项<ul>
<li>注入成功</li>
</ul>
</li>
<li>如果容器有多个此类型匹配项<ul>
<li>则以要注入的对象变量名作为Bean的id去匹配所有匹配项，若有此id则注入成功，无此id则注入失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Qualifier-value-”beanId”"><a href="#Qualifier-value-”beanId”" class="headerlink" title="@Qualifier(value=”beanId”)"></a>@Qualifier(value=”beanId”)</h4><ul>
<li>作用在字段上<ul>
<li>不能单独使用，配合<code>@Autowire</code></li>
<li>在按照类型注入的基础上指定bean的id</li>
</ul>
</li>
<li>作用在方法上<ul>
<li>可以单独使用</li>
</ul>
</li>
</ul>
<h4 id="Resource-name-”beanId”"><a href="#Resource-name-”beanId”" class="headerlink" title="@Resource(name=”beanId”)"></a>@Resource(name=”beanId”)</h4><ul>
<li>按照bean的id注入</li>
</ul>
<h1 id="新注解"><a href="#新注解" class="headerlink" title="新注解"></a>新注解</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>原有注解还是要配合xml一起使用，如扫描注解，配置不是我们编写的bean如数据源..</li>
</ul>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>配置在类上，指定当前类是一个spring配置类，创建容器时会从该类上加载注解。相当于<code>applicationContext.xml</code></li>
<li>创建容器要使用ApplicationContext的注解实现类AnnotationApplicationContext<ul>
<li><code>ApplicationContext ac = new AnnotationApplicationContext(有@Configuration 注解的类.class)</code></li>
</ul>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value</code><ul>
<li>用于指定配置类的字节码</li>
</ul>
</li>
</ul>
<h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于指定 spring 在初始化容器时要扫描的包，即原来的扫描注解</li>
</ul>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>basePackages</code><ul>
<li>用于指定要扫描的包</li>
</ul>
</li>
<li><code>value</code><ul>
<li>和basePackages一样</li>
</ul>
</li>
</ul>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ul>
<li>只能写在方法上，把当前方法的返回值作为bean对象存入spring的ioc容器中</li>
<li>如果方法有参数，spring会去容器中查找是否有参数对应的bean，查找方式与<code>@Autowire</code>一样，且也可以加<code>@Qualifier</code>注解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean(name=&quot;runner&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public QueryRunner createQueryRunner(@Qualifier(&quot;ds&quot;) DataSource dataSource)&#123;</span><br><span class="line">		return new QueryRunner(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>name</code><ul>
<li>给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）</li>
<li>默认为方法名。</li>
</ul>
</li>
</ul>
<h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于加载<code>.properties</code> 文件</li>
</ul>
<h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value[]</code><ul>
<li>用于指定 properties 文件位置</li>
<li>类路径下要加上<code>classpath:</code></li>
</ul>
</li>
</ul>
<h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><ul>
<li>用于导入其他配置类</li>
<li>当我们使用@Import的注解之后，有@Import注解的类就父配置类，而导入的都是子配置类</li>
</ul>
<h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>value[]</code><ul>
<li>用于指定其他配置类的字节码</li>
</ul>
</li>
</ul>
<h1 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h1><ul>
<li><code>Aspect Oriented Programming</code> </li>
<li>面向切面编程</li>
</ul>
<h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul>
<li>AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码<ul>
<li>经典应用：事务管理、权限校验、异常处理、性能监视、安全检查、缓存 、日志等</li>
</ul>
</li>
<li>将核心业务代码与外围业务（日志记录、权限校验、异常处理、事务控制）代码分离出来，提高模块化，降低代码耦合度，使职责更单一</li>
</ul>
<h2 id="AOP的实现框架"><a href="#AOP的实现框架" class="headerlink" title="AOP的实现框架"></a>AOP的实现框架</h2><h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><ul>
<li>AspectJ是一个比较牛逼的AOP框架，他可以对类的成员变量，方法进行拦截。由于 AspectJ 是 Java 语言语法和语义的扩展，所以它提供了自己的一套处理方面的关键字。除了包含字段和方法之外，AspectJ 的方面声明还包含切入点和通知成员。</li>
<li>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）</li>
<li>静态织入<ul>
<li>在编译期使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入</li>
<li>即先编译aspect类再编译目标类</li>
</ul>
</li>
</ul>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring-AOP"></a>Spring-AOP</h3><ul>
<li>Spring AOP依赖的是 Spring 框架方便的、最小化的运行时配置，所以不需要独立的启动器。但是，使用这个技术，只能通知从 Spring 框架检索出的对象。Spring的AOP技术只能是对方法进行拦截</li>
<li>Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码</li>
<li>动态织入<ul>
<li>在运行时动态将要增强的代码织入到目标类中</li>
<li>通过动态代理技术完成<ul>
<li><strong>JDK动态代理</strong><ul>
<li>基于反射技术的实现</li>
<li><code>接口+实现类</code></li>
<li>代理对象格式<code>$Proxy</code></li>
<li><code>Proxy.newProxyInstance()</code></li>
</ul>
</li>
<li><strong>CGLIB动态代理</strong><ul>
<li>基于继承的机制实现</li>
<li><code>实现类</code></li>
<li>代理对象格式<code>xxxx$$EnhancerByCGLIB$$xxxxxx</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">// 确定父类</span><br><span class="line">enhancer.setSuperclass(testService.getClass());</span><br><span class="line">// 设置回调函数</span><br><span class="line">enhancer.setCallback() </span><br><span class="line">// 创建代理</span><br><span class="line">Object proxy =  enhancer.create();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="AspectJ-amp-Spring-AOP"><a href="#AspectJ-amp-Spring-AOP" class="headerlink" title="AspectJ &amp; Spring-AOP"></a>AspectJ &amp; Spring-AOP</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li>Spring AOP 与ApectJ 的目的一致，都是为了统一处理横切业务</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>Spring AOP 并不尝试提供完整的AOP功能(即使它完全可以实现)Spring AOP 更注重的是与Spring IOC容器的结合，并结合该优势来解决横切业务的问题</li>
<li>AOP的功能完善方面AspectJ具有更大的优势</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>AspectJ 1.5后，引入<code>@Aspect</code>形式的注解</li>
<li>Spring 2.0后便使用了与AspectJ一样的注解，并使用Aspectj来做切入点解析和匹配(AspectJ 5让第三方使用AspectJ的切入点解析和匹配引擎的工具API)。但是spring AOP底层依然是动态代理技术的实现，运行时仍旧是纯的spring AOP,并不依赖于Aspectj的编译器或者织入器</li>
</ul>
<h2 id="AOP使用"><a href="#AOP使用" class="headerlink" title="AOP使用"></a>AOP使用</h2><h3 id="开发阶段（程序员）"><a href="#开发阶段（程序员）" class="headerlink" title="开发阶段（程序员）"></a>开发阶段（程序员）</h3><ul>
<li>编写核心业务代码</li>
<li>公共代码抽取为通知</li>
<li>配置中声明切入点和通知的关系，即切面</li>
</ul>
<h3 id="运行阶段（Spring）"><a href="#运行阶段（Spring）" class="headerlink" title="运行阶段（Spring）"></a>运行阶段（Spring）</h3><ul>
<li>spring监控切入点方法的执行，一旦切入点方法运行，使用代理机制，动态创建目标对象的代理对象，根据通知类型，在代理对象的相应位置，将通知织入。</li>
</ul>
<h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><ul>
<li>目标类</li>
<li>需要被代理的类。</li>
</ul>
<h3 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h3><ul>
<li>连接点</li>
<li>指目标类中那些可能被拦截到的方法</li>
</ul>
<h3 id="PointCut"><a href="#PointCut" class="headerlink" title="PointCut"></a>PointCut</h3><ul>
<li>切入点</li>
<li>已经被增强的连接点。即目标类中被拦截了的方法。</li>
</ul>
<h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><ul>
<li>通知/增强</li>
<li>在某个特定的pointcut上需要执行的动作（代码）</li>
<li>如日志，权限验证。。。</li>
</ul>
<h3 id="Weaving"><a href="#Weaving" class="headerlink" title="Weaving"></a>Weaving</h3><ul>
<li>织入</li>
<li>是指把切面的代码应用到目标对象target的目标函数的过程</li>
<li>spring采用动态代理织入</li>
<li>Aspectj采用编译期织入和类装载期织入</li>
</ul>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><ul>
<li>代理类</li>
</ul>
<h3 id="Aspect-advisor"><a href="#Aspect-advisor" class="headerlink" title="Aspect/advisor"></a>Aspect/advisor</h3><ul>
<li>切面</li>
<li>是切入点pointcut和通知advice的结合,定义通知应用到哪些切入点上<ul>
<li>一个切入点和一个通知组成一条线</li>
<li>一个线是一个特殊的面。</li>
</ul>
</li>
</ul>
<h2 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h2><ul>
<li><code>org.aopalliance.aop.Advice</code></li>
<li>AOP联盟定义的通知</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h4><ul>
<li><code>org.springframework.aop.MethodBeforeAdvice</code></li>
<li>在目标方法执行前实施增强</li>
</ul>
<h4 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h4><ul>
<li><code>org.springframework.aop.AfterReturningAdvice</code></li>
<li>在目标方法执行后实施增强</li>
</ul>
<h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><ul>
<li><code>org.aopalliance.intercept.MethodInterceptor</code></li>
<li>在目标方法执行前后实施增强</li>
<li>必须手动执行目标方法</li>
</ul>
<h4 id="异常抛出通知"><a href="#异常抛出通知" class="headerlink" title="异常抛出通知"></a>异常抛出通知</h4><ul>
<li><code>org.springframework.aop.ThrowsAdvice</code></li>
<li>在方法抛出异常后实施增强</li>
</ul>
<h4 id="引介通知"><a href="#引介通知" class="headerlink" title="引介通知"></a>引介通知</h4><ul>
<li><code>org.springframework.aop.IntroductionInterceptor</code></li>
<li>在目标类中添加一些新的方法和属性</li>
</ul>
<h2 id="AspectJ-1"><a href="#AspectJ-1" class="headerlink" title="AspectJ"></a>AspectJ</h2><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><h4 id="execution"><a href="#execution" class="headerlink" title="execution()"></a><code>execution()</code></h4><ul>
<li>用于描述方法。</li>
</ul>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li><code>execution(修饰符 返回值 包.类.方法(参数)throws 异常)</code></li>
</ul>
<h6 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h6><ul>
<li>一般省略</li>
<li><code>*</code> <ul>
<li>通配符，任意</li>
</ul>
</li>
<li><code>public</code><ul>
<li>公共</li>
</ul>
</li>
</ul>
<h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><ul>
<li>不可省略</li>
<li><code>void</code> <ul>
<li>无返回值</li>
</ul>
</li>
<li><code>String</code> <ul>
<li>返回字符串</li>
</ul>
</li>
<li><code>*</code> <ul>
<li>任意</li>
</ul>
</li>
</ul>
<h6 id="包"><a href="#包" class="headerlink" title="包"></a>包</h6><ul>
<li><code>..</code> 当前包及其子包</li>
<li><code>*</code> 任意</li>
</ul>
<h6 id="类"><a href="#类" class="headerlink" title="类"></a>类</h6><ul>
<li>不可省略</li>
<li><code>C</code> <ul>
<li>指定类</li>
</ul>
</li>
<li><code>*x</code> <ul>
<li>以x结尾的类</li>
</ul>
</li>
<li><code>x*</code> <ul>
<li>以x开头的类</li>
</ul>
</li>
<li><code>*</code> <ul>
<li>任意</li>
</ul>
</li>
</ul>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法()"></a>方法()</h6><ul>
<li>不可省略</li>
<li><code>M</code> <ul>
<li>指定方法</li>
</ul>
</li>
<li><code>*x</code> <ul>
<li>以x结尾的方法</li>
</ul>
</li>
<li><code>x*</code> <ul>
<li>以x开头的方法</li>
</ul>
</li>
<li><code>*</code> <ul>
<li>任意</li>
</ul>
</li>
</ul>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul>
<li>可以直接写数据类型<ul>
<li>基本类型直接写名称，如<code>int</code></li>
<li>引用类型写<code>包名.类名</code>，如<code>java.lang.String</code></li>
</ul>
</li>
<li><code>..</code><ul>
<li>任意类型，且有无参数皆可</li>
</ul>
</li>
<li><code>*</code><ul>
<li>任意类型，必须有参数</li>
</ul>
</li>
<li><code>()</code> 无参</li>
<li><code>(int)</code> 一个整数</li>
<li><code>(int,int)</code> 两个整数</li>
<li><code>(..)</code> 任意参数</li>
</ul>
<h6 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h6><ul>
<li>一般不写。</li>
</ul>
<h4 id="within-了解"><a href="#within-了解" class="headerlink" title="within(了解)"></a><code>within</code>(了解)</h4><ul>
<li>匹配包或子包中的方法</li>
<li><code>within(包目录)</code><ul>
<li><code>within(cn.an...*)</code></li>
</ul>
</li>
</ul>
<h4 id="this-了解"><a href="#this-了解" class="headerlink" title="this(了解)"></a><code>this</code>(了解)</h4><ul>
<li>匹配实现接口的代理对象中的方法</li>
<li><code>this(接口全限定名)</code><ul>
<li><code>this(cn.an.UserDao)</code></li>
</ul>
</li>
</ul>
<h4 id="target-了解"><a href="#target-了解" class="headerlink" title="target(了解)"></a><code>target</code>(了解)</h4><ul>
<li>匹配实现接口的目标对象中的方法</li>
<li><code>target(接口全限定名)</code><ul>
<li><code>target(cn.an.UserDao)</code></li>
</ul>
</li>
</ul>
<h4 id="args-了解"><a href="#args-了解" class="headerlink" title="args(了解)"></a><code>args</code>(了解)</h4><ul>
<li>匹配参数格式符合标准的方法</li>
<li><code>args(int,int)</code></li>
</ul>
<h4 id="bean-了解"><a href="#bean-了解" class="headerlink" title="bean(了解)"></a><code>bean</code>(了解)</h4><ul>
<li>匹配指定的bean所有的方法</li>
<li><code>bean(&quot;beanId&quot;)</code></li>
</ul>
<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul>
<li>aop联盟通知类型<ul>
<li>具有特性接口，必须实现，从而确定方法名称。</li>
</ul>
</li>
<li>aspectj通知类型<ul>
<li>只定义类型名称以及方法格式    </li>
</ul>
</li>
</ul>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><h5 id="前置通知-1"><a href="#前置通知-1" class="headerlink" title="前置通知"></a>前置通知</h5><ul>
<li><code>before</code><ul>
<li>应用：各种校验</li>
<li>在方法执行前执行，如果通知抛出异常，阻止方法运行</li>
</ul>
</li>
<li><p>前置通知方法定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义方法名([JoinPoint jp])&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>jp</code><ul>
<li>用于描述连接点(目标方法)</li>
<li>可以获取目标方法方法名等。。。。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="后置通知-1"><a href="#后置通知-1" class="headerlink" title="后置通知"></a>后置通知</h5><ul>
<li><code>afterReturning</code><ul>
<li>应用：常规数据处理</li>
<li>方法正常返回后执行，如果方法中抛出异常，通知无法执行</li>
<li>必须在方法执行后才执行，所以可以获得方法的返回值。</li>
</ul>
</li>
<li><p>后置通知方法定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义方法名([JoinPoint jp],[Object obj])&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>obj</code><ul>
<li>目标方法返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="环绕通知-1"><a href="#环绕通知-1" class="headerlink" title="环绕通知"></a>环绕通知</h5><ul>
<li><code>around</code><ul>
<li>应用：十分强大，可以做任何事情</li>
<li>方法执行前后分别执行，可以阻止方法的执行</li>
</ul>
</li>
<li>必须手动执行目标方法<ul>
<li>spring为我们提供了一个接口<code>ProceedingJoinPoint</code>，该接口有一个方法<code>proceed()</code>，相当于调用目标方法，该接口作为环绕通知的方法参数，程序执行时，spring会自动提供实现类。</li>
</ul>
</li>
<li>环绕通知方法定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Object 自定义方法名(ProceedingJoinPoint pjp) &#123;</span><br><span class="line">	Object obj = null;</span><br><span class="line">	try&#123;</span><br><span class="line">		// 获取方法执行所需参数</span><br><span class="line">		Object[] args = pjp.getArges();</span><br><span class="line">		// 目标方法前 前置通知</span><br><span class="line">		// 执行目标方法 </span><br><span class="line">		obj = pjp.proceed();</span><br><span class="line">		// 目标方法后 前置通知</span><br><span class="line">		return obj;</span><br><span class="line">	&#125;catch()&#123;</span><br><span class="line">		// 异常通知</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">		// 最终通知</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="抛出异常通知"><a href="#抛出异常通知" class="headerlink" title="抛出异常通知"></a>抛出异常通知</h5><ul>
<li><code>afterThrowing</code><ul>
<li>应用：包装异常信息</li>
</ul>
</li>
<li>方法抛出异常后执行，如果方法没有抛出异常，无法执行</li>
<li>异常通知方法定义<ul>
<li><code>自定义方法名([JoinPoint jp],[Throwable e])</code></li>
</ul>
</li>
</ul>
<h5 id="最终通知"><a href="#最终通知" class="headerlink" title="最终通知"></a>最终通知</h5><ul>
<li><code>after</code><ul>
<li>应用：清理现场</li>
</ul>
</li>
<li>方法执行完毕后执行，无论方法中是否出现异常</li>
<li>最终通知方法定义<ul>
<li><code>自定义方法名([JoinPoint jp])</code></li>
</ul>
</li>
</ul>
<h1 id="Spring-AOP编程"><a href="#Spring-AOP编程" class="headerlink" title="Spring AOP编程"></a>Spring AOP编程</h1><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><h3 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h3><ol>
<li>编写目标类</li>
<li>编写通知</li>
<li>手动生成目标类代理对象<ol>
<li>jdk动态代理</li>
<li>cglib</li>
</ol>
</li>
</ol>
<h3 id="半自动方式"><a href="#半自动方式" class="headerlink" title="半自动方式"></a>半自动方式</h3><ol>
<li>编写目标类</li>
<li>编写通知（aop联盟的通知，实现指定接口）</li>
<li>通过配置让spring创建代理对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--1 配置目标类--&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;an.s4.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--2 配置切面类--&gt;</span><br><span class="line">&lt;bean id=&quot;myAdvice&quot; class=&quot;an.s4.advice.MyAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--3 配置代理对象--&gt;</span><br><span class="line">&lt;!--使用工厂bean  FactoryBean 底层调用getObject()--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    ProxyFactoryBean</span><br><span class="line">        interfaces:确定接口们</span><br><span class="line">        target：确定目标类</span><br><span class="line">        interceptorNames:确定切面类(通知)</span><br><span class="line">        optimize：强制使用cglib</span><br><span class="line">        底层机制：如果目标类有接口:采用jdk</span><br><span class="line">                目标类没有接口:采用cglib</span><br><span class="line">                声明了optimize:强制cglib</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;proxyService&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">	&lt;property name=&quot;interfaces&quot;&gt;</span><br><span class="line">       	 &lt;array&gt;</span><br><span class="line">   		     &lt;value&gt;an.s4.service.UserService&lt;/value&gt;</span><br><span class="line">        	&lt;/array&gt;</span><br><span class="line">    	&lt;/property&gt;</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;!--数组只有一个值时可以简化--&gt;</span><br><span class="line">    &lt;property name=&quot;interfaces&quot; value=&quot;an.s4.service.UserService&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;target&quot; ref=&quot;userService&quot;/&gt;</span><br><span class="line">    &lt;!--注意这里写的是value而不是ref 因为interceptorNames类型是String[] 而target是Object--&gt;</span><br><span class="line">    &lt;property name=&quot;interceptorNames&quot; value=&quot;myAdvice&quot;/&gt;</span><br><span class="line">    &lt;!--&lt;property name=&quot;optimize&quot; value=&quot;true&quot;/&gt;--&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="全自动方式"><a href="#全自动方式" class="headerlink" title="全自动方式"></a>全自动方式</h3><ol>
<li>编写目标类</li>
<li>编写通知</li>
<li>配置AOP<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--1 配置目标类--&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;an.s5.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--2 配置切面类--&gt;</span><br><span class="line">&lt;bean id=&quot;myAdvice&quot; class=&quot;an.s5.advice.MyAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--3 配置aop--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    proxy-target-class=&quot;true&quot;:使用cglib代理</span><br><span class="line">    &lt;aop:advisor&gt;</span><br><span class="line">        特殊的切面，只有一个通知 和 一个切入点</span><br><span class="line">        advice-ref 通知引用</span><br><span class="line">        pointcut-ref 切入点引用</span><br><span class="line">--&gt;</span><br><span class="line">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">  &lt;aop:pointcut id=&quot;pointcutID&quot; expression=&quot;execution(* an.s5.service.*.*(..))&quot;/&gt;</span><br><span class="line">  &lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut-ref=&quot;pointcutID&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="基于经典的SpringAOP"><a href="#基于经典的SpringAOP" class="headerlink" title="基于经典的SpringAOP"></a>基于经典的SpringAOP</h2><ul>
<li>使用aop联盟的通知类型</li>
<li>通知需要实现指定的接口</li>
</ul>
<h2 id="Spring-AspectJ"><a href="#Spring-AspectJ" class="headerlink" title="Spring+AspectJ"></a>Spring+AspectJ</h2><ul>
<li>使用AspectJ的通知类型</li>
</ul>
<h3 id="基于xml的AOP编程"><a href="#基于xml的AOP编程" class="headerlink" title="基于xml的AOP编程"></a>基于xml的AOP编程</h3><ol>
<li>编写目标类</li>
<li><p>编写通知类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdvice &#123;</span><br><span class="line">		public void myBefore(JoinPoint jp) &#123;</span><br><span class="line">		    System.out.println(&quot;前置通知 :name=&quot;+jp.getSignature().getName());</span><br><span class="line">		&#125;</span><br><span class="line">		public void myAfterReturning(JoinPoint jp,Object obj) &#123;</span><br><span class="line">		    System.out.println(&quot;后置通知 :return=&quot;+obj);</span><br><span class="line">		&#125;</span><br><span class="line">		public Object myAround(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">		    System.out.println(&quot;环绕通知...前&quot;);</span><br><span class="line">		    Object proceed = pjp.proceed();</span><br><span class="line">		    System.out.println(&quot;环绕通知...后&quot;);</span><br><span class="line">		    return proceed;</span><br><span class="line">		&#125;</span><br><span class="line">		public void myAfterThrowning() &#123;</span><br><span class="line">		    System.out.println(&quot;异常通知&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		public void myAfter() &#123;</span><br><span class="line">		    System.out.println(&quot;最终通知&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置aop织入通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置目标类--&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;an.s6.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--配置通知类--&gt;</span><br><span class="line">&lt;bean id=&quot;myAdvice&quot; class=&quot;an.s6.advice.MyAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--aop配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:aspect id=&quot;aspectID&quot; ref=&quot;myAdvice&quot;&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pontcutID&quot; expression=&quot;execution(* an.s6.service.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;</span><br><span class="line">        &lt;aop:before method=&quot;myBefore&quot; pointcut-ref=&quot;pontcutID&quot;/&gt;</span><br><span class="line">        &lt;aop:after-returning method=&quot;myAfterReturning&quot; pointcut-ref=&quot;pontcutID&quot; returning=&quot;obj&quot;/&gt;</span><br><span class="line">        &lt;aop:around method=&quot;myAround&quot; pointcut-ref=&quot;pontcutID&quot;/&gt;</span><br><span class="line">        &lt;aop:after-throwing method=&quot;myAfterThrowning&quot; pointcut-ref=&quot;pontcutID&quot;/&gt;</span><br><span class="line">        &lt;aop:after method=&quot;myAfter&quot; pointcut-ref=&quot;pontcutID&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;aop:aspect&gt;</code><ul>
<li>用于配置切面</li>
</ul>
</li>
<li><code>&lt;aop:pointcut&gt;</code><ul>
<li>配置切入点</li>
<li>如果此标签在<code>&lt;/aop:config&gt;</code>下与<code>&lt;aop:aspect&gt;</code>平级<ul>
<li>则必须写在<code>&lt;aop:aspect&gt;</code>之前，且多个<code>&lt;aop:aspect&gt;</code>中都可以使用</li>
</ul>
</li>
<li>如果在<code>&lt;aop:aspect&gt;</code>下<ul>
<li>则只能当前<code>&lt;aop:aspect&gt;</code>使用</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;aop:after-returning&gt;</code><ul>
<li>如果定义的后置通知方法有第二个参数<code>Object xxx</code>,则需配置<code>returning=&quot;xxx&quot;</code></li>
</ul>
</li>
<li><code>&lt;aop:after-throwing&gt;</code><ul>
<li>如果定义的异常通知方法有第二个参数<code>Throwable xxx</code>,则需配置<code>throw=&quot;xxx&quot;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="基于注解的AOP编程"><a href="#基于注解的AOP编程" class="headerlink" title="基于注解的AOP编程"></a>基于注解的AOP编程</h3><ol>
<li>手动编写目标类</li>
<li>手动使用注解编写通知类，并织入<ul>
<li>类<ul>
<li><code>@Aspect</code><ul>
<li>声明切面</li>
</ul>
</li>
</ul>
</li>
<li>方法<ul>
<li><code>@PointCut</code><ul>
<li>相当于声明了一个切入点，id是方法名</li>
<li>在其它通知方法上<ul>
<li><code>@Xxx(&quot;execution(表达式)&quot;)</code><ul>
<li>相当于使用一个自己定义的切入点表达式</li>
</ul>
</li>
<li><code>@Xxx(value=&quot;声明切入点的方法名（方法带括号）&quot;)</code><ul>
<li>相当于引入一个切入点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>@Before</code></li>
<li><code>@AfterReturning</code><ul>
<li><code>returning=&quot;第二个参数Object xxx&quot;</code></li>
</ul>
</li>
<li><code>@Around</code></li>
<li><code>@AfterThrowing</code><ul>
<li><code>throwing=&quot;第二个参数Throwable xxx&quot;</code></li>
</ul>
</li>
<li><code>@After</code></li>
</ul>
</li>
</ul>
</li>
<li>开启aop注解<ol>
<li><code>&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code></li>
<li><code>@EnableAspectJAutoProxy</code><ul>
<li>配置在注解配置类上（带<code>@Configuraction</code>的）</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="JDBC-Template"><a href="#JDBC-Template" class="headerlink" title="JDBC Template"></a>JDBC Template</h1><ul>
<li>spring 提供用于操作JDBC工具类，类似：DBUtils。</li>
<li>依赖<ul>
<li>DataSource （数据源）</li>
</ul>
</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="手动创建方式-了解"><a href="#手动创建方式-了解" class="headerlink" title="手动创建方式 (了解)"></a>手动创建方式 (了解)</h3><ol>
<li>创建数据源<ul>
<li><code>DriverManagerDataSource</code><ul>
<li>spring内置数据源</li>
</ul>
</li>
<li><code>ComboPooledDataSource</code><ul>
<li>c3p0数据源</li>
</ul>
</li>
<li><code>BasicDataSource</code><ul>
<li>dbcp数据源</li>
</ul>
</li>
</ul>
</li>
<li>创建JdbcTemplate，并设置数据源（构造/set方法）<ul>
<li><code>JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);</code></li>
</ul>
</li>
<li>使用jdbcTemplate操作 </li>
</ol>
<h3 id="spring-ioc之JdbcTemplate"><a href="#spring-ioc之JdbcTemplate" class="headerlink" title="spring ioc之JdbcTemplate"></a>spring ioc之JdbcTemplate</h3><ul>
<li>xml或注解配置使用</li>
</ul>
<ol>
<li>创建dao 并持有JdbcTemplate</li>
<li>spring配置 <ol>
<li>配置数据源bean</li>
<li>配置JdbcTemplate bean，并注入数据源</li>
<li>配置dao bean，并注入JdbcTemplate bean</li>
</ol>
</li>
<li>dao中直接使用JdbcTemplate操作</li>
</ol>
<h3 id="spring-ioc之-JdbcDaoSupport"><a href="#spring-ioc之-JdbcDaoSupport" class="headerlink" title="spring ioc之 JdbcDaoSupport"></a>spring ioc之 JdbcDaoSupport</h3><ul>
<li>xml配置使用</li>
</ul>
<ol>
<li><p>创建dao 继承<code>JdbcDaoSupport</code></p>
<ul>
<li><p>JdbcDaoSupport</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate getJdbcTemplate()&#123;&#125;</span><br><span class="line">void setDataSource(DataSource dataSource)&#123;</span><br><span class="line">	if (jdbcTemplate == null) &#123;</span><br><span class="line">		jdbcTemplate = createJdbcTemplate(DataSource dataSource);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">JdbcTemplate createJdbcTemplate(DataSource dataSource)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只要给dao注入了数据源，就可以创建JdbcTemplate</p>
</li>
</ul>
</li>
<li>spring配置<ol>
<li>配置数据源bean</li>
<li>配置dao bean，并注入数据源</li>
</ol>
</li>
<li>dao中直接使用<code>getJdbcTemplate()</code>获取JdbcTemplate进行操作</li>
</ol>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><ul>
<li><code>int update(String sql, Object... obj)</code></li>
</ul>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li><code>List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, Object... obj)</code><ul>
<li>查询结果封装为javabean对象，然后封装到list集合</li>
<li>查询所有</li>
<li>查询一个，集合中只有一个获取即可。</li>
</ul>
</li>
<li><code>T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... obj)</code><ul>
<li>查询一行一列</li>
<li>一般用于聚合函数的查询</li>
</ul>
</li>
<li><code>Map&lt;String, Object&gt; queryForMap(String sql, Object... obj)</code><ul>
<li>查询的结果集封装为map集合</li>
<li>此方法查询结果集长度只能是1<ul>
<li>列名为key，列值为value</li>
</ul>
</li>
</ul>
</li>
<li><code>List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... obj)</code><ul>
<li>将每一条记录封装为map集合，然后将map集合封装到list集合中</li>
</ul>
</li>
</ul>
<h4 id="RowMapper"><a href="#RowMapper" class="headerlink" title="RowMapper"></a>RowMapper</h4><ul>
<li>类似于DBUtils的ResultSetHandler</li>
<li>可以自己实现，也可使用spring提供的</li>
</ul>
<h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><ul>
<li><code>T mapRow(ResultSet rs, int rowNum)</code></li>
</ul>
<h5 id="Spring提供的RowMapper实现"><a href="#Spring提供的RowMapper实现" class="headerlink" title="Spring提供的RowMapper实现"></a>Spring提供的RowMapper实现</h5><h6 id="BeanPropertyRowMapper"><a href="#BeanPropertyRowMapper" class="headerlink" title="BeanPropertyRowMapper"></a>BeanPropertyRowMapper</h6><ul>
<li>将结果集封装为对象</li>
</ul>
<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><h2 id="三个顶级接口"><a href="#三个顶级接口" class="headerlink" title="三个顶级接口"></a>三个顶级接口</h2><h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ul>
<li>平台事务管理器 <code>spring-tx.jar</code>中</li>
<li>因为不同平台，操作事务的代码各不相同，spring提供了此接口</li>
<li>spring要管理事务，必须使用事务管理器</li>
</ul>
<h4 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h4><ul>
<li><code>TransactionStatus getTransaction(TransactionDefinition definition)</code><ul>
<li>事务管理器 通过“事务详情”，获得“事务状态”，从而管理事务。</li>
</ul>
</li>
<li><code>void commit(TransactionStatus status)</code><ul>
<li>根据状态提交</li>
</ul>
</li>
<li><code>void rollback(TransactionStatus status)</code><ul>
<li>根据状态回滚</li>
</ul>
</li>
</ul>
<h4 id="事务管理器（实现）"><a href="#事务管理器（实现）" class="headerlink" title="事务管理器（实现）"></a>事务管理器（实现）</h4><h5 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h5><ul>
<li>jdbc开发时事务管理器，采用JdbcTemplate</li>
<li>在<code>spring-jdbc.jar</code>中</li>
</ul>
<h5 id="HibernateTransactionManager"><a href="#HibernateTransactionManager" class="headerlink" title="HibernateTransactionManager"></a>HibernateTransactionManager</h5><ul>
<li>hibernate开发时事务管理器，整合hibernate时用</li>
<li>在<code>spring-orm.jar</code>中</li>
</ul>
<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><ul>
<li>事务详情（事务定义、事务属性）</li>
<li>spring用于确定事务具体详情<ul>
<li>例如：隔离级别、是否只读、超时时间 等</li>
</ul>
</li>
<li>进行事务配置时，必须配置详情。spring将配置项封装到该对象实例</li>
</ul>
<h4 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h4><ul>
<li><code>getPropagationBehavior()</code><ul>
<li>获取传播行为</li>
<li>传播行为：在两个业务之间如何共享事务。</li>
</ul>
</li>
<li><code>getName()</code><ul>
<li>配置事务详情名称</li>
</ul>
</li>
<li><code>isReadOnly()</code><ul>
<li>是否只读(增删改：读写，查：只读)</li>
<li>默认非只读</li>
</ul>
</li>
<li><code>getTimeout()</code><ul>
<li>获取超时时间。</li>
</ul>
</li>
<li><code>getIsolationlevel()</code><ul>
<li>获取隔离级别</li>
<li>隔离级别<ul>
<li>0 1 2 4 8</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><h5 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h5><ul>
<li>如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为</li>
</ul>
<h5 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h5><ul>
<li><strong>PROPAGATION_REQUIRED</strong> (required 必须)(默认值)<ul>
<li>支持当前事务<ul>
<li>如果A有事务，B将使用该事务。</li>
<li>如果A没有事务，B将创建一个新的事务。</li>
</ul>
</li>
</ul>
</li>
<li>PROPAGATION_SUPPORTS (supports 支持)<ul>
<li>支持当前事务<ul>
<li>如果A有事务，B将使用该事务。</li>
<li>如果A没有事务，B将以非事务执行。</li>
</ul>
</li>
</ul>
</li>
<li>PROPAGATION_MANDATORY (mandatory 强制)<ul>
<li>支持当前事务<ul>
<li>如果A有事务，B将使用该事务。</li>
<li>如果A没有事务，B将抛异常</li>
</ul>
</li>
</ul>
</li>
<li><strong>PROPAGATION_REQUIRES_NEW</strong> (requires_new 必须新的)<ul>
<li>如果A有事务，将A的事务挂起，B创建一个新的事务</li>
<li>如果A没有事务，B创建一个新的事务</li>
</ul>
</li>
<li>PROPAGATION_NOT_SUPPORTED (not_supported 不支持)<ul>
<li>如果A有事务，将A的事务挂起，B将以非事务执行</li>
<li>如果A没有事务，B将以非事务执行</li>
</ul>
</li>
<li>PROPAGATION_NEVER (never 从不)<ul>
<li>如果A有事务，B将抛异常</li>
<li>如果A没有事务，B将以非事务执行</li>
</ul>
</li>
<li><strong>PROPAGATION_NESTED</strong> (nested 嵌套)<ul>
<li>A和B底层采用保存点机制，形成嵌套事务。</li>
</ul>
</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul>
<li><code>ISOLATION_DEFAULT</code><ul>
<li>默认</li>
<li>表示底层使用数据库的默认隔离级别</li>
</ul>
</li>
<li><code>ISOLATION_READ_UNCOMMITTED</code></li>
<li><code>ISOLATION_READ_COMMITTED</code></li>
<li><code>ISOLATION_REPEATABLE_READ</code></li>
<li><code>ISOLATION_SERIALIZABLE</code></li>
</ul>
<h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><ul>
<li>事务状态，spring用于记录当前事务运行状态。<ul>
<li>例如：是否有保存点，事务是否完成。</li>
</ul>
</li>
<li>spring底层根据状态进行相应操作。</li>
</ul>
<h4 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h4><ul>
<li><code>isNewtransaction()</code><ul>
<li>是否是新的事务</li>
</ul>
</li>
<li><code>hasSavepoint()</code></li>
<li><code>setRollbackOnly()</code></li>
<li><code>isRollbackOnly()</code></li>
<li><code>flush()</code></li>
<li><code>isCompleted()</code></li>
</ul>
<h2 id="事务管理详解"><a href="#事务管理详解" class="headerlink" title="事务管理详解"></a>事务管理详解</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><ul>
<li>spirng底层使用TransactionTemplate模板管理事务。<ul>
<li>模板需要注入事务管理器</li>
<li>事务管理器需要事务</li>
<li>事务从Connection获得</li>
<li>Connection不管直接创建还是从连接池中获得都需要数据源</li>
<li>所以事务管理器需要注入数据源DataSource</li>
</ul>
</li>
</ul>
<h3 id="手动管理事务-了解"><a href="#手动管理事务-了解" class="headerlink" title="手动管理事务(了解)"></a>手动管理事务(了解)</h3><ol>
<li>配置TransactionTemplate，并注入Service中</li>
<li>配置事务管理器，并注入到TransactionTemplate中</li>
<li>Service中业务方法中使用事务模板操作<ul>
<li><code>transactionTemplate.execute();</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) &#123;</span><br><span class="line">        accountDao.raise(to, money);</span><br><span class="line">        int i = 1/0;</span><br><span class="line">        accountDao.reduce(from, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="半自动管理事务"><a href="#半自动管理事务" class="headerlink" title="半自动管理事务"></a>半自动管理事务</h3><ol>
<li>使用工厂bean生成代理</li>
<li>为代理对象注入事务管理器及事务详情</li>
<li>使用代理对象执行业务方法</li>
</ol>
<h4 id="TransactionProxyFactoryBean"><a href="#TransactionProxyFactoryBean" class="headerlink" title="TransactionProxyFactoryBean"></a>TransactionProxyFactoryBean</h4><ul>
<li>spring提供 管理事务的代理工厂bean<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 4 service 代理对象 </span><br><span class="line">	4.1 proxyInterfaces 接口 </span><br><span class="line">	4.2 target 目标类</span><br><span class="line">	4.3 transactionManager 事务管理器</span><br><span class="line">	4.4 transactionAttributes 事务属性（事务详情）</span><br><span class="line">		prop.key ：确定哪些方法使用当前事务配置</span><br><span class="line">		prop.text:用于配置事务详情</span><br><span class="line">			格式：PROPAGATION,ISOLATION,readOnly,-Exception,+Exception</span><br><span class="line">				传播行为		隔离级别	是否只读		异常回滚		异常提交</span><br><span class="line">			例如：</span><br><span class="line">				&lt;prop key=&quot;save&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;/prop&gt; 默认传播行为，和隔离级别</span><br><span class="line">				&lt;prop key=&quot;add&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly&lt;/prop&gt; 只读</span><br><span class="line">				&lt;prop key=&quot;add&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT,+java.lang.ArithmeticException&lt;/prop&gt;  有异常扔提交</span><br><span class="line">--&gt;</span><br><span class="line">&lt;bean id=&quot;proxyAccountService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.itheima.service.AccountService&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;target&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;transactionAttributes&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;方法名&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自动管理事务"><a href="#自动管理事务" class="headerlink" title="自动管理事务"></a>自动管理事务</h3><ol>
<li>spring配置aop自动生成代理，进行事务管理</li>
<li>Aop从连接点中选出切入点</li>
<li>TxAdvice从切入点中再次筛选，确定哪些方法需要什么样的事务</li>
</ol>
<h4 id="Aop配置事务基于xml"><a href="#Aop配置事务基于xml" class="headerlink" title="Aop配置事务基于xml"></a>Aop配置事务基于xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--事务管理器--&gt;</span><br><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--事务详情--&gt;&lt;!--对什么方法使用什么样的事务 readOnly默认false--&gt;</span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; readOnly=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line">&lt;!--aop配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;pointcutID&quot; expression=&quot;execution(* an.s8.service.*.*(..))&quot;/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcutID&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Aop配置事务基于注解"><a href="#Aop配置事务基于注解" class="headerlink" title="Aop配置事务基于注解"></a>Aop配置事务基于注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 将事务管理器交予spring --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@Transactional</code><ul>
<li>事务详情的配置在注解的括号里</li>
<li>用在类上<ul>
<li>所有方法都开事务</li>
</ul>
</li>
<li>用在方法上<ul>
<li>此方法开事务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="spring整合junit"><a href="#spring整合junit" class="headerlink" title="spring整合junit"></a>spring整合junit</h1><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><ul>
<li><code>junti的jar包</code></li>
<li><code>spring核心4+1</code></li>
<li><code>spring-test.jar</code></li>
</ul>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><ul>
<li>与junit整合,不需要在spring配置中配置扫描</li>
</ul>
<h3 id="RunWith-SpringJunit4ClassRunner-class"><a href="#RunWith-SpringJunit4ClassRunner-class" class="headerlink" title="@RunWith(SpringJunit4ClassRunner.class)"></a>@RunWith(SpringJunit4ClassRunner.class)</h3><ul>
<li>在类上</li>
<li>替换原有运行器</li>
</ul>
<h3 id="ContextConfiguration"><a href="#ContextConfiguration" class="headerlink" title="@ContextConfiguration"></a>@ContextConfiguration</h3><ul>
<li><code>location</code><ul>
<li>指定spring配置文件的位置，类路径要加<code>classpath:</code></li>
</ul>
</li>
<li><code>classes</code><ul>
<li>用于指定注解的配置类。当不使用 xml 配置时，需要用此属性指定注解类的位置</li>
</ul>
</li>
</ul>
<h3 id="Autowired-1"><a href="#Autowired-1" class="headerlink" title="@Autowired"></a>@Autowired</h3><ul>
<li>注入数据</li>
</ul>
<h1 id="spring整合web"><a href="#spring整合web" class="headerlink" title="spring整合web"></a>spring整合web</h1><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><ul>
<li>普通java项目<ul>
<li>我们手动读取spring配置，创建spring容器。</li>
</ul>
</li>
<li>web项目<ul>
<li>服务器启动就创建spring容器。(安)</li>
</ul>
</li>
</ul>
<h2 id="web技术之服务器-tomcat-一启动就加载配置文件的方式"><a href="#web技术之服务器-tomcat-一启动就加载配置文件的方式" class="headerlink" title="web技术之服务器(tomcat)一启动就加载配置文件的方式"></a>web技术之服务器(tomcat)一启动就加载配置文件的方式</h2><ol>
<li>Servlet<ul>
<li><code>init(ServletConfig config)</code><ul>
<li><code>&lt;load-on-startup&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>Filter<ul>
<li><code>init(FilterConfig config)</code><ul>
<li><code>web.xml</code>注册过滤器自动调用初始化</li>
</ul>
</li>
</ul>
</li>
<li>Listener<ul>
<li><code>ServletContextListener</code><ul>
<li><code>web.xml</code>中配置监听器</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>spring使用的是<strong>Listener</strong><ul>
<li>spring提供了<code>ContextLoaderListener</code>监听器<ul>
<li><code>spring-web.jar</code>中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="spring监听器的配置"><a href="#spring监听器的配置" class="headerlink" title="spring监听器的配置"></a>spring监听器的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>此监听器默认加载的是<code>WEB-INF/applicationContext.xml</code></li>
<li>而我们的配置文件通常在src下即<code>WEB-INF/classes/applicationContext.cml</code></li>
<li>通过配置参数指定配置文件</li>
</ul>
<h2 id="手动获取spring容器"><a href="#手动获取spring容器" class="headerlink" title="手动获取spring容器"></a>手动获取spring容器</h2><ul>
<li>一般一个应用中只有一份spring容器放在ServletContext域中</li>
</ul>
<ol>
<li>从application域中根据key获取容器,spring把key封装成了一个常量<code>ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code><br> <code>this.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</code></li>
<li>通过工具类（WebApplicationContextUtils）获取，其实是封装了方法一<ul>
<li><code>WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());</code></li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    <div>
      
    </div>

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://github.com/awcnoanswer/myPicture/raw/master/headPic/swk.png"
                alt="安₃" />
            
              <p class="site-author-name" itemprop="name">安₃</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">59</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安₃</span>

  

  
</div>



<!--





-->





        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  


<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>
</html>
